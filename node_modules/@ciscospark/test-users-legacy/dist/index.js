"use strict";

var _assign = require("babel-runtime/core-js/object/assign");

var _assign2 = _interopRequireDefault(_assign);

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var assert = require("assert");
var btoa = require("btoa");
var _ = require("lodash");
var randomName = require("node-random-name");
var generateRandomString = require("./generate-random-string.js");
var request = require("./request");

// eslint-disable-next-line func-names
var CONVERSATION_SERVICE = function () {
  var cs = process.env.CONVERSATION_SERVICE_URL || process.env.CONVERSATION_SERVICE;
  if (!cs && process.env.WDM_SERVICE_URL) {
    if (process.env.WDM_SERVICE_URL.includes("wdm-integration")) {
      cs = "https://conv-a.wbx2.com/conversation/api/v1";
    }
    if (process.env.WDM_SERVICE_URL.includes("wdm-a")) {
      cs = "https://conv-a.wbx2.com/conversation/api/v1";
    }
  }

  if (!cs) {
    cs = "https://conv-a.wbx2.com/conversation/api/v1";
  }
  return cs;
}();
var BASE_PATH_SECURE = CONVERSATION_SERVICE + "/users/test_users_s";
var BASE_PATH = CONVERSATION_SERVICE + "/users/test_users";

/**
 * Computes `expires` and `refresh_token_expires` from `expires_in` and
 * `refresh_token_expires_in` and creates an `authorization` string.
 * @param {Object} token
 * @private
 * @returns {Object}
 */
function fixToken(token) {
  var now = Date.now();
  if (token.expires_in && !token.expires) {
    token.expires = now + token.expires_in * 1000;
  }

  if (token.refresh_token_expires_in && !token.refresh_token_expires) {
    /* eslint camelcase: [0] */
    token.refresh_token_expires = now + token.refresh_token_expires_in * 1000;
  }

  if (token.token_type && token.access_token) {
    token.authorization = token.token_type + " " + token.access_token;
  }
  return token;
}

var clientToken = void 0;
/**
 * Fetches credentials to talk to the test_users_s endpoint
 * @param {Object} options
 * @private
 * @returns {String}
 */
function getClientCredentials(options) {
  if (clientToken) {
    return _promise2.default.resolve(clientToken);
  }
  var clientId = options.clientId || process.env.WEBEX_CLIENT_ID || process.env.CISCOSPARK_CLIENT_ID;
  assert(clientId, "options.clientId, process.env.WEBEX_CLIENT_ID, or process.env.CISCOSPARK_CLIENT_ID must be defined");
  var clientSecret = options.clientSecret || process.env.WEBEX_CLIENT_SECRET || process.env.CISCOSPARK_CLIENT_SECRET;
  assert(clientSecret, "options.clientSecret, process.env.WEBEX_CLIENT_SECRET, or process.env.CISCOSPARK_CLIENT_SECRET must be defined");

  return request({
    method: "POST",
    uri: (process.env.IDBROKER_BASE_URL || "https://idbroker.webex.com") + "/idb/oauth2/v1/access_token",
    json: true,
    form: {
      grant_type: "client_credentials",
      scope: "webexsquare:get_conversation",
      client_id: clientId,
      client_secret: clientSecret
    },
    headers: {
      // Note: we can't request's auth hash here because this endpoint expects
      // us to send the auth header *without including "Basic "* before the
      // token string
      authorization: btoa(clientId + ":" + clientSecret)
    }
  }).then(function (res) {
    var token = fixToken(res.body);
    return token.token_type + " " + token.access_token;
  }).then(function (token) {
    clientToken = token;
    return clientToken;
  });
}

/**
 * Makes a request authorized with client credentials
 * @param {Object} options
 * @private
 * @returns {Promise<HttpResponseObject>}
 */
function requestWithAuth(options) {
  return getClientCredentials(options.body).then(function (authorization) {
    options.headers = options.headers || {};
    options.headers.authorization = authorization;
    return request(options);
  });
}

/**
 * Creates a test user
 * @param {Object} options
 * @returns {Object}
 */
function create(options) {
  options = options || {};
  var body = _.defaultsDeep({}, options, {
    // The four characters on the end are to hit all the password requirements
    password: generateRandomString(10) + "zA1*",
    displayName: randomName(),
    clientId: process.env.WEBEX_CLIENT_ID || process.env.CISCOSPARK_CLIENT_ID,
    clientSecret: process.env.WEBEX_CLIENT_SECRET || process.env.CISCOSPARK_CLIENT_SECRET,
    emailTemplate: options.email || options.emailAddress,
    // defaultsDeep doesn't seem to handle arrays
    entitlements: options.entitlements || ["spark", "squaredCallInitiation", "squaredRoomModeration", "squaredInviter", "webExSquared"],
    scopes: options.scope || process.env.WEBEX_SCOPE || process.env.CISCOSPARK_SCOPE
  });

  return requestWithAuth({
    method: "POST",
    uri: BASE_PATH_SECURE,
    json: true,
    body: body
  }).then(function (res) {
    return (0, _assign2.default)({
      password: JSON.parse(res.request.body).password,
      emailAddress: res.body.user.email,
      displayName: res.body.user.name
    }, res.body.user, { token: fixToken(res.body.token) });
  });
}

/**
 * Exchanges a user name/password for an access token
 * @param {Object} options
 * @returns {Object}
 */
function login(options) {
  return request({
    method: "POST",
    uri: BASE_PATH + "/login",
    json: true,
    body: _.defaultsDeep(options, {
      clientId: process.env.WEBEX_CLIENT_ID || process.env.CISCOSPARK_CLIENT_ID,
      clientSecret: process.env.WEBEX_CLIENT_SECRET || process.env.CISCOSPARK_CLIENT_SECRET
    })
  }).then(function (res) {
    return fixToken(res.body);
  });
}

/**
 * Deletes a test user
 * @param {Object} options
 * @returns {Object}
 */
function remove(options) {
  if (!options) {
    return _promise2.default.reject(new Error("options is required"));
  }

  if (!options.id) {
    return _promise2.default.reject(new Error("options.id is required"));
  }

  if (!options.token) {
    return login(options).then(function (token) {
      return remove((0, _assign2.default)({ token: token }, options));
    });
  }

  assert(options.token.authorization, "options.token.authorization must be defined");

  return request({
    method: "POST",
    json: true,
    headers: {
      authorization: options.token.authorization
    },
    body: {
      /* eslint-disable camelcase */
      user_id: options.id,
      refresh_token: options.token.refresh_token
      /* eslint-enable camelcase */
    },
    uri: BASE_PATH + "/delete"
  });
}

var TestUsers = {
  create: create,

  login: login,

  remove: remove,

  delete: remove,

  generateRandomString: generateRandomString,

  request: request
};

module.exports = TestUsers;