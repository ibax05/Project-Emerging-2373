"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));
var _assign = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/assign"));
var _isArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/array/is-array"));
var _isArray3 = _interopRequireDefault(require("lodash/isArray"));
var _encryptTextProp = function _encryptTextProp(ctx, name, key, object) {
  if (!object[name]) {
    return _promise.default.resolve();
  }
  return ctx.webex.internal.encryption.encryptText(key.uri || key, object[name]).then(function (ciphertext) {
    object[name] = ciphertext;
  });
};
var _encryptCalendarEventPayload = function _encryptCalendarEventPayload(data, ctx) {
  (0, _assign.default)(data, {
    encryptionKeyUrl: ctx.encryptionKeyUrl
  });
  var encryptedAttendees = data.attendees ? data.attendees.map(function (attendee) {
    return _promise.default.all([_encryptTextProp(ctx, 'displayName', data.encryptionKeyUrl, attendee), _encryptTextProp(ctx, 'email', data.encryptionKeyUrl, attendee)]);
  }) : [];
  return _promise.default.all([_encryptTextProp(ctx, 'subject', data.encryptionKeyUrl, data), _encryptTextProp(ctx, 'notes', data.encryptionKeyUrl, data), _encryptTextProp(ctx, 'webexOptions', data.encryptionKeyUrl, data)].concat([encryptedAttendees]));
};
var _encryptFreeBusyPayload = function _encryptFreeBusyPayload(data, ctx) {
  (0, _assign.default)(data, {
    encryptionKeyUrl: ctx.encryptionKeyUrl
  });
  var promises = [];
  if (data.emails && (0, _isArray2.default)(data.emails)) {
    data.emails.map(function (item, index) {
      return promises.push(ctx.webex.internal.encryption.encryptText(data.encryptionKeyUrl, item).then(function (encryptText) {
        data.emails[index] = encryptText;
      }));
    });
  }
  return _promise.default.all(promises);
};
var EncryptHelper = {
  /**
   * Encrypt create / update calendar event request payload
   * @param {object} [ctx] context
   * @param {object} [data] meeting payload data
   * @returns {Promise} Resolves with encrypted request payload
   * */
  encryptCalendarEventRequest: function encryptCalendarEventRequest(ctx, data) {
    if (ctx.encryptionKeyUrl) {
      return _encryptCalendarEventPayload(data, ctx);
    }
    return ctx.webex.internal.encryption.kms.createUnboundKeys({
      count: 1
    }).then(function (keys) {
      var key = (0, _isArray3.default)(keys) ? keys[0] : keys;
      ctx.encryptionKeyUrl = key.uri;
      return _encryptCalendarEventPayload(data, ctx);
    });
  },
  /**
   * Encrypt free-busy request payload, if request payload only includes the sensitive data, like email, need to encrypt these reqeust parameters, and playload includes encrypt url.
   * Otherwise, don't encrypt playload and without encrypt url,Due to calendar serivce will vaild both encrypt url and sensitive that are both present. if not, will return 400 bad reqeust to caller.
   * @param {object} [ctx] context
   * @param {object} [data] free busy payload data
   * @returns {Promise} Resolves with encrypted request payload
   * */
  encryptFreeBusyRequest: function encryptFreeBusyRequest(ctx, data) {
    if (!data.emails || !(0, _isArray2.default)(data.emails)) {
      return _promise.default.resolve();
    }
    if (ctx.encryptionKeyUrl) {
      return _encryptFreeBusyPayload(data, ctx);
    }
    return ctx.webex.internal.encryption.kms.createUnboundKeys({
      count: 1
    }).then(function (keys) {
      var key = (0, _isArray3.default)(keys) ? keys[0] : keys;
      ctx.encryptionKeyUrl = key.uri;
      return _encryptFreeBusyPayload(data, ctx);
    });
  }
};
var _default = EncryptHelper;
exports.default = _default;
//# sourceMappingURL=calendar.encrypt.helper.js.map
