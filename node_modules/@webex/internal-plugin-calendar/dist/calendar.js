"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));
var _isArray2 = _interopRequireDefault(require("lodash/isArray"));
var _common = require("@webex/common");
var _webexCore = require("@webex/webex-core");
var _collection = _interopRequireDefault(require("./collection"));
var _constants = require("./constants");
var _calendarEncrypt = _interopRequireDefault(require("./calendar.encrypt.helper"));
var _calendarDecrypt = _interopRequireDefault(require("./calendar.decrypt.helper"));
var Calendar = _webexCore.WebexPlugin.extend({
  namespace: 'Calendar',
  /**
   * registered value indicating events registration is successful
   * @instance
   * @type {Boolean}
   * @memberof Calendar
   */
  registered: false,
  /**
   * Cache all rpc event request locally
   * */
  rpcEventRequests: [],
  /**
   * Cache KMS encryptionKeyUrl
   * */
  encryptionKeyUrl: null,
  /**
   * WebexPlugin initialize method. This triggers once Webex has completed its
   * initialization workflow.
   *
   * If the plugin is meant to perform startup actions, place them in this
   * `initialize()` method instead of the `constructor()` method.
   * @returns {void}
   */
  initialize: function initialize() {
    var _this = this;
    // Used to perform actions after webex is fully qualified and ready for
    // operation.
    this.listenToOnce(this.webex, 'ready', function () {
      // Pre-fetch a KMS encryption key url to improve performance
      _this.webex.internal.encryption.kms.createUnboundKeys({
        count: 1
      }).then(function (keys) {
        var key = (0, _isArray2.default)(keys) ? keys[0] : keys;
        _this.encryptionKeyUrl = key ? key.uri : null;
        _this.logger.info('calendar->bind a KMS encryption key url');
        _this.webex.internal.encryption.getKey(_this.encryptionKeyUrl, {
          onBehalfOf: null
        }).then(function (retrievedKey) {
          _this.encryptionKeyUrl = retrievedKey ? retrievedKey.uri : null;
          _this.logger.info('calendar->retrieve the KMS encryption key url and cache it');
        });
      });
    });
  },
  /**
   * Explicitly sets up the calendar plugin by registering
   * the device, connecting to mercury, and listening for calendar events.
   * @returns {Promise}
   * @public
   * @memberof Calendar
   */
  register: function register() {
    var _this2 = this;
    if (!this.webex.canAuthorize) {
      this.logger.error('calendar->register#ERROR, Unable to register, SDK cannot authorize');
      return _promise.default.reject(new Error('SDK cannot authorize'));
    }
    if (this.registered) {
      this.logger.info('calendar->register#INFO, Calendar plugin already registered');
      return _promise.default.resolve();
    }
    return this.webex.internal.device.register().then(function () {
      return _this2.webex.internal.mercury.connect();
    }).then(function () {
      _this2.listenForEvents();
      _this2.trigger(_constants.CALENDAR_REGISTERED);
      _this2.registered = true;
    }).catch(function (error) {
      _this2.logger.error("calendar->register#ERROR, Unable to register, ".concat(error.message));
      return _promise.default.reject(error);
    });
  },
  /**
   * Explicitly tears down the calendar plugin by deregistering
   * the device, disconnecting from mercury, and stops listening to calendar events
   *
   * @returns {Promise}
   * @public
   * @memberof Calendar
   */
  unregister: function unregister() {
    var _this3 = this;
    if (!this.registered) {
      this.logger.info('calendar->unregister#INFO, Calendar plugin already unregistered');
      return _promise.default.resolve();
    }
    this.stopListeningForEvents();
    return this.webex.internal.mercury.disconnect().then(function () {
      return _this3.webex.internal.device.unregister();
    }).then(function () {
      _this3.trigger(_constants.CALENDAR_UNREGISTERED);
      _this3.registered = false;
    });
  },
  /**
   * registers for calendar events through mercury
   * @returns {undefined}
   * @private
   */
  listenForEvents: function listenForEvents() {
    var _this4 = this;
    // Calendar mercury events listener
    this.webex.internal.mercury.on('event:calendar.meeting.create', function (envelope) {
      _this4._handleCreate(envelope.data);
    });
    this.webex.internal.mercury.on('event:calendar.meeting.update', function (envelope) {
      _this4._handleUpdate(envelope.data);
    });
    this.webex.internal.mercury.on('event:calendar.meeting.create.minimal', function (envelope) {
      _this4._handleCreate(envelope.data);
    });
    this.webex.internal.mercury.on('event:calendar.meeting.update.minimal', function (envelope) {
      _this4._handleUpdate(envelope.data);
    });
    this.webex.internal.mercury.on('event:calendar.meeting.delete', function (envelope) {
      _this4._handleDelete(envelope.data);
    });
    this.webex.internal.mercury.on('event:calendar.free_busy', function (envelope) {
      _this4._handleFreeBusy(envelope.data);
    });
  },
  /**
   * unregisteres all the calendar events from mercury
   * @returns {undefined}
   * @private
   */
  stopListeningForEvents: function stopListeningForEvents() {
    this.webex.internal.mercury.off('event:calendar.meeting.create');
    this.webex.internal.mercury.off('event:calendar.meeting.create.minimal');
    this.webex.internal.mercury.off('event:calendar.meeting.update');
    this.webex.internal.mercury.off('event:calendar.meeting.update.minimal');
    this.webex.internal.mercury.off('event:calendar.meeting.delete');
    this.webex.internal.mercury.off('event:calendar.free_busy');
  },
  /**
   * handles update events, triggers after collection updates
   * @param {Object} data
   * @returns {undefined}
   * @private
   */
  _handleUpdate: function _handleUpdate(data) {
    var id = _collection.default.set(data.calendarMeetingExternal);
    this.trigger(_constants.CALENDAR_UPDATED, _collection.default.get(id));
  },
  /**
   * handles create events, triggers after collection updates
   * @param {Object} data
   * @returns {undefined}
   * @private
   */
  _handleCreate: function _handleCreate(data) {
    var id = _collection.default.set(data.calendarMeetingExternal);
    this.trigger(_constants.CALENDAR_CREATE, _collection.default.get(id));
  },
  /**
   * handles delete events, triggers after collection updates
   * @param {Object} data
   * @returns {undefined}
   * @private
   */
  _handleDelete: function _handleDelete(data) {
    var item = _collection.default.remove(data.calendarMeetingExternal.id);
    this.trigger(_constants.CALENDAR_DELETE, item);
  },
  /**
   * handles free_busy events
   * @param {Object} data
   * @returns {undefined}
   * @private
   */
  _handleFreeBusy: function _handleFreeBusy(data) {
    var _this5 = this;
    _calendarDecrypt.default.decryptFreeBusyResponse(this, data).then(function () {
      var response = {};
      if (data && data.calendarFreeBusyScheduleResponse) {
        response = data.calendarFreeBusyScheduleResponse;
      }
      if (response && response.requestId && response.requestId in _this5.rpcEventRequests) {
        _this5.logger.log("webex.internal.calendar - receive requests, requestId: ".concat(response.requestId));
        delete response.encryptionKeyUrl;
        var resolve = _this5.rpcEventRequests[response.requestId].resolve;
        resolve(response);
        delete _this5.rpcEventRequests[response.requestId];
      } else {
        _this5.logger.log('webex.internal.calendar - receive other requests.');
      }
    });
  },
  /**
   * Retrieves a collection of calendars based on the request parameters
   * Defaults to 1 day before and 7 days ahead
   * @param {Object} options
   * @param {Date} options.fromDate the start of the time range
   * @param {Date} options.toDate the end of the time range
   * @returns {Promise} Resolves with an array of calendars
   */
  syncCalendar: function syncCalendar() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      fromDate: this.config.fromDate,
      toDate: this.config.toDate
    };
    return this.list({
      fromDate: options.fromDate,
      toDate: options.toDate
    }).then(function (res) {
      _collection.default.setAll(res);
      return _collection.default.getAll();
    });
  },
  /**
   * get the calendar item that has a matching value
   * @param {String} key meeting property
   * @param {Any} value the meeting property to match
   * @returns {Object}
   */
  getByType: function getByType(key, value) {
    if (['spaceURI', 'spaceMeetURL', 'conversationId'].includes(key)) {
      return _collection.default.getBy(key, value);
    }
    throw new Error('key must be one of, spaceURI, spaceMeetURL, or conversationId');
  },
  /**
   * gets all the calendar items that have been populated
   * @returns {Object}
   */
  getAll: function getAll() {
    return _collection.default.getAll();
  },
  /**
   * Decrypts an encrypted incoming calendar event
   * @param {Object} event
   * @returns {Promise} Resolves with a decrypted calendar event
   */
  processMeetingEvent: function processMeetingEvent(event) {
    return this.webex.transform('inbound', event).then(function () {
      return event;
    });
  },
  /**
   * Retrieves an array of meeting participants for the meeting id
   * @param {String} id
   * @returns {Promise} Resolves with an object of meeting participants
   */
  getParticipants: function getParticipants(id) {
    return this.request({
      method: 'GET',
      service: 'calendar',
      resource: "calendarEvents/".concat(_common.base64.encode(id), "/participants")
    });
  },
  /**
   * Retrieves a collection of meetings based on the request parameters
   * @param {String} id
   * @returns {Promise} Resolves with an object of meeting notes
   */
  getNotes: function getNotes(id) {
    return this.request({
      method: 'GET',
      service: 'calendar',
      resource: "calendarEvents/".concat(_common.base64.encode(id), "/notes")
    });
  },
  /**
   * Retrieves a collection of meetings based on the request parameters
   * @param {Object} options
   * @param {Date} options.fromDate the start of the time range
   * @param {Date} options.toDate the end of the time range
   * @returns {Promise} Resolves with an array of meetings
   */
  list: function list(options) {
    var _this6 = this;
    options = options || {};
    return this.webex.request({
      method: 'GET',
      service: 'calendar',
      resource: 'calendarEvents',
      qs: options
    }).then(function (res) {
      var meetingObjects = res.body.items;
      var promises = [];
      meetingObjects.forEach(function (meeting) {
        if (!meeting.encryptedParticipants) {
          promises.push(_this6.getParticipants(meeting.id).then(function (notesResponse) {
            meeting.encryptedParticipants = notesResponse.body.encryptedParticipants;
          }));
        }
      });
      return _promise.default.all(promises).then(function () {
        return meetingObjects;
      });
    });
  },
  /**
   * Create calendar event
   * @param {object} [data] meeting payload data
   * @param {object} [query] the query parameters for specific usage
   * @returns {Promise} Resolves with creating calendar event response
   * */
  createCalendarEvent: function createCalendarEvent(data, query) {
    var _this7 = this;
    return _calendarEncrypt.default.encryptCalendarEventRequest(this, data).then(function () {
      return _this7.request({
        method: 'POST',
        service: 'calendar',
        body: data,
        resource: 'calendarEvents/sync',
        qs: query || {}
      });
    });
  },
  /**
   * Update calendar event
   * @param {string} [id] calendar event id
   * @param {object} [data] meeting payload data
   * @param {object} [query] the query parameters for specific usage
   * @returns {Promise} Resolves with updating calendar event response
   * */
  updateCalendarEvent: function updateCalendarEvent(id, data, query) {
    var _this8 = this;
    return _calendarEncrypt.default.encryptCalendarEventRequest(this, data).then(function () {
      return _this8.request({
        method: 'PATCH',
        service: 'calendar',
        body: data,
        resource: "calendarEvents/".concat(_common.base64.encode(id), "/sync"),
        qs: query || {}
      });
    });
  },
  /**
   * Delete calendar event
   * @param {string} [id] calendar event id
   * @param {object} [query] the query parameters for specific usage
   * @returns {Promise} Resolves with deleting calendar event response
   * */
  deleteCalendarEvent: function deleteCalendarEvent(id, query) {
    return this.request({
      method: 'DELETE',
      service: 'calendar',
      resource: "calendarEvents/".concat(_common.base64.encode(id), "/sync"),
      qs: query || {}
    });
  },
  /**
   * @typedef QuerySchedulerDataOptions
   * @param {string} [siteName] it is site full url, must have. Example: ccctest.dmz.webex.com
   * @param {string} [id] it is seriesOrOccurrenceId. If present, the series/occurrence meeting ID to fetch data for.
   *                      Example: 040000008200E00074C5B7101A82E008000000004A99F11A0841D9010000000000000000100000009EE499D4A71C1A46B51494C70EC7BFE5
   * @param {string} [clientMeetingId] If present, the client meeting UUID to fetch data for.
   *                      Example: 7f318aa9-887c-6e94-802a-8dc8e6eb1a0a
   * @param {string} [scheduleTemplateId] it template id.
   * @param {string} [sessionTypeId] it session type id.
   * @param {string} [organizerCIUserId] required in schedule-on-behalf case. It is the organizer's CI UUID.
   * @param {boolean} [usmPreference]
   * @param {string} [webexMeetingId] webex side meeting UUID
   * @param {string} [eventId] event ID.
   * @param {string} [icalUid] icalendar UUID.
   * @param {string} [thirdPartyType] third part type, such as: Microsoft
   */
  /**
   * Get scheduler data from calendar service
   * @param {QuerySchedulerDataOptions} [query] the command parameters for fetching scheduler data.
   * @returns {Promise} Resolves with a decrypted scheduler data
   * */
  getSchedulerData: function getSchedulerData(query) {
    var _this9 = this;
    return this.request({
      method: 'GET',
      service: 'calendar',
      resource: 'schedulerData',
      qs: query || {}
    }).then(function (response) {
      return _calendarDecrypt.default.decryptSchedulerDataResponse(_this9, response.body).then(function () {
        return response;
      });
    });
  },
  /**
   * Get free busy status from calendar service
   * @param {Object} [data] the command parameters for fetching free busy status.
   * @param {object} [query] the query parameters for specific usage
   * @returns {Promise} Resolves with a decrypted response
   * */
  getFreeBusy: function getFreeBusy(data, query) {
    var _this10 = this;
    return _calendarEncrypt.default.encryptFreeBusyRequest(this, data).then(function () {
      return _this10.request({
        method: 'POST',
        service: 'calendar',
        body: data,
        resource: 'freebusy',
        qs: query || {}
      });
    }).then(function () {
      return new _promise.default(function (resolve, reject) {
        _this10.rpcEventRequests[data.requestId] = {
          resolve: resolve,
          reject: reject
        };
      });
    }).catch(function (error) {
      throw error;
    });
  },
  version: "2.59.8"
});
var _default = Calendar;
exports.default = _default;
//# sourceMappingURL=calendar.js.map
