"use strict";

var _Object$keys = require("@babel/runtime-corejs2/core-js/object/keys");
var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");
var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");
var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");
var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");
var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.isMatchingFile = exports.isBufferLike = exports.isBlobLike = exports.fetchWithoutMagic = exports.fetch = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/slicedToArray"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));
var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));
var _fs = require("fs");
var _path = require("path");
var _fileType = require("file-type");
var _common = require("@webex/common");
function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } return target; }
var fetchWithoutMagic = function fetchWithoutMagic(filename) {
  return new _promise.default(function (resolve, reject) {
    var filepath = (0, _path.join)(__dirname, '../../../@webex/test-helper-server/static', filename);
    (0, _fs.readFile)(filepath, function (err, data) {
      if (err) {
        reject(err);
        return;
      }
      resolve(_objectSpread(_objectSpread({}, data), {}, {
        name: filename
      }));
    });
  });
};
exports.fetchWithoutMagic = fetchWithoutMagic;
var fetch = function fetch(filename) {
  return fetchWithoutMagic(filename).then(function (data) {
    return _promise.default.all([(0, _fileType.fromFile)(data), data]);
  })
  // .then(([{mime: type}, data]) => {
  //   console.error(data, type);

  //   return {...data, type};
  // });
  .then(function (_ref) {
    var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
      type = _ref2[0].mime,
      data = _ref2[1];
    return type ? _objectSpread(_objectSpread({}, data), {}, {
      type: type
    }) : _promise.default.reject(new Error('Invalid Media Type'));
  });
};
exports.fetch = fetch;
var isBufferLike = function isBufferLike(file) {
  return (0, _common.isBuffer)(file);
};
exports.isBufferLike = isBufferLike;
var isBlobLike = function isBlobLike(file) {
  return (0, _common.isBuffer)(file);
};
exports.isBlobLike = isBlobLike;
var isMatchingFile = function isMatchingFile(left, right) {
  if (!isBufferLike(left)) {
    throw new Error('`left` must be a `Buffer`');
  }
  if (!isBufferLike(right)) {
    throw new Error('`right` must be a `Buffer`');
  }

  // Node 10 doesn't have Buffer#equals()
  if (left.equals) {
    return _promise.default.resolve(left.equals(right));
  }
  if (left.length !== right.length) {
    return _promise.default.resolve(false);
  }
  for (var i = 0; i < left.length; i += 1) {
    if (left[i] !== right[i]) {
      return _promise.default.resolve(false);
    }
  }
  return _promise.default.resolve(true);
};
exports.isMatchingFile = isMatchingFile;
//# sourceMappingURL=file.js.map
