"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));
var _isNan = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/number/is-nan"));
/*!
 * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.
 */

var bowser = require('bowser');

/**
 * Indicates if we're running in node
 * @returns {boolean}
 * @private
 */
function inNode() {
  return typeof window === 'undefined';
}

/**
 * Indicates if we're running in a web browser
 * @returns {boolean}
 * @private
 */
function inBrowser() {
  return !inNode();
}

/**
 * Indicates if we are running in the named browser
 * @param {string} name name of the browser
 * @returns {boolean}
 */
function inSpecificBrowser(name) {
  return window && bowser.getParser(window.navigator.userAgent).isBrowser(name);
}

/**
 * Indicates if we're running in firefox
 * @returns {boolean}
 * @private
 */
function inFirefox() {
  return inSpecificBrowser('firefox');
}

/**
 * Indicates if we're running in safari
 * @returns {boolean}
 * @private
 */
function inSafari() {
  return inSpecificBrowser('safari');
}

/**
 * Indicates if we're running on Jenkins
 * @returns {boolean}
 * @private
 */
function inJenkins() {
  return process.env.JENKINS;
}

/**
 * noop
 * @returns {undefined}
 * @private
 */
function noop() {
  // intentionally empty
}
module.exports = {
  /**
   * Wrap the desired mochaMethod with `flaky` to indicate it's a flaky test
   * and exclude it from the test suite.
   * example:
   * `flaky(it)('sometimes passes and sometimes failes')`
   * @param {Function} mochaMethod `it` or `describe`
   * @param {string} envVar process.env.SKIP_FLAKY_TESTS
   * @returns {Function} mochaMethod or mochaMethod.skip
   */
  flaky: function flaky(mochaMethod, envVar) {
    // If mochaMethod doesn't have a skip method,
    // assume the mochaMethod is either a .skip or .only
    if (!mochaMethod.skip) {
      return mochaMethod;
    }
    var shouldSkip = envVar && envVar !== 'false' && !!envVar;
    return shouldSkip ? mochaMethod.skip : mochaMethod;
  },
  /**
   * A lot of failures get produced by EventEmitters, which makes them difficult to
   * detect in tests (they just look like timeouts). This is a test helper that
   * captures that error and turns it into a rejected promise
   * @param {EventEmitter} emitter
   * @param {Function} fn
   * @returns {Promise}
   */
  handleErrorEvent: function handleErrorEvent(emitter, fn) {
    var r;
    var p = new _promise.default(function (resolve, reject) {
      r = reject;
      emitter.once('error', reject);
    });
    var handler = _promise.default.race([p, fn(emitter)]).then(unbind).catch(function (reason) {
      unbind();
      throw reason;
    });

    // Make it possible to add additional emitters
    handler.add = function (e) {
      return e.once('error', r);
    };
    return handler;

    /**
     * unbinder
     * @private
     * @returns {undefined}
     */
    function unbind() {
      try {
        emitter.off('error', r);
      } catch (err) {
        // ignore
      }
    }
  },
  inBrowser: inBrowser,
  inNode: inNode,
  /**
   * Wrap the desired mochaMethod with `skipInBrowser` to prevent the
   * corresponding test or group of tests from running in a web browser
   * example:
   * `skipInBrowser(it)('does a thing that only works in node')`
   * @param {Function} mochaMethod `it` or `describe`
   * @returns {Function} mochaMethod or mochaMethod.skip
   */
  skipInBrowser: function skipInBrowser(mochaMethod) {
    // If mochaMethod doesn't have a skip method, assume that mochaMethod is
    // already either a .skip or a .only
    if (!mochaMethod.skip) {
      return mochaMethod;
    }
    return inBrowser() ? mochaMethod.skip : mochaMethod;
  },
  /**
   * Wrap the desired mochaMethod with `skipInNode` to prevent the
   * corresponding test or group of tests from running in node.
   * example:
   * `skipInNode(it)('does a thing that only works in a web browser')`
   * @param {Function} mochaMethod `it` or `describe`
   * @returns {Function} mochaMethod or mochaMethod.skip
   */
  skipInNode: function skipInNode(mochaMethod) {
    // If mochaMethod doesn't have a skip method, assume that mochaMethod is
    // already either a .skip or a .only
    if (!mochaMethod.skip) {
      return mochaMethod;
    }
    return inNode() ? mochaMethod.skip : mochaMethod;
  },
  /**
   * Wrap the desired mochaMethod with `skipInFirefox` to prevent the
   * corresponding test or group of tests from running in Firefox.
   * example:
   * `skipInFirefox(it)('does a thing that does not work in Firefox')`
   * @param {Function} mochaMethod `it` or `describe`
   * @returns {Function} mochaMethod or mochaMethod.skip
   */
  skipInFirefox: function skipInFirefox(mochaMethod) {
    // If mochaMethod doesn't have a skip method, assume that mochaMethod is
    // already either a .skip or a .only
    if (!mochaMethod.skip) {
      return mochaMethod;
    }
    return inFirefox() ? mochaMethod.skip : mochaMethod;
  },
  /**
   * Wrap the desired mochaMethod with `skipInSafari` to prevent the
   * corresponding test or group of tests from running in Safari.
   * example:
   * `skipInSafari(it)('does a thing that does not work in Safari')`
   * @param {Function} mochaMethod `it` or `describe`
   * @returns {Function} mochaMethod or mochaMethod.skip
   */
  skipInSafari: function skipInSafari(mochaMethod) {
    // If mochaMethod doesn't have a skip method, assume that mochaMethod is
    // already either a .skip or a .only
    if (!mochaMethod.skip) {
      return mochaMethod;
    }
    return inSafari() ? mochaMethod.skip : mochaMethod;
  },
  /**
   * Similar to skipInNode in that it prevents the test from running, but goes a
   * step further to hide it from the list of skipped tests. Should be used when
   * the test will never be valid in NodeJS
   * @param {Function} mochaMethod
   * @returns {Function}
   */
  browserOnly: function browserOnly(mochaMethod) {
    return inBrowser() ? mochaMethod : noop;
  },
  /**
   * Similar to skipInBrowser in that it prevents the test from running, but
   * goes a step further to hide it from the list of skipped tests. Should be
   * used when the test will never be valid in a Browser
   * @param {Function} mochaMethod
   * @returns {Function}
   */
  nodeOnly: function nodeOnly(mochaMethod) {
    return inNode() ? mochaMethod : noop;
  },
  /**
   * Similar to skipInBrowser in that it prevents the test from running, but
   * goes a step further to hide it from the list of skipped tests. Should be
   * used when the test should be run on Jenkins only
   * @param {*} mochaMethod
   * @returns {Functions}
   */
  jenkinsOnly: function jenkinsOnly(mochaMethod) {
    return inJenkins() ? mochaMethod : noop;
  },
  /**
   * @param {number} max
   * @param {string} event
   * @param {EventEmitter} emitter
   * @param {function} activityChecker // callback to check if activity matches
   * @param {string} msg
   * @returns {Promise<mixed>} Resolves with the activity
   */
  expectActivity: function expectActivity(max, event, emitter, activityChecker, msg) {
    var timer;

    /**
     * helper
     * @private
     * @returns {undefined}
     */
    function unbind() {
      try {
        clearTimeout(timer);
        emitter.off(event);
      } catch (err) {
        // ignore
      }
    }
    return _promise.default.race([new _promise.default(function (resolve, reject) {
      timer = setTimeout(function () {
        reject(new Error("".concat(event, " did not fire within ").concat(max, "ms").concat(msg ? ": ".concat(msg) : '')));
      }, max);
    }), new _promise.default(function (resolve) {
      emitter.on(event, function (result) {
        var activity = result.data.activity;
        if (activityChecker(activity)) {
          unbind();
          resolve(activity);
        }
      });
    })]).catch(function (reason) {
      unbind();
      throw reason;
    });
  },
  /**
   * Returns a promise that resolves after timeout or rejects
   * when count has been exceeded. Will also reject if count
   * hasn't been met after timeout
   * @param {number} max amount of time to wait for events in ms
   * @param {number} count number of events to expect in timeframe
   * @param {string} event
   * @param {EventEmitter} emitter
   * @returns {Promise}
   */
  expectExactlyNEvents: function expectExactlyNEvents(max, count, event, emitter) {
    var lastResult;
    var timer;
    var currentCount = 0;
    return _promise.default.race([new _promise.default(function (resolve, reject) {
      timer = setTimeout(function () {
        if (currentCount === count) {
          resolve(lastResult);
        } else {
          reject(new Error("".concat(event, " fired only ").concat(currentCount, " times within ").concat(max, "ms. expected ").concat(count, " times")));
        }
      }, max);
    }), new _promise.default(function (resolve, reject) {
      emitter.on(event, fn);

      /**
       * helper
       * @private
       * @param {object} result
       * @returns {undefined}
       */
      function fn(result) {
        lastResult = result;
        currentCount += 1;
        if (currentCount > count) {
          emitter.off(event, fn);
          clearTimeout(timer);
          reject(new Error("".concat(event, " fired ").concat(currentCount, " times within ").concat(max, "ms. expected ").concat(count, " times")));
        }
      }
    })]);
  },
  /**
   * Returns a promise that resolves when event is fired count times or rejects
   * when max expires
   * @param {number} max
   * @param {number} count
   * @param {string} event
   * @param {EventEmitter} emitter
   * @returns {Promise}
   */
  expectNEvents: function expectNEvents(max, count, event, emitter) {
    var timer;
    var currentCount = 0;
    return _promise.default.race([new _promise.default(function (resolve, reject) {
      timer = setTimeout(function () {
        reject(new Error("".concat(event, " fired only ").concat(currentCount, " times within ").concat(max, "ms. expected ").concat(count, " times")));
      }, max);
    }), new _promise.default(function (resolve) {
      emitter.on(event, fn);

      /**
       * helper
       * @private
       * @returns {undefined}
       */
      function fn() {
        currentCount += 1;
        if (currentCount === count) {
          emitter.off(event, fn);
          clearTimeout(timer);
          resolve();
        }
      }
    })]);
  },
  /**
   * @param {number} max
   * @param {string} event
   * @param {EventEmitter} emitter
   * @param {string} msg
   * @returns {Promise<mixed>} Resolves with the results of the event
   */
  expectEvent: function expectEvent(max, event, emitter, msg) {
    var timer;
    return _promise.default.race([new _promise.default(function (resolve, reject) {
      timer = setTimeout(function () {
        reject(new Error("".concat(event, " did not fire within ").concat(max, "ms").concat(msg ? ": ".concat(msg) : '')));
      }, max);
    }), new _promise.default(function (resolve) {
      emitter.once(event, function (result) {
        clearTimeout(timer);
        resolve(result);
      });
    })]);
  },
  /**
   * Only run the specified test in firefox
   * @param {Function} mochaMethod
   * @returns {Function}
   */
  firefoxOnly: function firefoxOnly(mochaMethod) {
    return inFirefox() ? mochaMethod : noop;
  },
  /**
   * Waits max ms or until emitter fires event, then resolves
   * @param {number} max
   * @param {string} event
   * @param {EventEmitter} emitter
   * @returns {Promise<mixed>}
   */
  maxWaitForEvent: function maxWaitForEvent(max, event, emitter) {
    return _promise.default.race([new _promise.default(function (resolve) {
      setTimeout(resolve, max);
    }), new _promise.default(function (resolve) {
      emitter.once(event, resolve);
    })]);
  },
  /**
   * Waits timeout ms or until the promise resolves. Rejects if the timeout is
   * hit, otherwise resolves
   * @param {number} timeout
   * @param {Promise} promise
   * @returns {Promise<mixed>}
   */
  maxWaitForPromise: function maxWaitForPromise(timeout, promise) {
    return _promise.default.race([promise, new _promise.default(function (resolve, reject) {
      setTimeout(function () {
        reject(new Error("Timeout of ".concat(timeout, " expired before promise completed")));
      }, timeout);
    })]);
  },
  /**
   * Do not execute the specified mochaMethod until we pass the specified date
   * @param {Date|string} until
   * @param {string} explanation - Doesn't do anything, but forces you to defend
   * your decision to snooze a test
   * @returns {Function}
   */
  snoozeUntil: function snoozeUntil(until, explanation) {
    var now = new Date();
    if (!explanation) {
      throw new Error('You must defend your decision to snooze this test');
    }
    var d = new Date(until);
    if ((0, _isNan.default)(d.getTime())) {
      throw new Error("\"".concat(until, "\" does not appear to a valid date"));
    }
    var skip = now < d;
    return function (mochaMethod) {
      if (skip) {
        return mochaMethod.skip;
      }
      return mochaMethod;
    };
  }
};
//# sourceMappingURL=index.js.map
