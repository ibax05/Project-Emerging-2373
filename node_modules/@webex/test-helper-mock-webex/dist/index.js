"use strict";

var _Object$keys2 = require("@babel/runtime-corejs2/core-js/object/keys");
var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");
var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");
var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");
var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");
var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));
var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));
var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));
var _stringify = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify"));
function ownKeys(object, enumerableOnly) { var keys = _Object$keys2(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } return target; }
/*!
 * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.
 */

/* istanbul ignore next */
if (typeof _promise.default === 'undefined') {
  // eslint-disable-next-line global-require
  require('es6-promise').polyfill();
}
var _ = require('lodash');
var sinon = require('sinon');
var State = require('ampersand-state');
var nonInternalPlugins = ['authorization', 'credentials', 'memberships', 'messages', 'logger', 'people', 'phone', 'meetings', 'rooms', 'teams', 'teamMemberships', 'webhooks'];

/**
 * Mock Webex constructor
 * @param {Object} options
 * @returns {MockWebex}
 */
function makeWebex(options) {
  var requestPromise = _promise.default.resolve({
    statusCode: 200,
    body: {}
  });
  var uploadPromise = _promise.default.resolve({});
  options = options || {};
  options.children = options.children || {};
  var internalOptions = {};
  var internalChildren = {};
  var externalChildren = {};
  (0, _keys.default)(options.children).forEach(function (key) {
    if (nonInternalPlugins.indexOf(key) === -1) {
      internalChildren[key] = options.children[key];
    } else {
      externalChildren[key] = options.children[key];
    }
  });
  internalOptions.children = internalChildren;
  options.children = externalChildren;

  // This weird assignment is to make sure "internal" is the first property.
  // Because it turns out we're relying on ordering
  options.children = _objectSpread({
    internal: State.extend(internalOptions)
  }, options.children);
  requestPromise.on = uploadPromise.on = function on() {
    return requestPromise;
  };

  /**
   * produces a mock storage object
   * @param {Object} data
   * @returns {Storage}
   */
  function makeMockStorage(data) {
    data = data || {};
    return {
      data: data,
      on: sinon.spy(),
      once: sinon.spy(),
      listenTo: sinon.spy(),
      listenToAndRun: sinon.spy(),
      clear: function clear(namespace) {
        this.data = this.data || data;
        this.data[namespace] = {};
      },
      del: function del(namespace, key) {
        this.data = this.data || data;
        this.data[namespace] = this.data[namespace] || {};
        // eslint-disable-next-line prefer-reflect
        delete this.data[namespace][key];
      },
      get: function get(namespace, key) {
        this.data = this.data || data;
        this.data[namespace] = this.data[namespace] || {};
        var ret = this.data[namespace][key];
        if (ret) {
          return _promise.default.resolve(ret);
        }
        return _promise.default.reject(new Error('MockNotFoundError'));
      },
      put: function put(namespace, key, value) {
        this.data = this.data || data;
        try {
          // this is the simplest way to to turn ampstate objects into bare
          // objects without actually checking if they're ampstate objects
          value = JSON.parse((0, _stringify.default)(value));
        } catch (err) {
          // ignore
        }
        this.data[namespace] = this.data[namespace] || {};
        this.data[namespace][key] = value;
        return _promise.default.resolve();
      }
    };
  }
  var request = sinon.stub().returns(requestPromise);
  var upload = sinon.stub().returns(uploadPromise);
  var MockWebex = State.extend(_.defaults(options, {
    extraProperies: 'allow',
    request: request,
    upload: upload,
    refresh: function refresh() {
      return _promise.default.resolve();
    },
    setConfig: function setConfig(config) {
      this.config.credentials.idbroker.url = config.credentials.idbroker.url || process.env.IDBROKER_BASE_URL;
      this.config.credentials.identity.url = config.credentials.identity.url || process.env.IDENTITY_BASE_URL;
      return _promise.default.resolve();
    },
    config: {
      credentials: {
        idbroker: {
          url: process.env.IDBROKER_BASE_URL,
          defaultUrl: process.env.IDBROKER_BASE_URL
        },
        identity: {
          url: process.env.IDENTITY_BASE_URL,
          defaultUrl: process.env.IDENTITY_BASE_URL
        },
        activationUrl: "".concat(process.env.IDBROKER_BASE_URL || 'https://idbroker.webex.com', "/idb/token/v1/actions/UserActivation/invoke"),
        authorizeUrl: "".concat(process.env.IDBROKER_BASE_URL || 'https://idbroker.webex.com', "/idb/oauth2/v1/authorize"),
        setPasswordUrl: "".concat(process.env.IDBROKER_BASE_URL || 'https://identity.webex.com', "/identity/scim/v1/Users"),
        logoutUrl: "".concat(process.env.IDBROKER_BASE_URL || 'https://idbroker.webex.com', "/idb/oauth2/v1/logout"),
        // eslint-disable-next-line camelcase
        client_id: 'fake',
        // eslint-disable-next-line camelcase
        client_secret: 'fake',
        // eslint-disable-next-line camelcase
        redirect_uri: 'http://example.com',
        // eslint-disable-next-line camelcase
        scope: 'scope:one',
        service: 'webex'
      },
      conversation: {
        allowedTags: {
          'webex-mention': ['data-object-type', 'data-object-id', 'data-object-url']
        }
      },
      avatar: {},
      device: {},
      encryption: {},
      logger: {},
      mercury: {},
      metrics: {},
      support: {},
      user: {},
      llm: {},
      voicea: {},
      meetings: {
        mediaSettings: {
          sendAudio: true,
          sendVideo: true,
          receiveAudio: true,
          receiveVideo: true,
          pstn: false,
          sendShare: false,
          receiveShare: false
        },
        reconnection: {
          enabled: true,
          detection: true,
          retry: {
            times: 2,
            backOff: {
              start: 1000,
              rate: 2
            }
          }
        },
        stats: {
          interval: 1000,
          historyMax: 120
        },
        metrics: {
          clientType: 'TEAMS_CLIENT',
          clientName: 'WEBEX_JS_SDK',
          mqaMetricsInterval: 60000,
          autoSendMQA: true
        }
      }
    },
    initialize: function initialize(attrs) {
      this.boundedStorage = makeMockStorage(attrs && attrs.initialBoundedStorage);
      this.unboundedStorage = makeMockStorage(attrs && attrs.initialUnboundedStorage);
    }
  }));
  var webex = new MockWebex(options && options.attrs);
  sinon.spy(webex, 'refresh');
  _.defaults(webex, {
    credentials: {
      authorization: 'Basic NOTATOKEN',
      getUserToken: sinon.stub().returns(_promise.default.resolve({
        toString: function toString() {
          return 'Basic NOTATOKEN';
        }
      })),
      getClientToken: sinon.stub().returns(_promise.default.resolve({
        toString: function toString() {
          return 'Basic NOTATOKEN';
        }
      }))
    },
    sessionId: 'mock-webex_88888888-4444-4444-4444-aaaaaaaaaaaa',
    logger: process.env.MOCK_LOGGER ? console : {
      error: sinon.spy(),
      warn: sinon.spy(),
      log: sinon.spy(),
      info: sinon.spy(),
      debug: sinon.spy()
    }
  });
  _.defaults(webex.internal, {
    avatar: {},
    conversation: {},
    device: {
      webSocketUrl: 'ws://example.com',
      getWebSocketUrl: sinon.stub().returns(_promise.default.resolve('ws://example-2.com')),
      features: {
        developer: {
          get: sinon.stub()
        },
        entitlement: {
          get: sinon.stub()
        },
        user: {
          get: sinon.stub()
        }
      },
      registered: true,
      register: sinon.stub().returns(_promise.default.resolve())
    },
    feature: {
      setFeature: sinon.stub().returns(_promise.default.resolve(false)),
      getFeature: sinon.stub().returns(_promise.default.resolve(false))
    },
    encryption: {},
    metrics: {
      sendUnstructured: sinon.spy()
    },
    support: {},
    user: {},
    mercury: {},
    llm: {},
    voicea: {}
  });
  return webex;
}
module.exports = makeWebex;
//# sourceMappingURL=index.js.map
