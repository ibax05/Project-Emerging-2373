"use strict";

var _typeof = require("@babel/runtime-corejs2/helpers/typeof");
var _Object$keys = require("@babel/runtime-corejs2/core-js/object/keys");
var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");
var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");
var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");
var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");
var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _WeakMap = require("@babel/runtime-corejs2/core-js/weak-map");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.createTestUser = createTestUser;
_Object$defineProperty(exports, "createWhistlerTestUser", {
  enumerable: true,
  get: function get() {
    return _whistler.default;
  }
});
exports.loginTestUser = loginTestUser;
exports.removeTestUser = removeTestUser;
_Object$defineProperty(exports, "removeWhistlerTestUser", {
  enumerable: true,
  get: function get() {
    return _whistler.removeTestUser;
  }
});
var _now = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/date/now"));
var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));
var _defaultsDeep2 = _interopRequireDefault(require("lodash/defaultsDeep"));
var _assert = _interopRequireDefault(require("assert"));
var _uuid = _interopRequireDefault(require("uuid"));
var _btoa = _interopRequireDefault(require("btoa"));
var _nodeRandomName = _interopRequireDefault(require("node-random-name"));
var _httpCore = require("@webex/http-core");
var _whistler = _interopRequireWildcard(require("./whistler"));
function _getRequireWildcardCache(nodeInterop) { if (typeof _WeakMap !== "function") return null; var cacheBabelInterop = new _WeakMap(); var cacheNodeInterop = new _WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = _Object$defineProperty && _Object$getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? _Object$getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { _Object$defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } return target; }
var BASE_PATH_SECURE = '/users/test_users_s';
var BASE_PATH = '/users/test_users';

/**
 * Computes `expires` and `refresh_token_expires` from `expires_in` and
 * `refresh_token_expires_in` and creates an `authorization` string.
 * @param {Object} token
 * @private
 * @returns {Object}
 */
function fixToken(token) {
  var now = (0, _now.default)();
  if (token.expires_in && !token.expires) {
    token.expires = now + token.expires_in * 1000;
  }
  if (token.refresh_token_expires_in && !token.refresh_token_expires) {
    /* eslint camelcase: [0] */
    token.refresh_token_expires = now + token.refresh_token_expires_in * 1000;
  }
  if (token.token_type && token.access_token) {
    token.authorization = "".concat(token.token_type, " ").concat(token.access_token);
  }
  return token;
}
var clientToken;

/**
 * Fetches credentials to talk to the test_users_s endpoint
 *
 * Caches result in `clientToken` variable for multiple runs
 * @param {Object} options
 * @param {string} options.clientId
 * @param {string} options.clientSecret
 * @param {string} options.idbrokerUrl
 * @private
 * @returns {String}
 */
function getClientCredentials(_ref) {
  var clientId = _ref.clientId,
    clientSecret = _ref.clientSecret,
    idbrokerUrl = _ref.idbrokerUrl;
  if (clientToken) {
    return _promise.default.resolve(clientToken);
  }
  return (0, _httpCore.request)({
    method: 'POST',
    uri: "".concat(idbrokerUrl, "/idb/oauth2/v1/access_token"),
    json: true,
    form: {
      grant_type: 'client_credentials',
      scope: 'Identity:SCIM webexsquare:get_conversation',
      client_id: clientId,
      client_secret: clientSecret
    },
    headers: {
      // Note: we can't request's auth hash here because this endpoint expects
      // us to send the auth header *without including "Basic "* before the
      // token string
      authorization: (0, _btoa.default)("".concat(clientId, ":").concat(clientSecret))
    }
  }).then(function (res) {
    var token = fixToken(res.body);
    return "".concat(token.token_type, " ").concat(token.access_token);
  }).then(function (token) {
    clientToken = token;
    return clientToken;
  });
}

/**
 * Makes a request authorized with client credentials
 * @param {Object} options
 * @param {Object} options.body
 * @param {string} options.body.clientId
 * @param {string} options.body.clientSecret
 * @param {string} options.body.idbrokerUrl
 * @private
 * @returns {Promise<HttpResponseObject>}
 */
function requestWithAuth(options) {
  return getClientCredentials(options.body).then(function (authorization) {
    options.headers = options.headers || {};
    options.headers.authorization = authorization;
    return (0, _httpCore.request)(options);
  });
}

/**
 * @typedef {Object} AccessTokenObject
 * @property {string} token.access_token
 * @property {Number} token.expires_in
 * @property {string} token.token_type
 * @property {string} token.refresh_token
 * @property {Number} token.refresh_token_expires_in
 * @property {string} token.expires
 * @property {string} token.refresh_token_expires
 */

/**
 * @typedef {Object} CreateUserOptions
 * @property {boolean} [authCodeOnly] generates auth_code
 * @param {string} [clientId] defaults to WEBEX_CLIENT_ID
 * @param {string} [clientSecret] defaults to WEBEX_CLIENT_SECRET
 * @param {string} [cigServiceUrl] defaults to WEBEX_TEST_USERS_CI_GATEWAY_SERVICE_URL
 * @property {string} [displayName]
 * @property {string} [emailAddress]
 * @property {Array.<string>} [entitlements]
 * @param {string} [idbrokerUrl] defaults to IDBROKER_BASE_URL
 * @property {string} [machineType] used when creating a machine user/device
 * @property {string} [orgId] organization ID to create the user under
 * @property {string} [password] defaults to a random password
 * @property {string} [roles] defaults to []
 * @property {string} [scope] defaults to WEBEX_SCOPE
 * @property {string} [type] used to create a machine
 */

/**
 * @typedef {Object} TestUserObject
 * @property {string} password
 * @property {string} emailAddress
 * @property {string} displayName
 * @property {string} id
 * @property {string} userName
 * @property {string} email
 * @property {string} name
 * @property {string} givenName
 * @property {string} type
 * @property {Array.<string>} entitlements
 * @property {string} orgId
 * @property {AccessTokenObject} token
 */

/**
 * Creates a test user
 * @param {CreateUserOptions} options
 * @returns {Promise.<TestUserObject>}
 */
function createTestUser() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var clientId = options.clientId || process.env.WEBEX_CLIENT_ID;
  var clientSecret = options.clientSecret || process.env.WEBEX_CLIENT_SECRET;
  var idbrokerUrl = options.idbrokerUrl || process.env.IDBROKER_BASE_URL;
  var cigServiceUrl = options.cigServiceUrl || process.env.WEBEX_TEST_USERS_CI_GATEWAY_SERVICE_URL || process.env.WEBEX_TEST_USERS_CONVERSATION_SERVICE_URL;
  if (!clientId) {
    throw new Error('options.clientId or process.env.WEBEX_CLIENT_ID must be defined');
  }
  if (!clientSecret) {
    throw new Error('options.clientSecret or process.env.WEBEX_CLIENT_SECRET must be defined');
  }
  if (!idbrokerUrl) {
    throw new Error('options.idbrokerUrl or process.env.IDBROKER_BASE_URL must be defined');
  }
  if (!cigServiceUrl) {
    throw new Error('options.cigServiceUrl or process.env.WEBEX_TEST_USERS_CI_GATEWAY_SERVICE_URL must be defined');
  }
  var body = {
    authCodeOnly: options.authCodeOnly,
    clientId: clientId,
    clientSecret: clientSecret,
    displayName: options.displayName || (0, _nodeRandomName.default)(),
    emailTemplate: options.emailAddress,
    entitlements: options.entitlements || ['spark', 'squaredCallInitiation', 'squaredRoomModeration', 'squaredInviter', 'webExSquared'],
    idbrokerUrl: idbrokerUrl,
    machineType: options.machineType,
    orgId: options.orgId,
    // The five characters on the end are to hit all the password requirements
    password: options.password || "".concat(_uuid.default.v4(), "zAY1*"),
    roles: options.roles || [],
    scopes: options.scope || process.env.WEBEX_SCOPE,
    type: options.type
  };
  return requestWithAuth({
    method: 'POST',
    uri: "".concat(cigServiceUrl).concat(BASE_PATH_SECURE),
    json: true,
    body: body
  }).then(function (res) {
    return _objectSpread(_objectSpread({
      password: body.password,
      emailAddress: res.body.user.email,
      displayName: res.body.user.name
    }, res.body.user), {}, {
      token: fixToken(res.body.token)
    });
  });
}

/**
 * Exchanges a user name/password for an access token
 * @param {Object} options
 * @param {string} options.id
 * @param {string} options.email
 * @param {string} options.password
 * @param {string} options.clientId
 * @param {string} options.clientSecret
 * @param {string} options.cigServiceUrl
 * @returns {Promise.<AccessTokenObject>}
 */
function loginTestUser(options) {
  var clientId = options.clientId || process.env.WEBEX_CLIENT_ID;
  var clientSecret = options.clientSecret || process.env.WEBEX_CLIENT_SECRET;
  var cigServiceUrl = options.cigServiceUrl || process.env.WEBEX_TEST_USERS_CI_GATEWAY_SERVICE_URL || process.env.WEBEX_TEST_USERS_CONVERSATION_SERVICE_URL;
  if (!clientId) {
    throw new Error('options.clientId or process.env.WEBEX_CLIENT_ID must be defined');
  }
  if (!clientSecret) {
    throw new Error('options.clientSecret or process.env.WEBEX_CLIENT_SECRET must be defined');
  }
  if (!cigServiceUrl) {
    throw new Error('options.cigServiceUrl or process.env.WEBEX_TEST_USERS_CI_GATEWAY_SERVICE_URL must be defined');
  }
  return (0, _httpCore.request)({
    method: 'POST',
    uri: "".concat(cigServiceUrl).concat(BASE_PATH, "/login"),
    json: true,
    body: (0, _defaultsDeep2.default)(options, {
      clientId: clientId,
      clientSecret: clientSecret
    })
  }).then(function (res) {
    return fixToken(res.body);
  });
}

/**
 * Removes a test user
 * @param {Object} options
 * @param {string} options.id user id to remove
 * @param {string} options.cigServiceUrl
 * @param {Object} options.token
 * @param {string} options.token.authorization
 * @param {string} [options.token.refresh_token]
 * @returns {Promise}
 */
function removeTestUser() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var cigServiceUrl = options.cigServiceUrl || process.env.WEBEX_TEST_USERS_CI_GATEWAY_SERVICE_URL || process.env.WEBEX_TEST_USERS_CONVERSATION_SERVICE_URL;
  if (!cigServiceUrl) {
    throw new Error('options.cigServiceUrl or process.env.WEBEX_TEST_USERS_CI_GATEWAY_SERVICE_URL must be defined');
  }
  if (!options.id) {
    return _promise.default.reject(new Error('options.id is required'));
  }
  if (!options.token) {
    return loginTestUser(options).then(function (token) {
      options.token = token;
      return removeTestUser(options);
    });
  }
  (0, _assert.default)(options.token.authorization, 'options.token.authorization must be defined');
  return (0, _httpCore.request)({
    method: 'POST',
    json: true,
    headers: {
      authorization: options.token.authorization
    },
    body: {
      /* eslint-disable camelcase */
      user_id: options.id,
      refresh_token: options.token.refresh_token,
      user_type: options.userType || 'PERSON'
      /* eslint-enable camelcase */
    },

    uri: "".concat(cigServiceUrl).concat(BASE_PATH, "/delete")
  });
}
//# sourceMappingURL=index.js.map
