"use strict";

var _Object$keys = require("@babel/runtime-corejs2/core-js/object/keys");
var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");
var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");
var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");
var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");
var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createTestUser;
exports.removeTestUser = removeTestUser;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));
var _btoa = _interopRequireDefault(require("btoa"));
var _httpCore = require("@webex/http-core");
function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } return target; }
/**
 * Fetches credentials/access_token to talk to the whistler endpoint
 *
 * @param {Object} options
 * @param {string} options.clientId
 * @param {string} options.clientSecret
 * @param {string} options.idbrokerUrl
 * @param {string} options.orgId
 * @param {string} options.machineAccount
 * @param {string} options.machinePassword
 * @private
 * @returns {Promise<string>}
 */
var getClientCredentials = function getClientCredentials(_ref) {
  var clientId = _ref.clientId,
    clientSecret = _ref.clientSecret,
    orgId = _ref.orgId,
    idbrokerUrl = _ref.idbrokerUrl,
    machineAccount = _ref.machineAccount,
    machinePassword = _ref.machinePassword;
  return (0, _httpCore.request)({
    method: 'POST',
    uri: "".concat(idbrokerUrl, "/idb/token/").concat(orgId, "/v2/actions/GetBearerToken/invoke"),
    json: true,
    body: {
      uid: machineAccount,
      password: machinePassword
    }
  }).then(function (res) {
    return (0, _httpCore.request)({
      method: 'POST',
      uri: "".concat(idbrokerUrl, "/idb/oauth2/v1/access_token"),
      json: true,
      form: {
        assertion: res.body.BearerToken,
        grant_type: 'urn:ietf:params:oauth:grant-type:saml2-bearer',
        scope: 'webexsquare:get_conversation webexsquare:admin',
        self_contained_token: true,
        client_id: clientId,
        client_secret: clientSecret
      },
      headers: {
        // Note: we can't request's auth hash here because this endpoint expects
        // us to send the auth header *without including "Basic "* before the
        // token string
        // authorization: `Basic + ${btoa(`${clientId}:${clientSecret}`)}`
        authorization: (0, _btoa.default)("".concat(clientId, ":").concat(clientSecret))
      }
    });
  }).then(function (res) {
    return "".concat(res.body.token_type, " ").concat(res.body.access_token);
  });
};

/**
 * @typedef {Object} TestUserObject
 * @property {string} password
 * @property {string} emailAddress
 * @property {string} displayName
 * @property {string} token
 * @property {string} reservationUrl
 * @property {object} responseMetaData - whistler given properties
 */

/**
 * @typedef {Object} CreateUserOptions
 * @param {Object} [options]
 * @param {string} [whistlerServiceUrl] defaults to WHISTLER_API_SERVICE_URL
 * @param {string} [options.clientId] defaults to WEBEX_CLIENT_ID
 * @param {string} [options.clientSecret] defaults to WEBEX_CLIENT_SECRET
 * @param {string} [options.idbrokerUrl] defaults to IDBROKER_BASE_URL
 * @param {string} [options.orgId] organization ID to create the user under
 * @param {string} [options.machineAccount] defaults to WHISTLER_MACHINE_ACCOUNT
 * @param {string} [options.machinePassword] defaults to WHISTLER_MACHINE_PASSWORD
 */

/**
 * Creates a test user
 * @param {CreateUserOptions} options
 * @returns {Promise.<TestUserObject>}
 */
function createTestUser() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var clientId = options.clientId || process.env.WEBEX_CLIENT_ID;
  var clientSecret = options.clientSecret || process.env.WEBEX_CLIENT_SECRET;
  var machineAccount = options.machineAccount || process.env.WHISTLER_MACHINE_ACCOUNT;
  var machinePassword = options.machinePassword || process.env.WHISTLER_MACHINE_PASSWORD;
  var idbrokerUrl = options.idbrokerUrl || process.env.IDBROKER_BASE_URL;
  var orgId = options.orgId || process.env.WHISTLER_TEST_ORG_ID;
  var whistlerServiceUrl = options.whistlerServiceUrl || process.env.WHISTLER_API_SERVICE_URL;
  var reservationGroup = options.reservationGroup,
    userScopes = options.userScopes;
  if (!clientId) {
    throw new Error('options.clientId or process.env.WEBEX_CLIENT_ID must be defined');
  }
  if (!clientSecret) {
    throw new Error('options.clientSecret or process.env.WEBEX_CLIENT_SECRET must be defined');
  }
  if (!machineAccount) {
    throw new Error('options.machineAccount or process.env.WHISTLER_MACHINE_ACCOUNT must be defined');
  }
  if (!machinePassword) {
    throw new Error('options.machinePassword or process.env.WHISTLER_MACHINE_PASSWORD must be defined');
  }
  if (!idbrokerUrl) {
    throw new Error('options.idbrokerUrl or process.env.IDBROKER_BASE_URL must be defined');
  }
  if (!orgId) {
    throw new Error('options.orgId or process.env.WHISTLER_TEST_ORG_ID must be defined');
  }
  if (!whistlerServiceUrl) {
    throw new Error('options.whistlerServiceUrl or process.env.WHISTLER_API_SERVICE_URL must be defined');
  }

  // For reservation groups and user scopes
  // Please check https://confluence-eng-gpk2.cisco.com/conf/pages/viewpage.action?spaceKey=LOCUS&title=Whistler+APIs#WhistlerAPIs-GET/reservations/testUser
  return getClientCredentials({
    clientId: clientId,
    clientSecret: clientSecret,
    machineAccount: machineAccount,
    machinePassword: machinePassword,
    idbrokerUrl: idbrokerUrl,
    orgId: orgId
  }).then(function (authorization) {
    return (0, _httpCore.request)({
      method: 'GET',
      uri: "".concat(whistlerServiceUrl, "/reservations/testUser"),
      qs: {
        reservationGroup: reservationGroup,
        userScopes: userScopes,
        isAccessTokenRequired: true
      },
      headers: {
        authorization: authorization
      }
    });
  }).then(function (res) {
    return _objectSpread({
      password: res.body.responseMetaData.ciPassword,
      emailAddress: res.body.responseMetaData.name,
      displayName: res.body.responseMetaData.webExUserName,
      token: res.body.responseMetaData.ciAccessToken,
      reservationUrl: res.body.reservationUrl
    }, res.body.responseMetaData);
  });
}

/**
 *
 * @param {Object} options
 * @returns {Promise}
 */
function removeTestUser() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return (0, _httpCore.request)({
    method: 'DELETE',
    headers: {
      authorization: "Bearer ".concat(options.token)
    },
    uri: options.reservationUrl
  });
}
//# sourceMappingURL=whistler.js.map
