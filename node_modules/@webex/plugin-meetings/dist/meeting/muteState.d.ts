declare const createMuteState: (type: any, meeting: any, mediaDirection: any) => MuteState;
/** The purpose of this class is to manage the local and remote mute state and make sure that the server state always matches
   the last requested state by the client.

   More info about Locus muting API: https://sqbu-github.cisco.com/pages/WebExSquared/locus/guides/mute.html#
*/
declare class MuteState {
    pendingPromiseReject: any;
    pendingPromiseResolve: any;
    state: any;
    type: any;
    /**
     * Constructor
     *
     * @param {String} type - audio or video
     * @param {Object} meeting - the meeting object (used for reading current remote mute status)
     */
    constructor(type: string, meeting: any);
    /**
     * Handles mute/unmute request from the client/user. Returns a promise that's resolved once the server update is completed or
     * at the point that this request becomese superseded by another client request.
     *
     * The client doesn't have to wait for the returned promise to resolve before calling handleClientRequest() again. If
     * handleClientRequest() is called again before the previous one resolved, the MuteState class will make sure that eventually
     * the server state will match the last requested state from the client.
     *
     * @public
     * @memberof MuteState
     * @param {Object} [meeting] the meeting object
     * @param {Boolean} [mute] true for muting, false for unmuting request
     * @returns {Promise}
     */
    handleClientRequest(meeting?: object, mute?: boolean): Promise<unknown>;
    /**
     * Applies the current mute state to the local track (by enabling or disabling it accordingly)
     *
     * @public
     * @param {Object} [meeting] the meeting object
     * @memberof MuteState
     * @returns {void}
     */
    applyClientStateLocally(meeting?: any): void;
    /**
     * Updates the server local and remote mute values so that they match the current client desired state.
     *
     * @private
     * @param {Object} [meeting] the meeting object
     * @memberof MuteState
     * @returns {void}
     */
    private applyClientStateToServer;
    /**
     * Sets the local mute value in the server
     *
     * @private
     * @param {Object} [meeting] the meeting object
     * @memberof MuteState
     * @returns {Promise}
     */
    private sendLocalMuteRequestToServer;
    /**
     * Sets the remote mute value in the server
     *
     * @private
     * @param {Object} [meeting] the meeting object
     * @memberof MuteState
     * @returns {Promise}
     */
    private sendRemoteMuteRequestToServer;
    /**
     * This method should be called whenever the server remote mute state is changed
     *
     * @public
     * @memberof MuteState
     * @param {Boolean} [muted] true if user is remotely muted, false otherwise
     * @param {Boolean} [unmuteAllowed] indicates if user is allowed to unmute self (false when "hard mute" feature is used)
     * @returns {undefined}
     */
    handleServerRemoteMuteUpdate(muted?: boolean, unmuteAllowed?: boolean): void;
    /**
     * This method should be called whenever we receive from the server a requirement to locally unmute
     *
     * @public
     * @memberof MuteState
     * @param {Object} [meeting] the meeting object
     * @returns {undefined}
     */
    handleServerLocalUnmuteRequired(meeting?: object): void;
    /**
     * Returns true if the user is locally or remotely muted
     *
     * @public
     * @memberof MuteState
     * @returns {Boolean}
     */
    isMuted(): any;
    /**
     * Returns true if the user is locally muted
     *
     * @public
     * @memberof MuteState
     * @returns {Boolean}
     */
    isLocallyMuted(): any;
    /**
     * Returns true if the user is muted as a result of the client request (and not remotely muted)
     *
     * @public
     * @memberof MuteState
     * @returns {Boolean}
     */
    isSelf(): boolean;
    get muted(): any;
    get self(): boolean;
}
export default createMuteState;
