"use strict";

var _Reflect$construct = require("@babel/runtime-corejs2/core-js/reflect/construct");
var _Object$keys2 = require("@babel/runtime-corejs2/core-js/object/keys");
var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");
var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");
var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");
var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");
var _Object$defineProperty2 = require("@babel/runtime-corejs2/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
_Object$defineProperty2(exports, "__esModule", {
  value: true
});
exports.default = exports.MEDIA_UPDATE_TYPE = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));
var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));
var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/define-property"));
var _stringify = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify"));
var _assign = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/assign"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/slicedToArray"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/typeof"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/assertThisInitialized"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));
var _defineProperty3 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));
var _isString2 = _interopRequireDefault(require("lodash/isString"));
var _pick2 = _interopRequireDefault(require("lodash/pick"));
var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));
var _cloneDeep2 = _interopRequireDefault(require("lodash/cloneDeep"));
var _uuid = _interopRequireDefault(require("uuid"));
var _webexCore = require("@webex/webex-core");
var _internalMediaCore = require("@webex/internal-media-core");
var _webexErrors = require("../common/errors/webex-errors");
var _statsAnalyzer = require("../statsAnalyzer");
var _networkQualityMonitor = _interopRequireDefault(require("../networkQualityMonitor"));
var _loggerProxy = _interopRequireDefault(require("../common/logs/logger-proxy"));
var _triggerProxy = _interopRequireDefault(require("../common/events/trigger-proxy"));
var _index = _interopRequireDefault(require("../roap/index"));
var _media = _interopRequireDefault(require("../media"));
var _properties = _interopRequireDefault(require("../media/properties"));
var _state = _interopRequireDefault(require("./state"));
var _muteState = _interopRequireDefault(require("./muteState"));
var _effectsState = _interopRequireDefault(require("./effectsState"));
var _locusInfo = _interopRequireDefault(require("../locus-info"));
var _peerConnectionManager = _interopRequireDefault(require("../peer-connection-manager"));
var _metrics = _interopRequireDefault(require("../metrics"));
var _config = require("../metrics/config");
var _reconnectionManager = _interopRequireDefault(require("../reconnection-manager"));
var _request = _interopRequireDefault(require("./request"));
var _index2 = _interopRequireDefault(require("../members/index"));
var _util = _interopRequireDefault(require("./util"));
var _util2 = _interopRequireDefault(require("../recording-controller/util"));
var _util3 = _interopRequireDefault(require("../controls-options-manager/util"));
var _util4 = _interopRequireDefault(require("../media/util"));
var _transcription = _interopRequireDefault(require("../transcription"));
var _passwordError = _interopRequireDefault(require("../common/errors/password-error"));
var _captchaError = _interopRequireDefault(require("../common/errors/captcha-error"));
var _reconnection = _interopRequireDefault(require("../common/errors/reconnection"));
var _reconnectionInProgress = _interopRequireDefault(require("../common/errors/reconnection-in-progress"));
var _constants = require("../constants");
var _constants2 = _interopRequireDefault(require("../metrics/constants"));
var _parameter = _interopRequireDefault(require("../common/errors/parameter"));
var _media2 = _interopRequireDefault(require("../common/errors/media"));
var _meetingInfoV = require("../meeting-info/meeting-info-v2");
var _browserDetection = _interopRequireDefault(require("../common/browser-detection"));
var _collection = _interopRequireDefault(require("../roap/collection"));
var _reactions = require("../reactions/reactions");
var _inMeetingActions = _interopRequireDefault(require("./in-meeting-actions"));
var _recordingController = _interopRequireDefault(require("../recording-controller"));
var _controlsOptionsManager = _interopRequireDefault(require("../controls-options-manager"));
function ownKeys(object, enumerableOnly) { var keys = _Object$keys2(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty3.default)(target, key, source[key]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty2(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } return target; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var _BrowserDetection = (0, _browserDetection.default)(),
  isBrowser = _BrowserDetection.isBrowser;
var logRequest = function logRequest(request, _ref) {
  var _ref$header = _ref.header,
    header = _ref$header === void 0 ? '' : _ref$header,
    _ref$success = _ref.success,
    success = _ref$success === void 0 ? '' : _ref$success,
    _ref$failure = _ref.failure,
    failure = _ref$failure === void 0 ? '' : _ref$failure;
  _loggerProxy.default.logger.info(header);
  return request.then(function (arg) {
    _loggerProxy.default.logger.info(success);
    return arg;
  }).catch(function (error) {
    _loggerProxy.default.logger.error(failure, error);
    throw error;
  });
};
var MEDIA_UPDATE_TYPE = {
  ALL: 'ALL',
  AUDIO: 'AUDIO',
  VIDEO: 'VIDEO',
  SHARE: 'SHARE'
};

/**
 * MediaDirection
 * @typedef {Object} MediaDirection
 * @property {boolean} sendAudio
 * @property {boolean} receiveAudio
 * @property {boolean} sendVideo
 * @property {boolean} receiveVideo
 * @property {boolean} sendShare
 * @property {boolean} receiveShare
 * @property {boolean} isSharing
 */

/**
 * AudioVideo
 * @typedef {Object} AudioVideo
 * @property {Object} audio
 * @property {String} audio.deviceId
 * @property {Object} video
 * @property {String} video.deviceId
 * @property {String} video.localVideoQuality // [240p, 360p, 480p, 720p, 1080p]
 */

/**
 * SharePreferences
 * @typedef {Object} SharePreferences
 * @property {Object} [shareConstraints]
 * @property {Boolean} [highFrameRate]
 */

/**
 * JoinOptions
 * @typedef {Object} JoinOptions
 * @property {String} [resourceId]
 * @property {String} [pin]
 * @property {Boolean} [moderator]
 * @property {String|Object} [meetingQuality]
 * @property {String} [meetingQuality.local]
 * @property {String} [meetingQuality.remote]
 * @property {Boolean} [rejoin]
 */

/**
 * SendOptions
 * @typedef {Object} SendOptions
 * @property {Boolean} sendAudio
 * @property {Boolean} sendVideo
 * @property {Boolean} sendShare
 */

/**
 * Recording
 * @typedef {Object} Recording
 * @property {Object} state
 * @property {String} modifiedBy
 */

/**
 * Meeting State Change Event
 * Emitted when ever there is a meeting state change
 * @event meeting:stateChange
 * @instance
 * @type {Object}
 * @property {String} currentState current state of the meeting
 * @property {String} previousState previous state of the meeting
 * @memberof Meeting
 */

/**
 * Media Ready Event
 * Emitted when a stream is ready to be rendered
 * @event media:ready
 * @instance
 * @type {Object}
 * @property {MediaStream} stream the media stream
 * @property {String} type what type of stream, remote, local
 * @memberof Meeting
 */

/**
 * Media Stopped Event
 * Emitted when a stream has stopped sending
 * @event media:stopped
 * @instance
 * @type {Object}
 * @property {String} type what type of stream, remote, local
 * @memberof Meeting
 */

/**
 * Meeting Ringing Event
 * Emitted when this client should play a ringing sound, because this member is getting an incoming meeting
 * or sending out an incoming meeting
 * @event meeting:ringing
 * @instance
 * @type {Object}
 * @property {String} type // INCOMING or JOIN
 * @property {String} id
 * @memberof Meeting
 */

/**
 * Meeting Ringing Stop Event
 * Emitted when this client should stop playing a ringing sound
 * @event meeting:ringingStop
 * @instance
 * @type {Object}
 * @property {Object} type
 * @property {Boolean} type.remoteAnswered
 * @property {Boolean} type.remoteDeclined
 * @property {String} id
 * @memberof Meeting
 */

/**
 * Meeting Started Sharing Local Event
 * Emitted when this member starts sharing
 * @event meeting:startedSharingLocal
 * @instance
 * @type {Object}
 * @memberof Meeting
 */

/**
 * Meeting Stopped Sharing Local Event
 * Emitted when this member stops sharing
 * @event meeting:stoppedSharingLocal
 * @instance
 * @type {Object}
 * @memberof Meeting
 */

/**
 * Meeting Started Sharing Remote Event
 * Emitted when remote sharing starts
 * @event meeting:startedSharingRemote
 * @instance
 * @type {Object}
 * @property {Boolean} memberId id of the meeting member that started screen share
 * @memberof Meeting
 */

/**
 * Meeting Stopped Sharing Remote Event
 * Emitted when remote screen sharing ends
 * @event meeting:stoppedSharingRemote
 * @instance
 * @type {Object}
 * @memberof Meeting
 */

/**
 * Meeting Locked Event
 * Emitted when a meeting is locked
 * @event meeting:locked
 * @instance
 * @type {Object}
 * @property {Object} info
 * @memberof Meeting
 */

/**
 * Meeting Unlocked Event
 * Emitted when a meeting is unlocked
 * @event meeting:unlocked
 * @instance
 * @type {Object}
 * @property {Object} info
 * @memberof Meeting
 */

/**
 * Meeting Actions Update Event
 * Emitted when a user can take actions on a meeting such as lock, unlock, assign host
 * @event meeting:actionsUpdate
 * @instance
 * @type {Object}
 * @property {Boolean} canLock
 * @property {Boolean} canUnlock
 * @property {Boolean} canAssignHost
 * @memberof Meeting
 */

/**
 * Meeting Unmuted By Others Event
 * Emitted when a member is unmuted by another member
 * @event meeting:self:unmutedByOthers
 * @instance
 * @type {Object}
 * @property {Object} payload
 * @memberof Meeting
 */

/**
 * Meeting Muted By Others Event
 * Emitted when a member is muted by another member
 * @event meeting:self:mutedByOthers
 * @instance
 * @type {Object}
 * @property {Object} payload
 * @property {Boolean} payload.unmuteAllowed - whether the user is allowed to unmute self
 * @memberof Meeting
 */

/**
 * Meeting Muted By Others Event
 * Emitted when the host(moderator)/co-host requests a user to unmute
 * @event meeting:self:requestedToUnmute
 * @instance
 * @type {Object}
 * @property {Object} payload
 * @memberof Meeting
 */

/**
 * Meeting Self Guest Admitted Event
 * Emitted when a joined user get admitted to the meeting by another member or host
 * @event meeting:self:guestAdmitted
 * @instance
 * @type {Object}
 * @property {Object} payload
 * @memberof Meeting
 */

/**
 * Meeting Self Lobby Waiting Event
 * Emitted when joined user enters the lobby and is waiting for the webex meeting to begin
 * @event meeting:self:lobbyWaiting
 * @instance
 * @type {Object}
 * @property {Object} reason Reason why user left the meeting
 * @memberof Meeting
 */

/**
 * Meeting Self Left State
 * Emitted when user is inactive for more then 40 seconds, User can rejoin the meeting again
 * @event meeting:self:left
 * @instance
 * @type {Object}
 * @property {Object} payload
 * @memberof Meeting
 */

/**
 * Reconnection Starting Event
 * Emitted when reconnection of media to the active meeting was successful
 * @event meeting:reconnectionStarting
 * @instance
 * @memberof Meeting
 */

/**
 * Reconnection Success Event
 * Emitted when reconnection of media to the active meeting was successful
 * @event meeting:reconnectionSuccess
 * @instance
 * @type {Object}
 * @property {Object} reconnect
 * @memberof Meeting
 */

/**
 * Reconnection Failure Event
 * Emitted when reconnection of media to the active meeting was successful
 * @event meeting:reconnectionFailure
 * @instance
 * @type {Object}
 * @property {Error} error
 * @memberof Meeting
 */

/**
 * Meeting network quality event
 * Emitted on each interval of retrieving stats Analyzer data
 * @event network:quality
 * @type {Object}
 * @property {string} mediaType {video|audio}
 * @property {number} networkQualityScore - {1|0} 1 indicates acceptable uplink 0 indicates unacceptable uplink based on threshold
 * @memberof Meeting
 */

/**
 * @description Meeting is the crux of the plugin
 * @export
 * @class Meeting
 */
exports.MEDIA_UPDATE_TYPE = MEDIA_UPDATE_TYPE;
var Meeting = /*#__PURE__*/function (_StatelessWebexPlugin) {
  (0, _inherits2.default)(Meeting, _StatelessWebexPlugin);
  var _super = _createSuper(Meeting);
  /**
   * @param {Object} attrs
   * @param {Object} options
   * @constructor
   * @memberof Meeting
   */
  function Meeting(attrs, _options) {
    var _this$locusInfo, _this$locusInfo$links, _this$locusInfo$links2, _this$locusInfo$links3, _this$locusInfo2, _this$locusInfo2$full, _this$locusInfo3, _this$locusInfo4;
    var _this;
    (0, _classCallCheck2.default)(this, Meeting);
    _this = _super.call(this, {}, _options);
    /**
     * @instance
     * @type {Object}
     * @readonly
     * @private
     * @memberof Meeting
     */
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "attrs", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "audio", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "conversationUrl", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "correlationId", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "destination", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "destinationType", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "deviceUrl", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "effects", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "hostId", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "id", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "locusUrl", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "mediaConnections", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "meetingFiniteStateMachine", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "meetingInfo", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "meetingRequest", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "members", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "options", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "orgId", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "owner", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "partner", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "policy", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "reconnectionManager", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "resource", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "roap", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "roapSeq", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "sipUri", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "type", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "userId", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "video", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "callEvents", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "deferJoin", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "dialInDeviceStatus", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "dialInUrl", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "dialOutDeviceStatus", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "dialOutUrl", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "fetchMeetingInfoTimeoutId", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "floorGrantPending", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "hasJoinedOnce", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "hasWebsocketConnected", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "inMeetingActions", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "isLocalShareLive", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "isSharing", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "keepAliveTimerId", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "lastVideoLayoutInfo", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "locusInfo", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "mediaProperties", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "meetingInfoFailureReason", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "networkQualityMonitor", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "networkStatus", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "passwordStatus", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "queuedMediaUpdates", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "recording", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "recordingController", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "controlsOptionsManager", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "requiredCaptcha", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "shareStatus", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "statsAnalyzer", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "transcription", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "receiveTranscription", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "updateMediaConnections", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "endCallInitiateJoinReq", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "endJoinReqResp", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "endLocalSDPGenRemoteSDPRecvDelay", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "joinedWith", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "locusId", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "startCallInitiateJoinReq", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "startJoinReqResp", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "startLocalSDPGenRemoteSDPRecvDelay", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "wirelessShare", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "guest", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "meetingJoinUrl", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "meetingNumber", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "meetingState", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "permissionToken", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "resourceId", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "resourceUrl", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "selfId", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "state", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "namespace", _constants.MEETINGS);
    /**
     * Get local media streams based on options passed
     * @param {MediaDirection} mediaDirection A configurable options object for joining a meeting
     * @param {AudioVideo} [audioVideo] audio/video object to set audioinput and videoinput devices, see #Media.getUserMedia
     * @param {SharePreferences} [sharePreferences] audio/video object to set audioinput and videoinput devices, see #Media.getUserMedia
     * @returns {Promise} see #Media.getUserMedia
     * @public
     * @todo should be static, or moved so can be called outside of a meeting
     * @memberof Meeting
     */
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "getMediaStreams", function (mediaDirection) {
      var audioVideo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _constants.VIDEO_RESOLUTIONS[_this.mediaProperties.localQualityLevel];
      var sharePreferences = arguments.length > 2 ? arguments[2] : undefined;
      if (mediaDirection && (mediaDirection.sendAudio || mediaDirection.sendVideo || mediaDirection.sendShare)) {
        if (mediaDirection && mediaDirection.sendAudio && mediaDirection.sendVideo && mediaDirection.sendShare && isBrowser('safari')) {
          _loggerProxy.default.logger.warn('Meeting:index#getMediaStreams --> Setting `sendShare` to FALSE, due to complications with Safari');
          mediaDirection.sendShare = false;
          _loggerProxy.default.logger.warn('Meeting:index#getMediaStreams --> Enabling `sendShare` along with `sendAudio` & `sendVideo`, on Safari, causes a failure while setting up a screen share at the same time as the camera+mic stream');
          _loggerProxy.default.logger.warn('Meeting:index#getMediaStreams --> Please use `meeting.shareScreen()` to manually start the screen share after successfully joining the meeting');
        }
        if (audioVideo && (0, _isString2.default)(audioVideo)) {
          if ((0, _keys.default)(_constants.VIDEO_RESOLUTIONS).includes(audioVideo)) {
            _this.mediaProperties.setLocalQualityLevel(audioVideo);
            audioVideo = {
              video: _constants.VIDEO_RESOLUTIONS[audioVideo].video
            };
          } else {
            throw new _parameter.default("".concat(audioVideo, " not supported. Either pass level from pre-defined resolutions or pass complete audioVideo object"));
          }
        }
        if (!audioVideo.video) {
          audioVideo = _objectSpread(_objectSpread({}, audioVideo), {}, {
            video: _objectSpread(_objectSpread({}, audioVideo.video), _constants.VIDEO_RESOLUTIONS[_this.mediaProperties.localQualityLevel].video)
          });
        }
        // extract deviceId if exists otherwise default to null.
        var _ref2 = audioVideo && audioVideo.video || {
            deviceId: null
          },
          preferredVideoDevice = _ref2.deviceId;
        var lastVideoDeviceId = _this.mediaProperties.getVideoDeviceId();
        if (preferredVideoDevice) {
          // Store new preferred video input device
          _this.mediaProperties.setVideoDeviceId(preferredVideoDevice);
        } else if (lastVideoDeviceId) {
          // no new video preference specified so use last stored value,
          // works with empty object {} or media constraint.
          // eslint-disable-next-line no-param-reassign
          audioVideo = _objectSpread(_objectSpread({}, audioVideo), {}, {
            video: _objectSpread(_objectSpread({}, audioVideo.video), {}, {
              deviceId: lastVideoDeviceId
            })
          });
        }
        return _media.default.getSupportedDevice({
          sendAudio: mediaDirection.sendAudio,
          sendVideo: mediaDirection.sendVideo
        }).catch(function (error) {
          return _promise.default.reject(new _media2.default('Given constraints do not match permission set for either camera or microphone', error));
        }).then(function (devicePermissions) {
          return _media.default.getUserMedia(_objectSpread(_objectSpread({}, mediaDirection), {}, {
            sendAudio: devicePermissions.sendAudio,
            sendVideo: devicePermissions.sendVideo,
            isSharing: _this.shareStatus === _constants.SHARE_STATUS.LOCAL_SHARE_ACTIVE
          }), audioVideo, sharePreferences,
          // @ts-ignore - config coming from registerPlugin
          _this.config).catch(function (error) {
            var _this$locusUrl;
            // Whenever there is a failure when trying to access a user's device
            // report it as an Behavioral metric
            // This gives visibility into common errors and can help
            // with further troubleshooting
            var metricName = _constants2.default.GET_USER_MEDIA_FAILURE;
            var data = {
              correlation_id: _this.correlationId,
              locus_id: (_this$locusUrl = _this.locusUrl) === null || _this$locusUrl === void 0 ? void 0 : _this$locusUrl.split('/').pop(),
              reason: error.message,
              stack: error.stack
            };
            var metadata = {
              type: error.name
            };
            _metrics.default.sendBehavioralMetric(metricName, data, metadata);
            throw new _media2.default('Unable to retrieve media streams', error);
          });
        });
      }
      return _promise.default.reject(new _media2.default('At least one of the mediaDirection value should be true'));
    });
    /**
     * Checks if the machine has at least one audio or video device
     * @param {Object} options
     * @param {Boolean} options.sendAudio
     * @param {Boolean} options.sendVideo
     * @returns {Object}
     * @memberof Meetings
     */
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "getSupportedDevices", function (_ref3) {
      var _ref3$sendAudio = _ref3.sendAudio,
        sendAudio = _ref3$sendAudio === void 0 ? true : _ref3$sendAudio,
        _ref3$sendVideo = _ref3.sendVideo,
        sendVideo = _ref3$sendVideo === void 0 ? true : _ref3$sendVideo;
      return _media.default.getSupportedDevice({
        sendAudio: sendAudio,
        sendVideo: sendVideo
      });
    });
    /**
     * Get the devices from the Media module
     * @returns {Promise} resolves to an array of DeviceInfo
     * @memberof Meetings
     */
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "getDevices", function () {
      return _media.default.getDevices();
    });
    /**
     * Registers for all required StatsAnalyzer events
     * @private
     * @returns {void}
     * @memberof Meetings
     */
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "setupStatsAnalyzerEventHandlers", function () {
      _this.statsAnalyzer.on(_statsAnalyzer.EVENTS.MEDIA_QUALITY, function (options) {
        var _this$webex$meetings$;
        // TODO:  might have to send the same event to the developer
        // Add ip address info if geo hint is present
        // @ts-ignore fix type
        options.data.intervalMetadata.peerReflexiveIP =
        // @ts-ignore
        ((_this$webex$meetings$ = _this.webex.meetings.geoHintInfo) === null || _this$webex$meetings$ === void 0 ? void 0 : _this$webex$meetings$.clientAddress) || options.data.intervalMetadata.peerReflexiveIP || _constants.MQA_STATS.DEFAULT_IP;
        _metrics.default.postEvent({
          event: _config.eventType.MEDIA_QUALITY,
          meeting: (0, _assertThisInitialized2.default)(_this),
          data: {
            intervalData: options.data,
            networkType: options.networkType
          }
        });
      });
      _this.statsAnalyzer.on(_statsAnalyzer.EVENTS.LOCAL_MEDIA_STARTED, function (data) {
        _triggerProxy.default.trigger((0, _assertThisInitialized2.default)(_this), {
          file: 'meeting/index',
          function: 'addMedia'
        }, _constants.EVENT_TRIGGERS.MEETING_MEDIA_LOCAL_STARTED, data);
        _metrics.default.postEvent({
          event: _config.eventType.SENDING_MEDIA_START,
          meeting: (0, _assertThisInitialized2.default)(_this),
          data: {
            mediaType: data.type
          }
        });
      });
      _this.statsAnalyzer.on(_statsAnalyzer.EVENTS.LOCAL_MEDIA_STOPPED, function (data) {
        _metrics.default.postEvent({
          event: _config.eventType.SENDING_MEDIA_STOP,
          meeting: (0, _assertThisInitialized2.default)(_this),
          data: {
            mediaType: data.type
          }
        });
      });
      _this.statsAnalyzer.on(_statsAnalyzer.EVENTS.REMOTE_MEDIA_STARTED, function (data) {
        _triggerProxy.default.trigger((0, _assertThisInitialized2.default)(_this), {
          file: 'meeting/index',
          function: 'addMedia'
        }, _constants.EVENT_TRIGGERS.MEETING_MEDIA_REMOTE_STARTED, data);
        _metrics.default.postEvent({
          event: _config.eventType.RECEIVING_MEDIA_START,
          meeting: (0, _assertThisInitialized2.default)(_this),
          data: {
            mediaType: data.type
          }
        });
      });
      _this.statsAnalyzer.on(_statsAnalyzer.EVENTS.REMOTE_MEDIA_STOPPED, function (data) {
        _metrics.default.postEvent({
          event: _config.eventType.RECEIVING_MEDIA_STOP,
          meeting: (0, _assertThisInitialized2.default)(_this),
          data: {
            mediaType: data.type
          }
        });
      });
      _this.statsAnalyzer.on(_statsAnalyzer.EVENTS.NO_VIDEO_ENCODED, function (data) {
        _metrics.default.sendBehavioralMetric(_constants2.default.NO_VIDEO_ENCODED);
        _triggerProxy.default.trigger((0, _assertThisInitialized2.default)(_this), {
          file: 'meeting/index',
          function: 'compareLastStatsResult'
        }, _constants.EVENT_TRIGGERS.MEETING_NO_VIDEO_ENCODED, data);
      });
      _this.statsAnalyzer.on(_statsAnalyzer.EVENTS.NO_FRAMES_SENT, function (data) {
        var _this$mediaProperties, _this$mediaProperties2;
        if ((_this$mediaProperties = _this.mediaProperties.mediaDirection) !== null && _this$mediaProperties !== void 0 && _this$mediaProperties.sendVideo && data.mediaType === 'video' || (_this$mediaProperties2 = _this.mediaProperties.mediaDirection) !== null && _this$mediaProperties2 !== void 0 && _this$mediaProperties2.sendShare && data.mediaType === 'share') {
          _metrics.default.sendBehavioralMetric(_constants2.default.NO_FRAMES_SENT);
          _triggerProxy.default.trigger((0, _assertThisInitialized2.default)(_this), {
            file: 'meeting/index',
            function: 'compareLastStatsResult'
          }, _constants.EVENT_TRIGGERS.MEETING_NO_FRAMES_SENT, data);
        }
      });
    });
    /**
     * emits event when the negotation is completed
     * @returns {void}
     * @private
     * @memberof Meeting
     */
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "mediaNegotiatedEvent", function () {
      // @ts-ignore - config coming from registerPlugin
      if (_this.config.experimental.enableMediaNegotiatedEvent) {
        _loggerProxy.default.logger.info('Meeting:mediaNegotiatedEvent --> Media server negotiated');
        _triggerProxy.default.trigger((0, _assertThisInitialized2.default)(_this), {
          file: 'meeting/index',
          function: 'mediaNegotiatedEvent'
        }, _constants.EVENT_TRIGGERS.MEDIA_NEGOTIATED);
      }
    });
    /**
     * Checks if there are any queued media updates and runs the first one from
     * the queue if we are in a state that allows doing that.
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "processNextQueuedMediaUpdate", function () {
      if (_this.canUpdateMedia() && _this.queuedMediaUpdates.length > 0) {
        var _this$queuedMediaUpda = _this.queuedMediaUpdates.shift(),
          pendingPromiseResolve = _this$queuedMediaUpda.pendingPromiseResolve,
          pendingPromiseReject = _this$queuedMediaUpda.pendingPromiseReject,
          mediaUpdateType = _this$queuedMediaUpda.mediaUpdateType,
          options = _this$queuedMediaUpda.options;
        _loggerProxy.default.logger.log("Meeting:index#processNextQueuedMediaUpdate --> performing delayed media update type=".concat(mediaUpdateType));
        switch (mediaUpdateType) {
          case MEDIA_UPDATE_TYPE.ALL:
            _this.updateMedia(options).then(pendingPromiseResolve, pendingPromiseReject);
            break;
          case MEDIA_UPDATE_TYPE.AUDIO:
            _this.updateAudio(options).then(pendingPromiseResolve, pendingPromiseReject);
            break;
          case MEDIA_UPDATE_TYPE.VIDEO:
            _this.updateVideo(options).then(pendingPromiseResolve, pendingPromiseReject);
            break;
          case MEDIA_UPDATE_TYPE.SHARE:
            _this.updateShare(options).then(pendingPromiseResolve, pendingPromiseReject);
            break;
          default:
            _loggerProxy.default.logger.error("Peer-connection-manager:index#processNextQueuedMediaUpdate --> unsupported media update type ".concat(mediaUpdateType, " found in the queue"));
            break;
        }
      }
    });
    /**
     * clear the meeting data
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "clearMeetingData", function () {
      _this.audio = null;
      _this.video = null;
      _this.isSharing = false;
      if (_this.shareStatus === _constants.SHARE_STATUS.LOCAL_SHARE_ACTIVE) {
        _this.shareStatus = _constants.SHARE_STATUS.NO_SHARE;
      }
      _this.queuedMediaUpdates = [];
      if (_this.transcription) {
        _this.transcription.closeSocket();
        _this.triggerStopReceivingTranscriptionEvent();
        _this.transcription = undefined;
      }
    });
    /**
     * starts keepAlives being sent
     * @returns {void}
     * @private
     * @memberof Meeting
     */
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "startKeepAlive", function () {
      var _this$joinedWith, _this$joinedWith2;
      if (_this.keepAliveTimerId) {
        _loggerProxy.default.logger.warn('Meeting:index#startKeepAlive --> keepAlive not started: keepAliveTimerId already exists');
        return;
      }
      if (!((_this$joinedWith = _this.joinedWith) !== null && _this$joinedWith !== void 0 && _this$joinedWith.keepAliveUrl)) {
        _loggerProxy.default.logger.warn('Meeting:index#startKeepAlive --> keepAlive not started: no keepAliveUrl');
        return;
      }
      if (!((_this$joinedWith2 = _this.joinedWith) !== null && _this$joinedWith2 !== void 0 && _this$joinedWith2.keepAliveSecs)) {
        _loggerProxy.default.logger.warn('Meeting:index#startKeepAlive --> keepAlive not started: no keepAliveSecs');
        return;
      }
      if (_this.joinedWith.keepAliveSecs <= 1) {
        _loggerProxy.default.logger.warn('Meeting:index#startKeepAlive --> keepAlive not started: keepAliveSecs <= 1');
        return;
      }
      var keepAliveUrl = _this.joinedWith.keepAliveUrl;
      var keepAliveInterval = (_this.joinedWith.keepAliveSecs - 1) * 750; // taken from UCF

      _this.keepAliveTimerId = setInterval(function () {
        _this.meetingRequest.keepAlive({
          keepAliveUrl: keepAliveUrl
        }).catch(function (error) {
          _loggerProxy.default.logger.warn("Meeting:index#startKeepAlive --> Stopping sending keepAlives to ".concat(keepAliveUrl, " after error ").concat(error));
          _this.stopKeepAlive();
        });
      }, keepAliveInterval);
    });
    /**
     * stops keepAlives being sent
     * @returns {void}
     * @private
     * @memberof Meeting
     */
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "stopKeepAlive", function () {
      if (!_this.keepAliveTimerId) {
        return;
      }
      clearInterval(_this.keepAliveTimerId);
      _this.keepAliveTimerId = null;
    });
    _this.attrs = attrs;
    /**
     * @instance
     * @type {Object}
     * @readonly
     * @private
     * @memberof Meeting
     */
    _this.options = _options;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.id = _uuid.default.v4();
    /**
     * Correlation ID used for network tracking of meeting join
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.correlationId = _this.id;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.userId = attrs.userId;
    /**
     * Organization ID
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.orgId = attrs.orgId;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.resource = attrs.resource;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.deviceUrl = attrs.deviceUrl;
    /**
     * @description set you -1 as default values is 0 (used to idenfify if 1st roap request was sent)
     * @instance
     * @type {Number}
     * @readonly
     * @private
     * @memberof Meeting
     */
    _this.roapSeq = _constants.ROAP_SEQ_PRE;
    /**
     * @instance
     * @type {Object}
     * @readonly
     * @public
     * @memberof Meeting
     */
    // TODO: needs to be defined as a class
    _this.meetingInfo = {};
    /**
     * @instance
     * @type {Members}
     * @public
     * @memberof Meeting
     */
    // @ts-ignore - Fix type
    _this.members = new _index2.default({
      locusUrl: attrs.locus && attrs.locus.url
    }, {
      parent: _this.webex
    });
    /**
     * @instance
     * @type {Roap}
     * @readonly
     * @private
     * @memberof Meeting
     */
    // @ts-ignore - Fix type
    _this.roap = new _index.default({}, {
      parent: _this.webex
    });
    /**
     * created later
     * @instance
     * @type {ReconnectionManager}
     * @readonly
     * @private
     * @memberof Meeting
     */
    _this.reconnectionManager = new _reconnectionManager.default((0, _assertThisInitialized2.default)(_this));
    /**
     * created later
     * @instance
     * @type {MuteState}
     * @private
     * @memberof Meeting
     */
    _this.audio = null;
    /**
     * created later
     * @instance
     * @type {MuteState}
     * @private
     * @memberof Meeting
     */
    _this.video = null;
    /**
     * created later
     * @instance
     * @type {EffectsState}
     * @private
     * @memberof Meeting
     */
    _this.effects = null;
    /**
     * @instance
     * @type {MeetingStateMachine}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.meetingFiniteStateMachine = _state.default.create((0, _assertThisInitialized2.default)(_this));
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.conversationUrl = null;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.locusUrl = attrs.locus && attrs.locus.url || null;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.sipUri = null;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.destination = attrs.destination;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.destinationType = attrs.destinationType;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.partner = null;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.type = null;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.owner = null;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.hostId = null;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.policy = null;
    /**
     * @instance
     * @type {MeetingRequest}
     * @private
     * @memberof Meeting
     */
    _this.meetingRequest = new _request.default({}, _options);
    /**
     * @instance
     * @type {Array}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.mediaConnections = null;

    /**
     * Fetching meeting info can be done randomly 2-5 mins before meeting start
     * In case it is done before the timer expires, this timeout id is reset to cancel the timer.
     * @instance
     * @type {Number}
     * @readonly
     * @private
     * @memberof Meeting
     */
    _this.fetchMeetingInfoTimeoutId = null;

    /**
     * Update the MediaConnections property with new information
     * @param {array} mediaConnections
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
    _this.updateMediaConnections = function (mediaConnections) {
      if (!(0, _isEqual2.default)(_this.mediaConnections, mediaConnections)) {
        // grab last/latest item in the new mediaConnections information
        _this.mediaConnections = mediaConnections.slice(-1);
      }
    };
    /**
     * Passing only info as we send basic info for meeting added event
     * @instance
     * @type {MediaProperties}
     * @public
     * @memberof Meeting
     */
    _this.mediaProperties = new _properties.default();
    /**
     * @instance
     * @type {InMeetingActions}
     * @public
     * @memberof Meeting
     */
    _this.inMeetingActions = new _inMeetingActions.default();
    /**
     * This is deprecated, please use shareStatus instead.
     * @instance
     * @type {Boolean}
     * @readonly
     * @public
     * @memberof Meeting
     * @deprecated after v1.118.13
     */
    _this.isSharing = false;
    /**
     * @instance
     * @type {string}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.shareStatus = _constants.SHARE_STATUS.NO_SHARE;
    /**
     * @instance
     * @type {Boolean}
     * @readonly
     * @private
     * @memberof Meeting
     */
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), 'isLocalShareLive', {
      get: function get() {
        var _shareTransceiver$sen, _shareTransceiver$sen2;
        var shareTransceiver = _this.mediaProperties.peerConnection.shareTransceiver;
        var shareDirection = shareTransceiver === null || shareTransceiver === void 0 ? void 0 : shareTransceiver.direction;
        var trackReadyState = shareTransceiver === null || shareTransceiver === void 0 ? void 0 : (_shareTransceiver$sen = shareTransceiver.sender) === null || _shareTransceiver$sen === void 0 ? void 0 : (_shareTransceiver$sen2 = _shareTransceiver$sen.track) === null || _shareTransceiver$sen2 === void 0 ? void 0 : _shareTransceiver$sen2.readyState;
        var activeShare = trackReadyState === _constants.LIVE;
        var offersToSendData = shareDirection === _constants.SENDRECV;
        if (activeShare && offersToSendData) {
          return true;
        }
        return false;
      },
      configurable: true
    });
    /**
     * @instance
     * @type {Array}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.callEvents = [];
    /**
     * There is a pending floor requested by the user
     * @instance
     * @type {boolean}
     * @private
     * @memberof Meeting
     */
    _this.floorGrantPending = false;
    /**
     * The latest status of the dial in device (can be "JOINED", "CONNECTED", "LEFT",
     * "TRANSFERRING", "SUCCESS" or "")
     * @instance
     * @type {String}
     * @private
     * @memberof Meeting
     */
    _this.dialInDeviceStatus = _constants.PSTN_STATUS.UNKNOWN;
    /**
     * the url for provisioned device used to dial in
     * @instance
     * @type {String}
     * @private
     * @memberof Meeting
     */
    _this.dialInUrl = '';
    /**
     * The latest status of the dial out device (can be "JOINED", "CONNECTED", "LEFT",
     * "TRANSFERRING", "SUCCESS" or "")
     * @instance
     * @type {String}
     * @private
     * @memberof Meeting
     */
    _this.dialOutDeviceStatus = _constants.PSTN_STATUS.UNKNOWN;
    /**
     * the url for provisioned device used to dial out
     * @instance
     * @type {String}
     * @private
     * @memberof Meeting
     */
    _this.dialOutUrl = '';
    /**
     * @instance
     * @type {StatsAnalyzer}
     * @private
     * @memberof Meeting
     */
    _this.statsAnalyzer = null;
    /**
     * @instance
     * @type {NetworkQualityMonitor}
     * @private
     * @memberof Meeting
     */
    _this.networkQualityMonitor = null;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.networkStatus = null;
    /**
     * Passing only info as we send basic info for meeting added event
     * @instance
     * @type {MeetingRequest}
     * @private
     * @memberof Meeting
     */
    // @ts-ignore - Fix type
    _this.locusInfo = new _locusInfo.default(_this.updateMeetingObject.bind((0, _assertThisInitialized2.default)(_this)), _this.webex, _this.id);

    // We had to add listeners first before setting up the locus instance
    /**
     * @instance
     * @type {Recording}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.recording = null;

    /**
     * Promise that exists if joining, and resolves upon method completion.
     * @instance
     * @type {Promise}
     * @private
     * @memberof Meeting
     */
    _this.deferJoin = undefined;

    /**
     * Staus of websocket connection/mercury connection.
     * @instance
     * @type {Boolean}
     * @private
     * @memberof Meeting
     */
    // @ts-ignore - Fix type
    _this.hasWebsocketConnected = _this.webex.internal.mercury.connected;

    /**
     * Last sent render information
     * @instance
     * @type {Object}
     * @private
     * @memberof Meeting
     */
    _this.lastVideoLayoutInfo = {
      layoutType: undefined,
      main: undefined,
      content: undefined
    };

    /**
     * Queue of pending media updates requested by the app
     * @instance
     * @type {Array}
     * @private
     * @memberof Meeting
     */
    _this.queuedMediaUpdates = [];

    /**
     * Meeting transcription object
     * @instance
     * @type {Transcription}
     * @private
     * @memberof Meeting
     */
    _this.transcription = undefined;

    /**
     * Password status. If it's PASSWORD_STATUS.REQUIRED then verifyPassword() needs to be called
     * with the correct password before calling join()
     * @instance
     * @type {PASSWORD_STATUS}
     * @public
     * @memberof Meeting
     */
    _this.passwordStatus = _constants.PASSWORD_STATUS.UNKNOWN;

    /**
     * Information about required captcha. If null, then no captcha is required. status. If it's PASSWORD_STATUS.REQUIRED then verifyPassword() needs to be called
     * with the correct password before calling join()
     * @instance
     * @type {Object}
     * @property {string} captchaId captcha id
     * @property {string} verificationImageURL Url of the captcha image
     * @property {string} verificationAudioURL Url of the captcha audio file
     * @property {string} refreshURL Url used for refreshing the captcha (don't use it directly, call refreshCaptcha() instead)
     * @public
     * @memberof Meeting
     */
    _this.requiredCaptcha = null;

    /**
     * Indicates the reason for last failure to obtain meeting.meetingInfo. MEETING_INFO_FAILURE_REASON.NONE if meeting info was
     * retrieved successfully
     * @instance
     * @type {MEETING_INFO_FAILURE_REASON}
     * @private
     * @memberof Meeting
     */
    _this.meetingInfoFailureReason = undefined;

    /**
     * Repeating timer used to send keepAlives when in lobby
     * @instance
     * @type {String}
     * @private
     * @memberof Meeting
     */
    _this.keepAliveTimerId = null;

    /**
     * The class that helps to control recording functions: start, stop, pause, resume, etc
     * @instance
     * @type {RecordingController}
     * @public
     * @memberof Meeting
     */
    _this.recordingController = new _recordingController.default(_this.meetingRequest, {
      serviceUrl: (_this$locusInfo = _this.locusInfo) === null || _this$locusInfo === void 0 ? void 0 : (_this$locusInfo$links = _this$locusInfo.links) === null || _this$locusInfo$links === void 0 ? void 0 : (_this$locusInfo$links2 = _this$locusInfo$links.services) === null || _this$locusInfo$links2 === void 0 ? void 0 : (_this$locusInfo$links3 = _this$locusInfo$links2.record) === null || _this$locusInfo$links3 === void 0 ? void 0 : _this$locusInfo$links3.url,
      sessionId: (_this$locusInfo2 = _this.locusInfo) === null || _this$locusInfo2 === void 0 ? void 0 : (_this$locusInfo2$full = _this$locusInfo2.fullState) === null || _this$locusInfo2$full === void 0 ? void 0 : _this$locusInfo2$full.sessionId,
      locusUrl: (_this$locusInfo3 = _this.locusInfo) === null || _this$locusInfo3 === void 0 ? void 0 : _this$locusInfo3.url,
      displayHints: []
    });

    /**
     * The class that helps to control recording functions: start, stop, pause, resume, etc
     * @instance
     * @type {ControlsOptionsManager}
     * @public
     * @memberof Meeting
     */
    _this.controlsOptionsManager = new _controlsOptionsManager.default(_this.meetingRequest, {
      locusUrl: (_this$locusInfo4 = _this.locusInfo) === null || _this$locusInfo4 === void 0 ? void 0 : _this$locusInfo4.url,
      displayHints: []
    });
    _this.setUpLocusInfoListeners();
    _this.locusInfo.init(attrs.locus ? attrs.locus : {});
    _this.hasJoinedOnce = false;
    return _this;
  }

  /**
   * Fetches meeting information.
   * @param {Object} options
   * @param {String} [options.password] optional
   * @param {String} [options.captchaCode] optional
   * @public
   * @memberof Meeting
   * @returns {Promise}
   */
  (0, _createClass2.default)(Meeting, [{
    key: "fetchMeetingInfo",
    value: function () {
      var _fetchMeetingInfo = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(_ref4) {
        var _ref4$password, password, _ref4$captchaCode, captchaCode, captchaInfo, info, _err$body, _err$body2;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _ref4$password = _ref4.password, password = _ref4$password === void 0 ? null : _ref4$password, _ref4$captchaCode = _ref4.captchaCode, captchaCode = _ref4$captchaCode === void 0 ? null : _ref4$captchaCode;
              // when fetch meeting info is called directly by the client, we want to clear out the random timer for sdk to do it
              if (this.fetchMeetingInfoTimeoutId) {
                clearTimeout(this.fetchMeetingInfoTimeoutId);
                this.fetchMeetingInfoTimeoutId = undefined;
              }
              if (!(captchaCode && !this.requiredCaptcha)) {
                _context.next = 4;
                break;
              }
              return _context.abrupt("return", _promise.default.reject(new Error('fetchMeetingInfo() called with captchaCode when captcha was not required')));
            case 4:
              if (!(password && this.passwordStatus !== _constants.PASSWORD_STATUS.REQUIRED && this.passwordStatus !== _constants.PASSWORD_STATUS.UNKNOWN)) {
                _context.next = 6;
                break;
              }
              return _context.abrupt("return", _promise.default.reject(new Error('fetchMeetingInfo() called with password when password was not required')));
            case 6:
              _context.prev = 6;
              captchaInfo = captchaCode ? {
                code: captchaCode,
                id: this.requiredCaptcha.captchaId
              } : null;
              _context.next = 10;
              return this.attrs.meetingInfoProvider.fetchMeetingInfo(this.destination, this.destinationType, password, captchaInfo);
            case 10:
              info = _context.sent;
              this.parseMeetingInfo(info, this.destination);
              this.meetingInfo = info ? info.body : null;
              this.meetingInfoFailureReason = _constants.MEETING_INFO_FAILURE_REASON.NONE;
              this.requiredCaptcha = null;
              if (this.passwordStatus === _constants.PASSWORD_STATUS.REQUIRED || this.passwordStatus === _constants.PASSWORD_STATUS.VERIFIED) {
                this.passwordStatus = _constants.PASSWORD_STATUS.VERIFIED;
              } else {
                this.passwordStatus = _constants.PASSWORD_STATUS.NOT_REQUIRED;
              }
              _triggerProxy.default.trigger(this, {
                file: 'meetings',
                function: 'fetchMeetingInfo'
              }, _constants.EVENT_TRIGGERS.MEETING_INFO_AVAILABLE);
              return _context.abrupt("return", _promise.default.resolve());
            case 20:
              _context.prev = 20;
              _context.t0 = _context["catch"](6);
              if (!(_context.t0 instanceof _meetingInfoV.MeetingInfoV2PasswordError)) {
                _context.next = 33;
                break;
              }
              // @ts-ignore
              _loggerProxy.default.logger.info("Meeting:index#fetchMeetingInfo --> Info Unable to fetch meeting info for ".concat(this.destination, " - password required (code=").concat(_context.t0 === null || _context.t0 === void 0 ? void 0 : (_err$body = _context.t0.body) === null || _err$body === void 0 ? void 0 : _err$body.code, ")."));

              // when wbxappapi requires password it still populates partial meeting info in the response
              if (_context.t0.meetingInfo) {
                this.meetingInfo = _context.t0.meetingInfo;
                this.meetingNumber = _context.t0.meetingInfo.meetingNumber;
              }
              this.passwordStatus = _constants.PASSWORD_STATUS.REQUIRED;
              this.meetingInfoFailureReason = _constants.MEETING_INFO_FAILURE_REASON.WRONG_PASSWORD;
              if (!this.requiredCaptcha) {
                _context.next = 30;
                break;
              }
              _context.next = 30;
              return this.refreshCaptcha();
            case 30:
              throw new _passwordError.default();
            case 33:
              if (!(_context.t0 instanceof _meetingInfoV.MeetingInfoV2CaptchaError)) {
                _context.next = 41;
                break;
              }
              // @ts-ignore
              _loggerProxy.default.logger.info("Meeting:index#fetchMeetingInfo --> Info Unable to fetch meeting info for ".concat(this.destination, " - captcha required (code=").concat(_context.t0 === null || _context.t0 === void 0 ? void 0 : (_err$body2 = _context.t0.body) === null || _err$body2 === void 0 ? void 0 : _err$body2.code, ")."));
              this.meetingInfoFailureReason = this.requiredCaptcha ? _constants.MEETING_INFO_FAILURE_REASON.WRONG_CAPTCHA : _constants.MEETING_INFO_FAILURE_REASON.WRONG_PASSWORD;
              if (_context.t0.isPasswordRequired) {
                this.passwordStatus = _constants.PASSWORD_STATUS.REQUIRED;
              }
              this.requiredCaptcha = _context.t0.captchaInfo;
              throw new _captchaError.default();
            case 41:
              this.meetingInfoFailureReason = _constants.MEETING_INFO_FAILURE_REASON.OTHER;
              throw _context.t0;
            case 43:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[6, 20]]);
      }));
      function fetchMeetingInfo(_x) {
        return _fetchMeetingInfo.apply(this, arguments);
      }
      return fetchMeetingInfo;
    }()
    /**
     * Checks if the supplied password/host key is correct. It returns a promise with information whether the
     * password and captcha code were correct or not.
     * @param {String} password - this can be either a password or a host key, can be undefined if only captcha was required
     * @param {String} captchaCode - can be undefined if captcha was not required by the server
     * @public
     * @memberof Meeting
     * @returns {Promise<{isPasswordValid: boolean, requiredCaptcha: boolean, failureReason: MEETING_INFO_FAILURE_REASON}>}
     */
  }, {
    key: "verifyPassword",
    value: function verifyPassword(password, captchaCode) {
      var _this2 = this;
      return this.fetchMeetingInfo({
        password: password,
        captchaCode: captchaCode
      }).then(function () {
        _metrics.default.sendBehavioralMetric(_constants2.default.VERIFY_PASSWORD_SUCCESS);
        return {
          isPasswordValid: true,
          requiredCaptcha: null,
          failureReason: _constants.MEETING_INFO_FAILURE_REASON.NONE
        };
      }).catch(function (error) {
        if (error instanceof _passwordError.default || error instanceof _captchaError.default) {
          return {
            isPasswordValid: _this2.passwordStatus === _constants.PASSWORD_STATUS.VERIFIED,
            requiredCaptcha: _this2.requiredCaptcha,
            failureReason: _this2.meetingInfoFailureReason
          };
        }
        throw error;
      });
    }

    /**
     * Refreshes the captcha. As a result the meeting will have new captcha id, image and audio.
     * If the refresh operation fails, meeting remains with the old captcha properties.
     * @public
     * @memberof Meeting
     * @returns {Promise}
     */
  }, {
    key: "refreshCaptcha",
    value: function refreshCaptcha() {
      var _this3 = this;
      if (!this.requiredCaptcha) {
        return _promise.default.reject(new Error('There is no captcha to refresh'));
      }

      // in order to get fully populated uris for captcha audio and image in response to refresh captcha request
      // we have to pass the wbxappapi hostname as the siteFullName parameter
      var _URL = new URL(this.requiredCaptcha.refreshURL),
        hostname = _URL.hostname;
      return this.meetingRequest
      // @ts-ignore
      .refreshCaptcha({
        captchaRefreshUrl: "".concat(this.requiredCaptcha.refreshURL, "&siteFullName=").concat(hostname),
        captchaId: this.requiredCaptcha.captchaId
      }).then(function (response) {
        _this3.requiredCaptcha.captchaId = response.body.captchaID;
        _this3.requiredCaptcha.verificationImageURL = response.body.verificationImageURL;
        _this3.requiredCaptcha.verificationAudioURL = response.body.verificationAudioURL;
      }).catch(function (error) {
        _loggerProxy.default.logger.error("Meeting:index#refreshCaptcha --> Error Unable to refresh captcha for ".concat(_this3.destination, " - ").concat(error));
        throw error;
      });
    }

    /**
     * Proxy function for all the listener set ups
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
  }, {
    key: "setUpLocusInfoListeners",
    value: function setUpLocusInfoListeners() {
      // meeting update listeners
      this.setUpLocusInfoSelfListener();
      this.setUpLocusInfoMeetingListener();
      this.setUpLocusServicesListener();
      // members update listeners
      this.setUpLocusFullStateListener();
      this.setUpLocusUrlListener();
      this.setUpLocusHostListener();
      this.setUpLocusSelfListener();
      this.setUpLocusParticipantsListener();
      this.setupLocusControlsListener();
      this.setUpLocusMediaSharesListener();
      this.setUpLocusEmbeddedAppsListener();
      this.setUpLocusInfoMeetingInfoListener();
      this.setUpLocusInfoAssignHostListener();
      this.setUpLocusInfoMediaInactiveListener();
    }

    /**
     * Set up the locus info listener for meetings disconnected due to inactivity
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
  }, {
    key: "setUpLocusInfoMediaInactiveListener",
    value: function setUpLocusInfoMediaInactiveListener() {
      var _this4 = this;
      // User gets kicked off the meeting due to inactivity or user did a refresh
      this.locusInfo.on(_constants.EVENTS.DISCONNECT_DUE_TO_INACTIVITY, function (res) {
        // https:// jira-eng-gpk2.cisco.com/jira/browse/SPARK-240520
        // TODO: send custom parameter explaining why the inactivity happened
        // refresh , no media or network got dsconnected or something else
        _metrics.default.sendBehavioralMetric(_constants2.default.DISCONNECT_DUE_TO_INACTIVITY, {
          correlation_id: _this4.correlationId,
          locus_id: _this4.locusId
        });

        // Upload logs on media inactivity
        // Normally media should not be inactive
        _triggerProxy.default.trigger(_this4, {
          file: 'meeting/index',
          function: 'setUpLocusInfoMediaInactiveListener'
        }, _constants.EVENTS.REQUEST_UPLOAD_LOGS, _this4);
        _loggerProxy.default.logger.error("Meeting:index#setUpLocusInfoMediaInactiveListener --> Meeting disconnected due to inactivity: ".concat(res.reason));

        // @ts-ignore - config coming from registerPlugin
        if (_this4.config.reconnection.autoRejoin) {
          _this4.reconnect();
        } else {
          _triggerProxy.default.trigger(_this4, {
            file: 'meeting/index',
            function: 'setUpLocusInfoMediaInactiveListener'
          }, _constants.EVENT_TRIGGERS.MEETING_SELF_LEFT, res.reason);
        }
      });
    }

    /**
     * Set up the locus info listener for assign host permissions on a meeting
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
  }, {
    key: "setUpLocusInfoAssignHostListener",
    value: function setUpLocusInfoAssignHostListener() {
      var _this5 = this;
      this.locusInfo.on(_constants.EVENTS.LOCUS_INFO_CAN_ASSIGN_HOST, function (payload) {
        var changed = _this5.inMeetingActions.set({
          canAssignHost: payload.canAssignHost
        });
        if (changed) {
          _triggerProxy.default.trigger(_this5, {
            file: 'meeting/index',
            function: 'setUpLocusInfoAssignHostListener'
          }, _constants.EVENT_TRIGGERS.MEETING_ACTIONS_UPDATE, _this5.inMeetingActions.get());
        }
      });
    }

    /**
     * Set up the internal locus info full state object listener
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
  }, {
    key: "setUpLocusFullStateListener",
    value: function setUpLocusFullStateListener() {
      var _this6 = this;
      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.FULL_STATE_MEETING_STATE_CHANGE, function (payload) {
        _triggerProxy.default.trigger(_this6, {
          file: 'meeting/index',
          function: 'setUpLocusFullStateListener'
        }, _constants.EVENT_TRIGGERS.MEETING_STATE_CHANGE, {
          payload: payload
        });
      });
      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.FULL_STATE_TYPE_UPDATE, function (payload) {
        _this6.members.locusFullStateTypeUpdate(payload);
      });
    }

    /**
     * get the metrics payload pre
     * @param {Object} options
     * @param {String} options.event
     * @param {String} options.trackingId
     * @param {Object} options.locus
     * @param {Array} options.mediaConnections
     * @param {Object} options.errors
     * @returns {Object}
     * @memberof Meeting
     */
  }, {
    key: "getAnalyzerMetricsPrePayload",
    value: function getAnalyzerMetricsPrePayload(options) {
      if (options) {
        var event = options.event,
          trackingId = options.trackingId,
          _mediaConnections = options.mediaConnections;
        if (!event) {
          _loggerProxy.default.logger.error('Meeting:index#getAnalyzerMetricsPrePayload --> Error [Call Analyzer Event', event || '', "]: invalid identifers or event type! ".concat(this.correlationId));
          return null;
        }
        var identifiers = {
          correlationId: this.correlationId,
          userId: this.userId,
          deviceId: this.deviceUrl,
          orgId: this.orgId,
          // @ts-ignore fix type
          locusUrl: this.webex.internal.services.get('locus')
        };
        if (this.locusUrl && this.locusInfo.fullState) {
          identifiers.locusUrl = this.locusUrl;
          identifiers.locusId = this.locusUrl && this.locusUrl.split('/').pop();
          identifiers.locusStartTime = this.locusInfo.fullState && this.locusInfo.fullState.lastActive;
        }

        // Check if mediaConnections has been passed in or else use this.mediaConnections
        if (_mediaConnections) {
          identifiers.mediaAgentAlias = _mediaConnections === null || _mediaConnections === void 0 ? void 0 : _mediaConnections[0].mediaAgentAlias;
          identifiers.mediaAgentGroupId = _mediaConnections === null || _mediaConnections === void 0 ? void 0 : _mediaConnections[0].mediaAgentGroupId;
          identifiers.mediaAgentCluster = _mediaConnections === null || _mediaConnections === void 0 ? void 0 : _mediaConnections[0].mediaAgentCluster;
        } else if (this.mediaConnections) {
          var _this$mediaConnection, _this$mediaConnection2, _this$mediaConnection3;
          identifiers.mediaAgentAlias = (_this$mediaConnection = this.mediaConnections) === null || _this$mediaConnection === void 0 ? void 0 : _this$mediaConnection[0].mediaAgentAlias;
          identifiers.mediaAgentGroupId = (_this$mediaConnection2 = this.mediaConnections) === null || _this$mediaConnection2 === void 0 ? void 0 : _this$mediaConnection2[0].mediaAgentGroupId;
          identifiers.mediaAgentCluster = (_this$mediaConnection3 = this.mediaConnections) === null || _this$mediaConnection3 === void 0 ? void 0 : _this$mediaConnection3[0].mediaAgentCluster;
        }
        if (options.trackingId) {
          identifiers.trackingId = trackingId;
        }
        var payload = {};
        var joinRespRxStartAudio = this.getSetupDelayDuration('audio');
        if (joinRespRxStartAudio) {
          options.audioSetupDelay = {
            joinRespRxStart: joinRespRxStartAudio
          };
        }
        var joinRespRxStartVideo = this.getSetupDelayDuration('video');
        if (joinRespRxStartAudio) {
          options.videoSetupDelay = {
            joinRespRxStart: joinRespRxStartVideo
          };
        }
        var joinRespTxStartAudio = this.getSendingMediaDelayDuration('audio');
        if (joinRespTxStartAudio) {
          options.audioSetupDelay = _objectSpread(_objectSpread({}, options.audioSetupDelay), {}, {
            joinRespTxStart: joinRespTxStartAudio
          });
        }
        var joinRespTxStartVideo = this.getSendingMediaDelayDuration('video');
        if (joinRespTxStartVideo) {
          options.videoSetupDelay = _objectSpread(_objectSpread({}, options.videoSetupDelay), {}, {
            joinRespTxStart: joinRespTxStartVideo
          });
        }
        var localSDPGenRemoteSDPRecv = this.getLocalSDPGenRemoteSDPRecvDelay();
        if (localSDPGenRemoteSDPRecv) {
          options.joinTimes = _objectSpread(_objectSpread({}, options.joinTimes), {}, {
            localSDPGenRemoteSDPRecv: localSDPGenRemoteSDPRecv
          });
        }
        var callInitiateJoinReq = this.getCallInitiateJoinReq();
        if (callInitiateJoinReq) {
          options.joinTimes = _objectSpread(_objectSpread({}, options.joinTimes), {}, {
            callInitiateJoinReq: callInitiateJoinReq
          });
        }
        var joinReqResp = this.getJoinReqResp();
        if (joinReqResp) {
          options.joinTimes = _objectSpread(_objectSpread({}, options.joinTimes), {}, {
            joinReqResp: joinReqResp
          });
        }
        var getTotalJmt = this.getTotalJmt();
        if (getTotalJmt) {
          options.joinTimes = _objectSpread(_objectSpread({}, options.joinTimes), {}, {
            getTotalJmt: getTotalJmt
          });
        }
        if (options.type === _constants.MQA_STATS.CA_TYPE) {
          payload = _metrics.default.initMediaPayload(options.event, identifiers, options);
        } else {
          payload = _metrics.default.initPayload(options.event, identifiers, options);
        }
        return payload;
      }
      return null;
    }

    /**
     * Send the metrics to call-analyzer dashboard
     * @param {Object} options
     * @param {String} options.event
     * @param {String} options.trackingId
     * @param {Object} options.locus
     * @param {Object} options.errors
     * @returns {Promise}
     * @private
     * @memberof Meeting
     */
  }, {
    key: "sendCallAnalyzerMetrics",
    value: function sendCallAnalyzerMetrics(options) {
      var payload = this.getAnalyzerMetricsPrePayload(_objectSpread(_objectSpread({}, (0, _pick2.default)(this.config.metrics, ['clientType', 'subClientType'])), options));

      // @ts-ignore - fix type
      return this.webex.internal.metrics.submitCallDiagnosticEvents(payload);
    }

    /**
     * Send the metrics to Media Quality Analyzer dashboard
     * @param {Object} options
     * @param {String} options.event
     * @param {String} options.trackingId
     * @param {Object} options.locus
     * @returns {Promise}
     * @private
     * @memberof Meeting
     */
  }, {
    key: "sendMediaQualityAnalyzerMetrics",
    value: function sendMediaQualityAnalyzerMetrics(options) {
      var payload = this.getAnalyzerMetricsPrePayload(_objectSpread(_objectSpread({
        type: _constants.MQA_STATS.CA_TYPE
      }, (0, _pick2.default)(this.config.metrics, ['clientType', 'subClientType'])), options));

      // @ts-ignore
      return this.webex.internal.metrics.submitCallDiagnosticEvents(payload);
    }

    /**
     * sets the network status on meeting object
     * @param {String} networkStatus
     * @private
     * @returns {undefined}
     * @memberof Meeting
     */
  }, {
    key: "setNetworkStatus",
    value: function setNetworkStatus(networkStatus) {
      if (networkStatus === _constants.NETWORK_STATUS.DISCONNECTED) {
        _triggerProxy.default.trigger(this, {
          file: 'meeting/index',
          function: 'setNetworkStatus'
        }, _constants.EVENT_TRIGGERS.MEETINGS_NETWORK_DISCONNECTED);
      } else if (networkStatus === _constants.NETWORK_STATUS.CONNECTED && this.networkStatus === _constants.NETWORK_STATUS.DISCONNECTED) {
        _triggerProxy.default.trigger(this, {
          file: 'meeting/index',
          function: 'setNetworkStatus'
        }, _constants.EVENT_TRIGGERS.MEETINGS_NETWORK_CONNECTED);
      }
      this.networkStatus = networkStatus;
    }

    /**
     * Set up the locus info self listener
     * update self value for members and updates the member
     * notifies consumer with members:self:update {activeSelfId endedSelfId}
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
  }, {
    key: "setUpLocusSelfListener",
    value: function setUpLocusSelfListener() {
      var _this7 = this;
      this.locusInfo.on(_constants.EVENTS.LOCUS_INFO_UPDATE_SELF, function (payload) {
        _this7.members.locusSelfUpdate(payload);
        _this7.pstnUpdate(payload);

        // If user moved to a JOINED state and there is a pending floor grant trigger it
        if (_this7.floorGrantPending && payload.newSelf.state === _constants.MEETING_STATE.STATES.JOINED) {
          _this7.requestScreenShareFloor().then(function () {
            _this7.floorGrantPending = false;
          });
        }
      });
    }

    /**
     * Notify any changes on the pstn devices
     * @param {Object} payload
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
  }, {
    key: "pstnUpdate",
    value: function pstnUpdate(payload) {
      var _this8 = this;
      if (this.locusInfo.self) {
        var _payload$newSelf, _payload$newSelf2;
        var dialInPstnDevice = (_payload$newSelf = payload.newSelf) === null || _payload$newSelf === void 0 ? void 0 : _payload$newSelf.pstnDevices.find(function (device) {
          return device.url === _this8.dialInUrl;
        });
        var dialOutPstnDevice = (_payload$newSelf2 = payload.newSelf) === null || _payload$newSelf2 === void 0 ? void 0 : _payload$newSelf2.pstnDevices.find(function (device) {
          return device.url === _this8.dialOutUrl;
        });
        var changed = false;
        if (dialInPstnDevice) {
          var _dialInPstnDevice$dia;
          var newStatus = (_dialInPstnDevice$dia = dialInPstnDevice.dialingStatus) !== null && _dialInPstnDevice$dia !== void 0 ? _dialInPstnDevice$dia : dialInPstnDevice.state;
          if (newStatus !== this.dialInDeviceStatus) {
            this.dialInDeviceStatus = newStatus;
            changed = true;
          }
        }
        if (dialOutPstnDevice) {
          var _dialOutPstnDevice$di;
          var _newStatus = (_dialOutPstnDevice$di = dialOutPstnDevice.dialingStatus) !== null && _dialOutPstnDevice$di !== void 0 ? _dialOutPstnDevice$di : dialOutPstnDevice.state;
          if (_newStatus !== this.dialOutDeviceStatus) {
            this.dialOutDeviceStatus = _newStatus;
            changed = true;
          }
        }
        if (changed) {
          _triggerProxy.default.trigger(this, {
            file: 'meeting/index',
            function: 'setUpLocusSelfListener'
          }, _constants.EVENT_TRIGGERS.MEETING_SELF_PHONE_AUDIO_UPDATE, {
            dialIn: {
              status: this.dialInDeviceStatus,
              attendeeId: dialInPstnDevice === null || dialInPstnDevice === void 0 ? void 0 : dialInPstnDevice.attendeeId
            },
            dialOut: {
              status: this.dialOutDeviceStatus,
              attendeeId: dialOutPstnDevice === null || dialOutPstnDevice === void 0 ? void 0 : dialOutPstnDevice.attendeeId
            }
          });
        }
      }
    }

    /**
     * Set up the locus info host listener
     * update host value for members and updates the member
     * notifies consumer with members:host:update: {activeHostId, endedHostId}
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
  }, {
    key: "setUpLocusHostListener",
    value: function setUpLocusHostListener() {
      var _this9 = this;
      this.locusInfo.on(_constants.EVENTS.LOCUS_INFO_UPDATE_HOST, function (payload) {
        _this9.members.locusHostUpdate(payload);
      });
    }

    /**
     * Set up the locus info participants update listener
     * update members collection value for members
     * notifies consumer with members:update
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
  }, {
    key: "setUpLocusParticipantsListener",
    value: function setUpLocusParticipantsListener() {
      var _this10 = this;
      this.locusInfo.on(_constants.EVENTS.LOCUS_INFO_UPDATE_PARTICIPANTS, function (payload) {
        _this10.members.locusParticipantsUpdate(payload);
      });
    }

    /**
     * Set up the locus info recording update listener
     * update recording value for the meeting
     * notifies consumer with:
     *  meeting:recording:started
     *  meeting:recording:stopped
     *  meeting:recording:paused
     *  meeting:recording:resumed
     *
     * Set up the locus info meeeting container listener
     * update meetingContainerUrl value for the meeting
     * notifies consumer with:
     *  meeting:meetingContainer:update
     *
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
  }, {
    key: "setupLocusControlsListener",
    value: function setupLocusControlsListener() {
      var _this11 = this;
      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.CONTROLS_RECORDING_UPDATED, function (_ref5) {
        var state = _ref5.state,
          modifiedBy = _ref5.modifiedBy,
          lastModified = _ref5.lastModified;
        var event;
        switch (state) {
          case _constants.RECORDING_STATE.RECORDING:
            event = _constants.EVENT_TRIGGERS.MEETING_STARTED_RECORDING;
            break;
          case _constants.RECORDING_STATE.IDLE:
            event = _constants.EVENT_TRIGGERS.MEETING_STOPPED_RECORDING;
            break;
          case _constants.RECORDING_STATE.PAUSED:
            event = _constants.EVENT_TRIGGERS.MEETING_PAUSED_RECORDING;
            break;
          case _constants.RECORDING_STATE.RESUMED:
            event = _constants.EVENT_TRIGGERS.MEETING_RESUMED_RECORDING;
            break;
          default:
            event = null;
            break;
        }

        // `RESUMED` state should be converted to `RECORDING` after triggering the event
        _this11.recording = {
          state: state === _constants.RECORDING_STATE.RESUMED ? _constants.RECORDING_STATE.RECORDING : state,
          modifiedBy: modifiedBy,
          lastModified: lastModified
        };
        _triggerProxy.default.trigger(_this11, {
          file: 'meeting/index',
          function: 'setupLocusControlsListener'
        }, event, _this11.recording);
      });
      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.CONTROLS_MEETING_CONTAINER_UPDATED, function (_ref6) {
        var meetingContainerUrl = _ref6.meetingContainerUrl;
        _triggerProxy.default.trigger(_this11, {
          file: 'meeting/index',
          function: 'setupLocusControlsListener'
        }, _constants.EVENT_TRIGGERS.MEETING_MEETING_CONTAINER_UPDATE, {
          meetingContainerUrl: meetingContainerUrl
        });
      });
      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.CONTROLS_MEETING_TRANSCRIBE_UPDATED, function (_ref7) {
        var caption = _ref7.caption,
          transcribing = _ref7.transcribing;
        // @ts-ignore - config coming from registerPlugin
        if (transcribing && !_this11.transcription && _this11.config.receiveTranscription) {
          _this11.startTranscription();
        } else if (!transcribing && _this11.transcription) {
          _triggerProxy.default.trigger(_this11, {
            file: 'meeting/index',
            function: 'setupLocusControlsListener'
          }, _constants.EVENT_TRIGGERS.MEETING_STOPPED_RECEIVING_TRANSCRIPTION, {
            caption: caption,
            transcribing: transcribing
          });
        }
      });
      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.CONTROLS_ENTRY_EXIT_TONE_UPDATED, function (_ref8) {
        var entryExitTone = _ref8.entryExitTone;
        _triggerProxy.default.trigger(_this11, {
          file: 'meeting/index',
          function: 'setupLocusControlsListener'
        }, _constants.EVENT_TRIGGERS.MEETING_ENTRY_EXIT_TONE_UPDATE, {
          entryExitTone: entryExitTone
        });
      });
    }

    /**
     * Set up the locus info media shares listener
     * update content and whiteboard sharing id value for members, and updates the member
     * notifies consumer with members:content:update {activeContentSharingId, endedContentSharingId}
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
  }, {
    key: "setUpLocusMediaSharesListener",
    value: function setUpLocusMediaSharesListener() {
      var _this12 = this;
      // Will get triggered on local and remote share
      this.locusInfo.on(_constants.EVENTS.LOCUS_INFO_UPDATE_MEDIA_SHARES, function (payload) {
        var _payload$previous, _payload$previous2;
        var _payload$current = payload.current,
          contentShare = _payload$current.content,
          whiteboardShare = _payload$current.whiteboard;
        var previousContentShare = (_payload$previous = payload.previous) === null || _payload$previous === void 0 ? void 0 : _payload$previous.content;
        var previousWhiteboardShare = (_payload$previous2 = payload.previous) === null || _payload$previous2 === void 0 ? void 0 : _payload$previous2.whiteboard;
        if (contentShare.beneficiaryId === (previousContentShare === null || previousContentShare === void 0 ? void 0 : previousContentShare.beneficiaryId) && contentShare.disposition === (previousContentShare === null || previousContentShare === void 0 ? void 0 : previousContentShare.disposition) && whiteboardShare.beneficiaryId === (previousWhiteboardShare === null || previousWhiteboardShare === void 0 ? void 0 : previousWhiteboardShare.beneficiaryId) && whiteboardShare.disposition === (previousWhiteboardShare === null || previousWhiteboardShare === void 0 ? void 0 : previousWhiteboardShare.disposition) && whiteboardShare.resourceUrl === (previousWhiteboardShare === null || previousWhiteboardShare === void 0 ? void 0 : previousWhiteboardShare.resourceUrl)) {
          // nothing changed, so ignore
          // (this happens when we steal presentation from remote)
          return;
        }
        var newShareStatus = _this12.shareStatus;

        // REMOTE - check if remote started sharing
        if (_this12.selfId !== contentShare.beneficiaryId && contentShare.disposition === _constants.FLOOR_ACTION.GRANTED) {
          // CONTENT - sharing content remote
          newShareStatus = _constants.SHARE_STATUS.REMOTE_SHARE_ACTIVE;
        }
        // LOCAL - check if we started sharing content
        else if (_this12.selfId === contentShare.beneficiaryId && contentShare.disposition === _constants.FLOOR_ACTION.GRANTED) {
          var _this12$mediaProperti;
          if (((_this12$mediaProperti = _this12.mediaProperties.shareTrack) === null || _this12$mediaProperti === void 0 ? void 0 : _this12$mediaProperti.readyState) === 'ended') {
            _this12.stopShare({
              skipSignalingCheck: true
            }).catch(function (error) {
              _loggerProxy.default.logger.log('Meeting:index#setUpLocusMediaSharesListener --> Error stopping share: ', error);
            });
          } else {
            // CONTENT - sharing content local
            newShareStatus = _constants.SHARE_STATUS.LOCAL_SHARE_ACTIVE;
          }
        }
        // If we did not hit the cases above, no one is sharng content, so we check if we are sharing whiteboard
        // There is no concept of local/remote share for whiteboard
        // It does not matter who requested to share the whiteboard, everyone gets the same view
        else if (whiteboardShare.disposition === _constants.FLOOR_ACTION.GRANTED) {
          // WHITEBOARD - sharing whiteboard
          newShareStatus = _constants.SHARE_STATUS.WHITEBOARD_SHARE_ACTIVE;
        }
        // or if content share is either released or null and whiteboard share is either released or null, no one is sharing
        else if ((previousContentShare && contentShare.disposition === _constants.FLOOR_ACTION.RELEASED || contentShare.disposition === null) && (previousWhiteboardShare && whiteboardShare.disposition === _constants.FLOOR_ACTION.RELEASED || whiteboardShare.disposition === null)) {
          newShareStatus = _constants.SHARE_STATUS.NO_SHARE;
        }
        if (newShareStatus !== _this12.shareStatus) {
          var oldShareStatus = _this12.shareStatus;

          // update our state before we send out any notifications
          _this12.shareStatus = newShareStatus;

          // send out "stop" notifications for the old state
          switch (oldShareStatus) {
            case _constants.SHARE_STATUS.REMOTE_SHARE_ACTIVE:
              _triggerProxy.default.trigger(_this12, {
                file: 'meetings/index',
                function: 'remoteShare'
              }, _constants.EVENT_TRIGGERS.MEETING_STOPPED_SHARING_REMOTE);
              break;
            case _constants.SHARE_STATUS.LOCAL_SHARE_ACTIVE:
              _triggerProxy.default.trigger(_this12, {
                file: 'meeting/index',
                function: 'stopFloorRequest'
              }, _constants.EVENT_TRIGGERS.MEETING_STOPPED_SHARING_LOCAL, {
                reason: _constants.SHARE_STOPPED_REASON.SELF_STOPPED
              });
              break;
            case _constants.SHARE_STATUS.WHITEBOARD_SHARE_ACTIVE:
              _triggerProxy.default.trigger(_this12, {
                file: 'meeting/index',
                function: 'stopWhiteboardShare'
              }, _constants.EVENT_TRIGGERS.MEETING_STOPPED_SHARING_WHITEBOARD);
              break;
            case _constants.SHARE_STATUS.NO_SHARE:
              // nothing to do
              break;
            default:
              break;
          }

          // send "start" notifications for the new state
          switch (newShareStatus) {
            case _constants.SHARE_STATUS.REMOTE_SHARE_ACTIVE:
              {
                var _this12$mediaProperti2;
                var sendStartedSharingRemote = function sendStartedSharingRemote() {
                  _triggerProxy.default.trigger(_this12, {
                    file: 'meetings/index',
                    function: 'remoteShare'
                  }, _constants.EVENT_TRIGGERS.MEETING_STARTED_SHARING_REMOTE, {
                    memberId: contentShare.beneficiaryId
                  });
                };

                // if a remote participant is stealing the presentation from us
                if (!((_this12$mediaProperti2 = _this12.mediaProperties.mediaDirection) !== null && _this12$mediaProperti2 !== void 0 && _this12$mediaProperti2.sendShare) || oldShareStatus === _constants.SHARE_STATUS.WHITEBOARD_SHARE_ACTIVE) {
                  sendStartedSharingRemote();
                } else {
                  _this12.updateShare({
                    sendShare: false,
                    receiveShare: _this12.mediaProperties.mediaDirection.receiveShare
                  }).finally(function () {
                    sendStartedSharingRemote();
                  });
                }
                break;
              }
            case _constants.SHARE_STATUS.LOCAL_SHARE_ACTIVE:
              _triggerProxy.default.trigger(_this12, {
                file: 'meeting/index',
                function: 'share'
              }, _constants.EVENT_TRIGGERS.MEETING_STARTED_SHARING_LOCAL);
              _metrics.default.postEvent({
                event: _config.eventType.LOCAL_SHARE_FLOOR_GRANTED,
                meeting: _this12
              });
              break;
            case _constants.SHARE_STATUS.WHITEBOARD_SHARE_ACTIVE:
              _triggerProxy.default.trigger(_this12, {
                file: 'meeting/index',
                function: 'startWhiteboardShare'
              }, _constants.EVENT_TRIGGERS.MEETING_STARTED_SHARING_WHITEBOARD, {
                resourceUrl: whiteboardShare.resourceUrl,
                memberId: whiteboardShare.beneficiaryId
              });
              _metrics.default.postEvent({
                event: _config.eventType.WHITEBOARD_SHARE_FLOOR_GRANTED,
                meeting: _this12
              });
              break;
            case _constants.SHARE_STATUS.NO_SHARE:
              // nothing to do
              break;
            default:
              break;
          }
          _this12.members.locusMediaSharesUpdate(payload);
        } else if (newShareStatus === _constants.SHARE_STATUS.REMOTE_SHARE_ACTIVE) {
          // if we got here, then some remote participant has stolen
          // the presentation from another remote participant
          _triggerProxy.default.trigger(_this12, {
            file: 'meetings/index',
            function: 'remoteShare'
          }, _constants.EVENT_TRIGGERS.MEETING_STARTED_SHARING_REMOTE, {
            memberId: contentShare.beneficiaryId
          });
          _this12.members.locusMediaSharesUpdate(payload);
        } else if (newShareStatus === _constants.SHARE_STATUS.WHITEBOARD_SHARE_ACTIVE) {
          // if we got here, then some remote participant has stolen
          // the presentation from another remote participant
          _triggerProxy.default.trigger(_this12, {
            file: 'meeting/index',
            function: 'startWhiteboardShare'
          }, _constants.EVENT_TRIGGERS.MEETING_STARTED_SHARING_WHITEBOARD, {
            resourceUrl: whiteboardShare.resourceUrl,
            memberId: whiteboardShare.beneficiaryId
          });
          _metrics.default.postEvent({
            event: _config.eventType.WHITEBOARD_SHARE_FLOOR_GRANTED,
            meeting: _this12
          });
          _this12.members.locusMediaSharesUpdate(payload);
        }
      });
    }

    /**
     * Set up the locus info url listener
     * update locus_url value for members
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
  }, {
    key: "setUpLocusUrlListener",
    value: function setUpLocusUrlListener() {
      var _this13 = this;
      this.locusInfo.on(_constants.EVENTS.LOCUS_INFO_UPDATE_URL, function (payload) {
        var _this13$locusUrl;
        _this13.members.locusUrlUpdate(payload);
        _this13.locusUrl = payload;
        _this13.locusId = (_this13$locusUrl = _this13.locusUrl) === null || _this13$locusUrl === void 0 ? void 0 : _this13$locusUrl.split('/').pop();
        _this13.recordingController.setLocusUrl(_this13.locusUrl);
        _this13.controlsOptionsManager.setLocusUrl(_this13.locusUrl);
      });
    }

    /**
     * Set up the locus info service link listener
     * update the locusInfo for recording controller
     * does not currently re-emit the event as it's internal only
     * payload is unused
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
  }, {
    key: "setUpLocusServicesListener",
    value: function setUpLocusServicesListener() {
      var _this14 = this;
      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.LINKS_SERVICES, function (payload) {
        var _payload$services, _payload$services$rec, _this14$locusInfo, _this14$locusInfo$ful;
        _this14.recordingController.setServiceUrl(payload === null || payload === void 0 ? void 0 : (_payload$services = payload.services) === null || _payload$services === void 0 ? void 0 : (_payload$services$rec = _payload$services.record) === null || _payload$services$rec === void 0 ? void 0 : _payload$services$rec.url);
        _this14.recordingController.setSessionId((_this14$locusInfo = _this14.locusInfo) === null || _this14$locusInfo === void 0 ? void 0 : (_this14$locusInfo$ful = _this14$locusInfo.fullState) === null || _this14$locusInfo$ful === void 0 ? void 0 : _this14$locusInfo$ful.sessionId);
      });
    }

    /**
     * Set up the locus info meeting info listener
     * @returns {undefined}
     * @private
     * @memberof meeting
     */
  }, {
    key: "setUpLocusInfoMeetingInfoListener",
    value: function setUpLocusInfoMeetingInfoListener() {
      var _this15 = this;
      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.MEETING_LOCKED, function (payload) {
        if (payload) {
          _triggerProxy.default.trigger(_this15, {
            file: 'meeting/index',
            function: 'setUpLocusInfoMeetingInfoListener'
          }, _constants.EVENT_TRIGGERS.MEETING_LOCKED, {
            payload: payload
          });
        }
      });
      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.MEETING_UNLOCKED, function (payload) {
        if (payload) {
          _triggerProxy.default.trigger(_this15, {
            file: 'meeting/index',
            function: 'setUpLocusInfoMeetingInfoListener'
          }, _constants.EVENT_TRIGGERS.MEETING_UNLOCKED, {
            payload: payload
          });
        }
      });
      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.MEETING_INFO_UPDATED, function (payload) {
        if (payload && payload.info) {
          var changed = _this15.inMeetingActions.set({
            canInviteNewParticipants: _util.default.canInviteNewParticipants(payload.info.userDisplayHints),
            canAdmitParticipant: _util.default.canAdmitParticipant(payload.info.userDisplayHints),
            canLock: _util.default.canUserLock(payload.info.userDisplayHints),
            canUnlock: _util.default.canUserUnlock(payload.info.userDisplayHints),
            canSetDisallowUnmute: _util3.default.canSetDisallowUnmute(payload.info.userDisplayHints),
            canUnsetDisallowUnmute: _util3.default.canUnsetDisallowUnmute(payload.info.userDisplayHints),
            canSetMuteOnEntry: _util3.default.canSetMuteOnEntry(payload.info.userDisplayHints),
            canUnsetMuteOnEntry: _util3.default.canUnsetMuteOnEntry(payload.info.userDisplayHints),
            canStartRecording: _util2.default.canUserStart(payload.info.userDisplayHints),
            canStopRecording: _util2.default.canUserStop(payload.info.userDisplayHints),
            canPauseRecording: _util2.default.canUserPause(payload.info.userDisplayHints),
            canResumeRecording: _util2.default.canUserResume(payload.info.userDisplayHints),
            canRaiseHand: _util.default.canUserRaiseHand(payload.info.userDisplayHints),
            canLowerAllHands: _util.default.canUserLowerAllHands(payload.info.userDisplayHints),
            canLowerSomeoneElsesHand: _util.default.canUserLowerSomeoneElsesHand(payload.info.userDisplayHints),
            bothLeaveAndEndMeetingAvailable: _util.default.bothLeaveAndEndMeetingAvailable(payload.info.userDisplayHints),
            canEnableClosedCaption: _util.default.canEnableClosedCaption(payload.info.userDisplayHints),
            canStartTranscribing: _util.default.canStartTranscribing(payload.info.userDisplayHints),
            canStopTranscribing: _util.default.canStopTranscribing(payload.info.userDisplayHints),
            isClosedCaptionActive: _util.default.isClosedCaptionActive(payload.info.userDisplayHints),
            isWebexAssistantActive: _util.default.isWebexAssistantActive(payload.info.userDisplayHints),
            canViewCaptionPanel: _util.default.canViewCaptionPanel(payload.info.userDisplayHints),
            isRealTimeTranslationEnabled: _util.default.isRealTimeTranslationEnabled(payload.info.userDisplayHints),
            canSelectSpokenLanguages: _util.default.canSelectSpokenLanguages(payload.info.userDisplayHints),
            waitingForOthersToJoin: _util.default.waitingForOthersToJoin(payload.info.userDisplayHints)
          });
          _this15.recordingController.setDisplayHints(payload.info.userDisplayHints);
          _this15.controlsOptionsManager.setDisplayHints(payload.info.userDisplayHints);
          if (changed) {
            _triggerProxy.default.trigger(_this15, {
              file: 'meeting/index',
              function: 'setUpLocusInfoMeetingInfoListener'
            }, _constants.EVENT_TRIGGERS.MEETING_ACTIONS_UPDATE, _this15.inMeetingActions.get());
          }
        }
      });
    }

    /**
     * Set up the locus info embedded apps listener
     * @returns {undefined}
     * @private
     * @memberof meeting
     */
  }, {
    key: "setUpLocusEmbeddedAppsListener",
    value: function setUpLocusEmbeddedAppsListener() {
      var _this16 = this;
      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.EMBEDDED_APPS_UPDATED, function (embeddedApps) {
        if (embeddedApps) {
          _triggerProxy.default.trigger(_this16, {
            file: 'meeting/index',
            function: 'setUpLocusEmbeddedAppsListener'
          }, _constants.EVENT_TRIGGERS.MEETING_EMBEDDED_APPS_UPDATE, embeddedApps);
        }
      });
    }

    /**
     * Internal function to listen to the self object changes
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
  }, {
    key: "setUpLocusInfoSelfListener",
    value: function setUpLocusInfoSelfListener() {
      var _this17 = this;
      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.LOCAL_UNMUTE_REQUIRED, function (payload) {
        if (_this17.audio) {
          _this17.audio.handleServerLocalUnmuteRequired(_this17);
          _triggerProxy.default.trigger(_this17, {
            file: 'meeting/index',
            function: 'setUpLocusInfoSelfListener'
          }, _constants.EVENT_TRIGGERS.MEETING_SELF_UNMUTED_BY_OTHERS, {
            payload: payload
          });
        }
      });
      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.SELF_REMOTE_MUTE_STATUS_UPDATED, function (payload) {
        if (payload) {
          var _this17$audio;
          if (_this17.audio) {
            _this17.audio.handleServerRemoteMuteUpdate(payload.muted, payload.unmuteAllowed);
          }
          // with "mute on entry" server will send us remote mute even if we don't have media configured,
          // so if being muted by others, always send the notification,
          // but if being unmuted, only send it if we are also locally unmuted
          if (payload.muted || !((_this17$audio = _this17.audio) !== null && _this17$audio !== void 0 && _this17$audio.isMuted())) {
            _triggerProxy.default.trigger(_this17, {
              file: 'meeting/index',
              function: 'setUpLocusInfoSelfListener'
            }, payload.muted ? _constants.EVENT_TRIGGERS.MEETING_SELF_MUTED_BY_OTHERS : _constants.EVENT_TRIGGERS.MEETING_SELF_UNMUTED_BY_OTHERS, {
              payload: payload
            });
          }
        }
      });
      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.LOCAL_UNMUTE_REQUESTED, function (payload) {
        _triggerProxy.default.trigger(_this17, {
          file: 'meeting/index',
          function: 'setUpLocusInfoSelfListener'
        }, _constants.EVENT_TRIGGERS.MEETING_SELF_REQUESTED_TO_UNMUTE, {
          payload: payload
        });
      });
      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.SELF_UNADMITTED_GUEST, function (payload) {
        if (payload) {
          _this17.startKeepAlive();
          _triggerProxy.default.trigger(_this17, {
            file: 'meeting/index',
            function: 'setUpLocusInfoSelfListener'
          }, _constants.EVENT_TRIGGERS.MEETING_SELF_LOBBY_WAITING, {
            payload: payload
          });
          _metrics.default.postEvent({
            event: _config.eventType.LOBBY_ENTERED,
            meeting: _this17
          });
        }
      });
      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.SELF_ADMITTED_GUEST, /*#__PURE__*/function () {
        var _ref9 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(payload) {
          return _regenerator.default.wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                _this17.stopKeepAlive();
                // @ts-ignore
                if (!(!_this17.transcription && (_this17.config.receiveTranscription || _this17.receiveTranscription))) {
                  _context2.next = 6;
                  break;
                }
                if (!_this17.isTranscriptionSupported()) {
                  _context2.next = 6;
                  break;
                }
                _context2.next = 5;
                return _this17.startTranscription();
              case 5:
                _loggerProxy.default.logger.info('Meeting:index#setUpLocusInfoSelfListener --> enabled to receive transcription for guest user!');
              case 6:
                if (payload) {
                  _triggerProxy.default.trigger(_this17, {
                    file: 'meeting/index',
                    function: 'setUpLocusInfoSelfListener'
                  }, _constants.EVENT_TRIGGERS.MEETING_SELF_GUEST_ADMITTED, {
                    payload: payload
                  });
                  _metrics.default.postEvent({
                    event: _config.eventType.LOBBY_EXITED,
                    meeting: _this17
                  });
                }
              case 7:
              case "end":
                return _context2.stop();
            }
          }, _callee2);
        }));
        return function (_x2) {
          return _ref9.apply(this, arguments);
        };
      }());

      // @ts-ignore - check if MEDIA_INACTIVITY exists
      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.MEDIA_INACTIVITY, function () {
        _metrics.default.sendBehavioralMetric(_constants2.default.MEETING_MEDIA_INACTIVE, {
          correlation_id: _this17.correlationId,
          locus_id: _this17.locusId
        });
        _this17.reconnect();
      });

      // There is two stats for mute one is the actual media being sent or received
      // The second on is if the audio is muted, we need to tell the statsAnalyzer when
      // the audio is muted or the user is not willing to send media
      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.MEDIA_STATUS_CHANGE, function (status) {
        if (_this17.statsAnalyzer) {
          var _this17$mediaProperti, _this17$audio2, _this17$mediaProperti2, _this17$video, _this17$mediaProperti3, _this17$mediaProperti4, _this17$mediaProperti5, _this17$mediaProperti6;
          _this17.statsAnalyzer.updateMediaStatus({
            actual: status,
            expected: {
              // We need to check what should be the actual direction of media
              sendAudio: ((_this17$mediaProperti = _this17.mediaProperties.mediaDirection) === null || _this17$mediaProperti === void 0 ? void 0 : _this17$mediaProperti.sendAudio) && !((_this17$audio2 = _this17.audio) !== null && _this17$audio2 !== void 0 && _this17$audio2.isMuted()),
              sendVideo: ((_this17$mediaProperti2 = _this17.mediaProperties.mediaDirection) === null || _this17$mediaProperti2 === void 0 ? void 0 : _this17$mediaProperti2.sendVideo) && !((_this17$video = _this17.video) !== null && _this17$video !== void 0 && _this17$video.isMuted()),
              sendShare: (_this17$mediaProperti3 = _this17.mediaProperties.mediaDirection) === null || _this17$mediaProperti3 === void 0 ? void 0 : _this17$mediaProperti3.sendShare,
              receiveAudio: (_this17$mediaProperti4 = _this17.mediaProperties.mediaDirection) === null || _this17$mediaProperti4 === void 0 ? void 0 : _this17$mediaProperti4.receiveAudio,
              receiveVideo: (_this17$mediaProperti5 = _this17.mediaProperties.mediaDirection) === null || _this17$mediaProperti5 === void 0 ? void 0 : _this17$mediaProperti5.receiveVideo,
              receiveShare: (_this17$mediaProperti6 = _this17.mediaProperties.mediaDirection) === null || _this17$mediaProperti6 === void 0 ? void 0 : _this17$mediaProperti6.receiveShare
            }
          });
        }
      });
      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.SELF_CANNOT_VIEW_PARTICIPANT_LIST_CHANGE, function (payload) {
        _triggerProxy.default.trigger(_this17, {
          file: 'meeting/index',
          function: 'setUpLocusInfoSelfListener'
        }, _constants.EVENT_TRIGGERS.MEETING_SELF_CANNOT_VIEW_PARTICIPANT_LIST, {
          payload: payload
        });
      });
      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.SELF_IS_SHARING_BLOCKED_CHANGE, function (payload) {
        _triggerProxy.default.trigger(_this17, {
          file: 'meeting/index',
          function: 'setUpLocusInfoSelfListener'
        }, _constants.EVENT_TRIGGERS.MEETING_SELF_IS_SHARING_BLOCKED, {
          payload: payload
        });
      });
    }

    /**
     * Add LocusInfo nested object listeners (from child to parent)
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
  }, {
    key: "setUpLocusInfoMeetingListener",
    value: function setUpLocusInfoMeetingListener() {
      var _this18 = this;
      this.locusInfo.on(_constants.EVENTS.REMOTE_RESPONSE, function (payload) {
        _this18.meetingFiniteStateMachine.remote(payload);
        if (payload.remoteDeclined) {
          _this18.leave({
            reason: payload.reason
          }).then(function () {
            _loggerProxy.default.logger.info('Meeting:index#setUpLocusInfoMeetingListener --> REMOTE_RESPONSE. Attempting to leave meeting.');
          }).catch(function (error) {
            // @ts-ignore
            _loggerProxy.default.logger.error("Meeting:index#setUpLocusInfoMeetingListener --> REMOTE_RESPONSE. Issue with leave for meeting, meeting still in collection: ".concat(_this18, ", error: ").concat(error));
          });
        }
      });
      this.locusInfo.on(_constants.EVENTS.DESTROY_MEETING, function (payload) {
        // if self state is NOT left

        // TODO: Handle sharing and wireless sharing when meeting end
        if (_this18.wirelessShare) {
          if (_this18.mediaProperties.shareTrack) {
            _this18.mediaProperties.shareTrack.onended = null;
            _this18.mediaProperties.shareTrack.stop();
          }
        }
        // when multiple WEB deviceType join with same user
        // and some of the devices are joined and some are left
        // when your own device is still connected you want to leave and destroy
        // else you want to just destroy
        // this looks odd because when it leaves it should destroy, but we get a
        // leave response and we should destroy it on the next event loop
        // the leave response gets parsed and we decide if we want to destroy the meeting
        // the first time we just leave it, the second time it comes it destroys it from the collection
        if (payload.shouldLeave) {
          // TODO:  We should do cleaning of meeting object if the shouldLeave: false because there might be meeting object which we are not cleaning

          _this18.leave({
            reason: payload.reason
          }).then(function () {
            _loggerProxy.default.logger.warn('Meeting:index#setUpLocusInfoMeetingListener --> DESTROY_MEETING. The meeting has been left, but has not been destroyed, you should see a later event for leave.');
          }).catch(function (error) {
            // @ts-ignore
            _loggerProxy.default.logger.error("Meeting:index#setUpLocusInfoMeetingListener --> DESTROY_MEETING. Issue with leave for meeting, meeting still in collection: ".concat(_this18, ", error: ").concat(error));
          });
        } else {
          _loggerProxy.default.logger.info('Meeting:index#setUpLocusInfoMeetingListener --> MEETING_REMOVED_REASON', payload.reason);
          _util.default.cleanUp(_this18);
          _triggerProxy.default.trigger(_this18, {
            file: 'meeting/index',
            function: 'setUpLocusInfoMeetingListener'
          }, _constants.EVENTS.DESTROY_MEETING, {
            reason: payload.reason,
            meetingId: _this18.id
          });
        }
      });
    }

    /**
     * Set meeting values rather than events
     * @param {Object} object
     * @returns {undefined}
     * @private
     * @memberof Meeting
     * // TODO: is this function necessary?
     */
  }, {
    key: "updateMeetingObject",
    value: function updateMeetingObject(object) {
      var _this19 = this;
      // Validate if these are valid meeting object property
      // TODO: add a check to make sure the value passed in the constructor
      // is not changed by any delta event
      if (object && (0, _keys.default)(object).length) {
        (0, _keys.default)(object).forEach(function (key) {
          _this19[key] = object[key];
        });
      }
    }

    /**
     * Invite a guest to the call that isn't normally part of this call
     * @param {Object} invitee
     * @param {String} invitee.emailAddress
     * @param {String} invitee.email
     * @param {String} invitee.phoneNumber
     * @param {Boolean} [alertIfActive]
     * @returns {Promise} see #members.addMember
     * @public
     * @memberof Meeting
     */
  }, {
    key: "invite",
    value: function invite(invitee) {
      var alertIfActive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      return this.members.addMember(invitee, alertIfActive);
    }

    /**
     * Cancel an outgoing phone call invitation made during a meeting
     * @param {Object} invitee
     * @param {String} invitee.phoneNumber
     * @returns {Promise} see #members.cancelPhoneInvite
     * @public
     * @memberof Meeting
     */
  }, {
    key: "cancelPhoneInvite",
    value: function cancelPhoneInvite(invitee) {
      return this.members.cancelPhoneInvite(invitee);
    }

    /**
     * Admit the guest(s) to the call once they are waiting
     * @param {Array} memberIds
     * @returns {Promise} see #members.admitMembers
     * @public
     * @memberof Meeting
     */
  }, {
    key: "admit",
    value: function admit(memberIds) {
      return this.members.admitMembers(memberIds);
    }

    /**
     * Remove the member from the meeting, boot them
     * @param {String} memberId
     * @returns {Promise} see #members.removeMember
     * @public
     * @memberof Meeting
     */
  }, {
    key: "remove",
    value: function remove(memberId) {
      return this.members.removeMember(memberId);
    }

    /**
     * Mute another member from the meeting
     * @param {String} memberId
     * @param {Boolean} mute
     * @returns {Promise} see #members.muteMember
     * @public
     * @memberof Meeting
     */
  }, {
    key: "mute",
    value: function mute(memberId) {
      var _mute = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      return this.members.muteMember(memberId, _mute);
    }

    /**
     * Transfer the moderator role to another eligible member
     * @param {String} memberId
     * @param {Boolean} moderator
     * @returns {Promise} see #members.transferHostToMember
     * @public
     * @memberof Meeting
     */
  }, {
    key: "transfer",
    value: function transfer(memberId) {
      var moderator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      return this.members.transferHostToMember(memberId, moderator);
    }

    /**
     * Reference to the Members object
     * @returns {Members}
     * @public
     * @memberof Meeting
     */
  }, {
    key: "getMembers",
    value: function getMembers() {
      return this.members;
    }

    /**
     * Truthy when a meeting has an audio connection established
     * @returns {Boolean}  true if meeting audio is connected otherwise false
     * @public
     * @memberof Meeting
     */
  }, {
    key: "isAudioConnected",
    value: function isAudioConnected() {
      return !!this.audio;
    }

    /**
     * Convenience function to tell whether a meeting is muted
     * @returns {Boolean} if meeting audio muted or not
     * @public
     * @memberof Meeting
     */
  }, {
    key: "isAudioMuted",
    value: function isAudioMuted() {
      return this.audio && this.audio.isMuted();
    }

    /**
     * Convenience function to tell if the end user last changed the audio state
     * @returns {Boolean} if audio was manipulated by the end user
     * @public
     * @memberof Meeting
     */
  }, {
    key: "isAudioSelf",
    value: function isAudioSelf() {
      return this.audio && this.audio.isSelf();
    }

    /**
     * Truthy when a meeting has a video connection established
     * @returns {Boolean} true if meeting video connected otherwise false
     * @public
     * @memberof Meeting
     */
  }, {
    key: "isVideoConnected",
    value: function isVideoConnected() {
      return !!this.video;
    }

    /**
     * Convenience function to tell whether video is muted
     * @returns {Boolean} if meeting video is muted or not
     * @public
     * @memberof Meeting
     */
  }, {
    key: "isVideoMuted",
    value: function isVideoMuted() {
      return this.video && this.video.isMuted();
    }

    /**
     * Convenience function to tell whether the end user changed the video state
     * @returns {Boolean} if meeting video is muted or not
     * @public
     * @memberof Meeting
     */
  }, {
    key: "isVideoSelf",
    value: function isVideoSelf() {
      return this.video && this.video.isSelf();
    }

    /**
     * Sets the meeting info on the class instance
     * @param {Object} meetingInfo
     * @param {Object} meetingInfo.body
     * @param {String} meetingInfo.body.conversationUrl
     * @param {String} meetingInfo.body.locusUrl
     * @param {String} meetingInfo.body.sipUri
     * @param {Object} meetingInfo.body.owner
     * @param {Object | String} destination locus object with meeting data or destination string (sip url, meeting link, etc)
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
  }, {
    key: "parseMeetingInfo",
    value: function parseMeetingInfo(meetingInfo) {
      var destination = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var webexMeetingInfo = meetingInfo === null || meetingInfo === void 0 ? void 0 : meetingInfo.body;
      // We try to use as much info from Locus meeting object, stored in destination

      var locusMeetingObject;
      if (destination) {
        locusMeetingObject = (0, _typeof2.default)(destination) === 'object' ? destination : undefined;
      }

      // MeetingInfo will be undefined for 1:1 calls
      if (locusMeetingObject || webexMeetingInfo && !(meetingInfo !== null && meetingInfo !== void 0 && meetingInfo.errors && (meetingInfo === null || meetingInfo === void 0 ? void 0 : meetingInfo.errors.length) > 0)) {
        var _locusMeetingObject, _locusMeetingObject2, _locusMeetingObject3, _locusMeetingObject4, _locusMeetingObject6;
        this.conversationUrl = ((_locusMeetingObject = locusMeetingObject) === null || _locusMeetingObject === void 0 ? void 0 : _locusMeetingObject.conversationUrl) || (webexMeetingInfo === null || webexMeetingInfo === void 0 ? void 0 : webexMeetingInfo.conversationUrl) || this.conversationUrl;
        this.locusUrl = ((_locusMeetingObject2 = locusMeetingObject) === null || _locusMeetingObject2 === void 0 ? void 0 : _locusMeetingObject2.url) || (webexMeetingInfo === null || webexMeetingInfo === void 0 ? void 0 : webexMeetingInfo.locusUrl) || this.locusUrl;
        // @ts-ignore - config coming from registerPlugin
        this.setSipUri(
        // @ts-ignore
        this.config.experimental.enableUnifiedMeetings ? ((_locusMeetingObject3 = locusMeetingObject) === null || _locusMeetingObject3 === void 0 ? void 0 : _locusMeetingObject3.info.sipUri) || (webexMeetingInfo === null || webexMeetingInfo === void 0 ? void 0 : webexMeetingInfo.sipUrl) : ((_locusMeetingObject4 = locusMeetingObject) === null || _locusMeetingObject4 === void 0 ? void 0 : _locusMeetingObject4.info.sipUri) || (webexMeetingInfo === null || webexMeetingInfo === void 0 ? void 0 : webexMeetingInfo.sipMeetingUri) || this.sipUri);
        // @ts-ignore - config coming from registerPlugin
        if (this.config.experimental.enableUnifiedMeetings) {
          var _locusMeetingObject5;
          this.meetingNumber = ((_locusMeetingObject5 = locusMeetingObject) === null || _locusMeetingObject5 === void 0 ? void 0 : _locusMeetingObject5.info.webExMeetingId) || (webexMeetingInfo === null || webexMeetingInfo === void 0 ? void 0 : webexMeetingInfo.meetingNumber);
          this.meetingJoinUrl = webexMeetingInfo === null || webexMeetingInfo === void 0 ? void 0 : webexMeetingInfo.meetingJoinUrl;
        }
        this.owner = ((_locusMeetingObject6 = locusMeetingObject) === null || _locusMeetingObject6 === void 0 ? void 0 : _locusMeetingObject6.info.owner) || (webexMeetingInfo === null || webexMeetingInfo === void 0 ? void 0 : webexMeetingInfo.owner) || (webexMeetingInfo === null || webexMeetingInfo === void 0 ? void 0 : webexMeetingInfo.hostId) || this.owner;
        this.permissionToken = webexMeetingInfo === null || webexMeetingInfo === void 0 ? void 0 : webexMeetingInfo.permissionToken;
      }
    }

    /**
     * Sets the first locus info on the class instance
     * @param {Object} locus
     * @param {String} locus.url
     * @param {Array} locus.participants
     * @param {Object} locus.self
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
  }, {
    key: "parseLocus",
    value: function parseLocus(locus) {
      if (locus) {
        this.locusUrl = locus.url;
        // TODO: move this to parse participants module
        this.setLocus(locus);

        // check if we can extract this info from partner
        // Parsing of locus object must be finished at this state
        if (locus.participants && locus.self) {
          this.partner = _util.default.getLocusPartner(locus.participants, locus.self);
        }

        // For webex meeting the sipUrl gets updated in info parser
        if (!this.sipUri && this.partner && this.type === _constants._CALL_) {
          this.setSipUri(this.partner.person.sipUrl || this.partner.person.id);
        }
      }
    }

    /**
     * Sets the sip uri on the class instance
     * uses meeting info as precedence
     * @param {String} sipUri
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
  }, {
    key: "setSipUri",
    value: function setSipUri(sipUri) {
      // This can be tel no, device id or a sip uri, user Id
      this.sipUri = sipUri;
    }

    /**
     * Set the roap seq on the class instance
     * @param {Number} seq
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
  }, {
    key: "setRoapSeq",
    value: function setRoapSeq(seq) {
      if (seq >= 0) {
        this.roapSeq = seq;
      }
    }

    /**
     * Set the locus info the class instance
     * @param {Object} locus
     * @param {Array} locus.mediaConnections
     * @param {String} locus.locusUrl
     * @param {String} locus.locusId
     * @param {String} locus.mediaId
     * @param {Object} locus.host
     * @todo change name to genertic parser
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
  }, {
    key: "setLocus",
    value: function setLocus(locus) {
      var mtgLocus = locus.locus || locus;

      // LocusInfo object saves the locus object
      // this.locus = mtgLocus;
      this.mediaConnections = locus.mediaConnections;
      this.locusUrl = locus.locusUrl || locus.url;
      this.locusId = locus.locusId;
      this.selfId = locus.selfId;
      // @ts-ignore
      this.mediaId = locus.mediaId;
      this.hostId = mtgLocus.host ? mtgLocus.host.id : this.hostId;
      this.locusInfo.initialSetup(mtgLocus);
    }

    /**
     * Sets the remote stream on the class instance and emits and
     * event to developers
     * @param {Object} pc The remote stream peer connection
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */
  }, {
    key: "setRemoteStream",
    value: function setRemoteStream(pc) {
      var _this20 = this;
      if (!pc) {
        return;
      }
      // eslint-disable-next-line no-param-reassign
      pc.ontrack = function (event) {
        // eslint-disable-next-line no-warning-comments
        // TODO: It's possible for media to not be present
        // so we might need to either
        // A) wait until we have media flowing
        // B) trigger a second event when video is flowing
        _loggerProxy.default.logger.log("Meeting:index#setRemoteStream --> ontrack event received for peerConnection: ".concat(event));
        var MEDIA_ID = {
          AUDIO_TRACK: '0',
          VIDEO_TRACK: '1',
          SHARE_TRACK: '2'
        };
        // eslint-disable-next-line @typescript-eslint/no-shadow
        var eventType = null;
        var mediaTrack = event.track;
        var trackMediaID = null;

        // In case of safari some time the transceiver is not present for specific os version
        // sdk tries to determine the transceive using the track id present
        if (event.transceiver && event.transceiver.mid) {
          trackMediaID = event.transceiver.mid;
        } else {
          var _event$target = event.target,
            audioTransceiver = _event$target.audioTransceiver,
            videoTransceiver = _event$target.videoTransceiver,
            shareTransceiver = _event$target.shareTransceiver;

          // audio kind indicates its a audio stream
          if (mediaTrack.id === audioTransceiver.receiver.track.id) {
            trackMediaID = '0';
          } else if (mediaTrack.id === videoTransceiver.receiver.track.id) {
            trackMediaID = '1';
          } else if (mediaTrack.id === shareTransceiver.receiver.track.id) {
            trackMediaID = '2';
          } else {
            trackMediaID = null;
            _metrics.default.sendBehavioralMetric(_constants2.default.MUTE_AUDIO_FAILURE, {
              correlation_id: _this20.correlationId,
              locus_id: _this20.locusUrl.split('/').pop()
            });
          }
        }
        switch (trackMediaID) {
          case MEDIA_ID.AUDIO_TRACK:
            eventType = _constants.EVENT_TYPES.REMOTE_AUDIO;
            _this20.mediaProperties.setRemoteAudioTrack(mediaTrack);
            break;
          case MEDIA_ID.VIDEO_TRACK:
            eventType = _constants.EVENT_TYPES.REMOTE_VIDEO;
            _this20.mediaProperties.setRemoteVideoTrack(mediaTrack);
            break;
          case MEDIA_ID.SHARE_TRACK:
            if (event.track) {
              eventType = _constants.EVENT_TYPES.REMOTE_SHARE;
              _this20.mediaProperties.setRemoteShare(mediaTrack);
            }
            break;
          default:
            {
              _loggerProxy.default.logger.log('Meeting:index#setRemoteStream --> no matching media track id');
            }
        }

        // start stats here the stats are coming null if you dont receive streams

        _this20.statsAnalyzer.startAnalyzer(_this20.mediaProperties.peerConnection);
        if (eventType && mediaTrack) {
          _triggerProxy.default.trigger(_this20, {
            file: 'meeting/index',
            function: 'setRemoteStream:pc.ontrack'
          }, _constants.EVENT_TRIGGERS.MEDIA_READY, {
            type: eventType,
            stream: _util4.default.createMediaStream([mediaTrack])
          });
        }
      };
    }

    /**
     * Upload logs for the current meeting
     * @param {object} options file name and function name
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */
  }, {
    key: "uploadLogs",
    value: function uploadLogs() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        file: 'meeting/index',
        function: 'uploadLogs'
      };
      _triggerProxy.default.trigger(this, options, _constants.EVENTS.REQUEST_UPLOAD_LOGS, this);
    }

    /**
     * Removes remote audio and video stream on the class instance and triggers an event
     * to developers
     * @returns {undefined}
     * @public
     * @memberof Meeting
     * @deprecated after v1.89.3
     */
  }, {
    key: "unsetRemoteStream",
    value: function unsetRemoteStream() {
      _loggerProxy.default.logger.warn('Meeting:index#unsetRemoteStream --> [DEPRECATION WARNING]: unsetRemoteStream has been deprecated after v1.89.3');
      this.mediaProperties.unsetRemoteMedia();
    }

    /**
     * Removes remote audio, video and share tracks from class instance's mediaProperties
     * @returns {undefined}
     */
  }, {
    key: "unsetRemoteTracks",
    value: function unsetRemoteTracks() {
      this.mediaProperties.unsetRemoteTracks();
    }

    /**
     * Removes the remote stream on the class instance and triggers an event
     * to developers
     * @returns {undefined}
     * @public
     * @memberof Meeting
     * @deprecated after v1.89.3
     */
  }, {
    key: "closeRemoteStream",
    value: function closeRemoteStream() {
      _loggerProxy.default.logger.warn('Meeting:index#closeRemoteStream --> [DEPRECATION WARNING]: closeRemoteStream has been deprecated after v1.89.3');
      this.closeRemoteTracks();
    }

    /**
     * Removes the remote tracks on the class instance and triggers an event
     * to developers
     * @returns {undefined}
     * @memberof Meeting
     */
  }, {
    key: "closeRemoteTracks",
    value: function closeRemoteTracks() {
      var _this21 = this;
      var _this$mediaProperties3 = this.mediaProperties,
        remoteAudioTrack = _this$mediaProperties3.remoteAudioTrack,
        remoteVideoTrack = _this$mediaProperties3.remoteVideoTrack,
        remoteShare = _this$mediaProperties3.remoteShare;

      /**
       * Triggers an event to the developer
       * @param {string} mediaType Type of media that was stopped
       * @returns {void}
       * @inner
       */
      // eslint-disable-next-line @typescript-eslint/no-shadow
      var triggerMediaStoppedEvent = function triggerMediaStoppedEvent(mediaType) {
        _triggerProxy.default.trigger(_this21, {
          file: 'meeting/index',
          function: 'closeRemoteTracks'
        }, _constants.EVENT_TRIGGERS.MEDIA_STOPPED, {
          type: mediaType
        });
      };

      /**
       * Stops a media track and emits an event
       * @param {MediaStreamTrack} track Media track to stop
       * @param {string} type Media track type
       * @returns {Promise}
       * @inner
       */
      // eslint-disable-next-line arrow-body-style
      var stopTrack = function stopTrack(track, type) {
        return _media.default.stopTracks(track).then(function () {
          var isTrackStopped = track && track.readyState === _constants.ENDED;
          var isWrongReadyState = track && !isTrackStopped;
          if (isTrackStopped) {
            triggerMediaStoppedEvent(type);
          } else if (isWrongReadyState) {
            _loggerProxy.default.logger.warn("Meeting:index#closeRemoteTracks --> Error: MediaStreamTrack.readyState is ".concat(track.readyState, " for ").concat(type));
          }
        });
      };
      return _promise.default.all([stopTrack(remoteAudioTrack, _constants.EVENT_TYPES.REMOTE_AUDIO), stopTrack(remoteVideoTrack, _constants.EVENT_TYPES.REMOTE_VIDEO), stopTrack(remoteShare, _constants.EVENT_TYPES.REMOTE_SHARE)]);
    }

    /**
     * Emits the 'media:ready' event with a local stream that consists of 1 local audio and 1 local video track
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
  }, {
    key: "sendLocalMediaReadyEvent",
    value: function sendLocalMediaReadyEvent() {
      _triggerProxy.default.trigger(this, {
        file: 'meeting/index',
        function: 'setLocalTracks'
      }, _constants.EVENT_TRIGGERS.MEDIA_READY, {
        type: _constants.EVENT_TYPES.LOCAL,
        stream: _util4.default.createMediaStream([this.mediaProperties.audioTrack, this.mediaProperties.videoTrack])
      });
    }

    /**
     * Sets the local audio track on the class and emits an event to the developer
     * @param {MediaStreamTrack} audioTrack
     * @param {Boolean} emitEvent if true, a media ready event is emitted to the developer
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
  }, {
    key: "setLocalAudioTrack",
    value: function setLocalAudioTrack(audioTrack) {
      var emitEvent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (audioTrack) {
        var settings = audioTrack.getSettings();
        this.mediaProperties.setMediaSettings('audio', {
          echoCancellation: settings.echoCancellation,
          noiseSuppression: settings.noiseSuppression
        });
        _loggerProxy.default.logger.log('Meeting:index#setLocalAudioTrack --> Audio settings.', (0, _stringify.default)(this.mediaProperties.mediaSettings.audio));
        this.mediaProperties.setLocalAudioTrack(audioTrack);
        if (this.audio) this.audio.applyClientStateLocally(this);
      }
      if (emitEvent) {
        this.sendLocalMediaReadyEvent();
      }
    }

    /**
     * Sets the local video track on the class and emits an event to the developer
     * @param {MediaStreamTrack} videoTrack
     * @param {Boolean} emitEvent if true, a media ready event is emitted to the developer
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
  }, {
    key: "setLocalVideoTrack",
    value: function setLocalVideoTrack(videoTrack) {
      var emitEvent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (videoTrack) {
        var _videoTrack$getSettin = videoTrack.getSettings(),
          aspectRatio = _videoTrack$getSettin.aspectRatio,
          frameRate = _videoTrack$getSettin.frameRate,
          height = _videoTrack$getSettin.height,
          width = _videoTrack$getSettin.width,
          deviceId = _videoTrack$getSettin.deviceId;
        var localQualityLevel = this.mediaProperties.localQualityLevel;
        if (Number(localQualityLevel.slice(0, -1)) > height) {
          _loggerProxy.default.logger.warn("Meeting:index#setLocalVideoTrack --> Local video quality of ".concat(localQualityLevel, " not supported,\n         downscaling to highest possible resolution of ").concat(height, "p"));
          this.mediaProperties.setLocalQualityLevel("".concat(height, "p"));
        }
        this.mediaProperties.setLocalVideoTrack(videoTrack);
        if (this.video) this.video.applyClientStateLocally(this);
        this.mediaProperties.setMediaSettings('video', {
          aspectRatio: aspectRatio,
          frameRate: frameRate,
          height: height,
          width: width
        });
        // store and save the selected video input device
        if (deviceId) {
          this.mediaProperties.setVideoDeviceId(deviceId);
        }
        _loggerProxy.default.logger.log('Meeting:index#setLocalVideoTrack --> Video settings.', (0, _stringify.default)(this.mediaProperties.mediaSettings.video));
      }
      if (emitEvent) {
        this.sendLocalMediaReadyEvent();
      }
    }

    /**
     * Sets the local media stream on the class and emits an event to the developer
     * @param {Stream} localStream the local media stream
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */
  }, {
    key: "setLocalTracks",
    value: function setLocalTracks(localStream) {
      if (localStream) {
        var _MeetingUtil$getTrack = _util.default.getTrack(localStream),
          audioTrack = _MeetingUtil$getTrack.audioTrack,
          videoTrack = _MeetingUtil$getTrack.videoTrack;
        this.setLocalAudioTrack(audioTrack, false);
        this.setLocalVideoTrack(videoTrack, false);
        this.sendLocalMediaReadyEvent();
      }
    }

    /**
     * Sets the local media stream on the class and emits an event to the developer
     * @param {MediaStream} localShare the local media stream
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */
  }, {
    key: "setLocalShareTrack",
    value: function setLocalShareTrack(localShare) {
      var _this22 = this;
      var settings = null;
      if (localShare) {
        this.mediaProperties.setLocalShareTrack(_util.default.getTrack(localShare).videoTrack);
        var contentTracks = this.mediaProperties.shareTrack;
        if (contentTracks) {
          settings = contentTracks.getSettings();
          this.mediaProperties.setMediaSettings('screen', {
            aspectRatio: settings.aspectRatio,
            frameRate: settings.frameRate,
            height: settings.height,
            width: settings.width,
            displaySurface: settings.displaySurface,
            cursor: settings.cursor
          });
          _loggerProxy.default.logger.log('Meeting:index#setLocalShareTrack --> Screen settings.', (0, _stringify.default)(this.mediaProperties.mediaSettings.screen));
        }
        contentTracks.onended = function () {
          return _this22.handleShareTrackEnded(localShare);
        };
        _triggerProxy.default.trigger(this, {
          file: 'meeting/index',
          function: 'setLocalShareTrack'
        }, _constants.EVENT_TRIGGERS.MEDIA_READY, {
          type: _constants.EVENT_TYPES.LOCAL_SHARE,
          stream: localShare
        });
      }
    }

    /**
     * Closes the local stream from the class and emits an event to the developer
     * @returns {undefined}
     * @event media:stopped
     * @public
     * @memberof Meeting
     */
  }, {
    key: "closeLocalStream",
    value: function closeLocalStream() {
      var _this23 = this;
      var _this$mediaProperties4 = this.mediaProperties,
        audioTrack = _this$mediaProperties4.audioTrack,
        videoTrack = _this$mediaProperties4.videoTrack;
      return _media.default.stopTracks(audioTrack).then(function () {
        return _media.default.stopTracks(videoTrack);
      }).then(function () {
        var audioStopped = audioTrack && audioTrack.readyState === _constants.ENDED;
        var videoStopped = videoTrack && videoTrack.readyState === _constants.ENDED;

        // triggers event for audio and video stop , sometime either audio or video one of them exists
        if (audioStopped || videoStopped) {
          _triggerProxy.default.trigger(_this23, {
            file: 'meeting/index',
            function: 'closeLocalStream'
          }, _constants.EVENT_TRIGGERS.MEDIA_STOPPED, {
            type: _constants.EVENT_TYPES.LOCAL
          });
        } else if (audioTrack || videoTrack) {
          _loggerProxy.default.logger.warn('Meeting:index#closeLocalStream --> Warning: track might already been ended or unavaliable.');
        }
      });
    }

    /**
     * Closes the local stream from the class and emits an event to the developer
     * @returns {undefined}
     * @event media:stopped
     * @public
     * @memberof Meeting
     */
  }, {
    key: "closeLocalShare",
    value: function closeLocalShare() {
      var _this24 = this;
      var track = this.mediaProperties.shareTrack;
      return _media.default.stopTracks(track).then(function () {
        if (track && track.readyState === _constants.ENDED) {
          _triggerProxy.default.trigger(_this24, {
            file: 'meeting/index',
            function: 'closeLocalShare'
          }, _constants.EVENT_TRIGGERS.MEDIA_STOPPED, {
            type: _constants.EVENT_TYPES.LOCAL_SHARE
          });
        } else if (track) {
          // Track exists but with wrong readyState
          _loggerProxy.default.logger.warn("Meeting:index#closeLocalShare --> Error: MediaStreamTrack.readyState is ".concat(track.readyState, " for localShare"));
        }
      });
    }

    /**
     * Removes the local stream from the class and emits an event to the developer
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */
  }, {
    key: "unsetLocalVideoTrack",
    value: function unsetLocalVideoTrack() {
      this.mediaProperties.unsetLocalVideoTrack();
    }

    /**
     * Removes the local share from the class and emits an event to the developer
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */
  }, {
    key: "unsetLocalShareTrack",
    value: function unsetLocalShareTrack() {
      this.mediaProperties.unsetLocalShareTrack();
    }

    /**
     * sets up listner for mercury event
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */
  }, {
    key: "setMercuryListener",
    value: function setMercuryListener() {
      var _this25 = this;
      // Client will have a socket manager and handle reconnecting to mercury, when we reconnect to mercury
      // if the meeting has active peer connections, it should try to reconnect.
      // @ts-ignore
      this.webex.internal.mercury.on(_constants.ONLINE, function () {
        _loggerProxy.default.logger.info('Meeting:index#setMercuryListener --> Web socket online');

        // Only send restore event when it was disconnected before and for connected later
        if (!_this25.hasWebsocketConnected) {
          _metrics.default.postEvent({
            event: _config.eventType.MERCURY_CONNECTION_RESTORED,
            meeting: _this25
          });
          _metrics.default.sendBehavioralMetric(_constants2.default.MERCURY_CONNECTION_RESTORED, {
            correlation_id: _this25.correlationId
          });
        }
        _this25.hasWebsocketConnected = true;
      });

      // @ts-ignore
      this.webex.internal.mercury.on(_constants.OFFLINE, function () {
        _loggerProxy.default.logger.error('Meeting:index#setMercuryListener --> Web socket offline');
        _metrics.default.postEvent({
          event: _config.eventType.MERCURY_CONNECTION_LOST,
          meeting: _this25
        });
        _metrics.default.sendBehavioralMetric(_constants2.default.MERCURY_CONNECTION_FAILURE, {
          correlation_id: _this25.correlationId
        });
      });
    }

    /**
     * Close the peer connections and remove them from the class. Triggers an event
     * when each is closed.
     * @returns {Promise} returns a resolved promise with an array of closed peer connections
     * @public
     * @memberof Meeting
     */
  }, {
    key: "closePeerConnections",
    value: function closePeerConnections() {
      return _peerConnectionManager.default.close(this.mediaProperties.peerConnection);
    }

    /**
     * Unsets the peer connections on the class
     * warning DO NOT CALL WITHOUT CLOSING PEER CONNECTIONS FIRST
     * @param {PeerConnection} peerConnection
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */
  }, {
    key: "unsetPeerConnections",
    value: function unsetPeerConnections() {
      this.mediaProperties.unsetPeerConnection();
      // @ts-ignore - config coming from registerPlugin
      if (this.config.reconnection.detection) {
        // @ts-ignore
        this.webex.internal.mercury.off(_constants.ONLINE);
      }
    }

    /**
     * Convenience method to set the correlation id for the Meeting
     * @param {String} id correlation id to set on the class
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
  }, {
    key: "setCorrelationId",
    value: function setCorrelationId(id) {
      this.correlationId = id;
    }

    /**
     * Mute the audio for a meeting
     * @returns {Promise} resolves the data from muting audio {mute, self} or rejects if there is no audio set
     * @public
     * @memberof Meeting
     */
  }, {
    key: "muteAudio",
    value: function muteAudio() {
      var _this26 = this;
      if (!_util.default.isUserInJoinedState(this.locusInfo)) {
        return _promise.default.reject(new _webexErrors.UserNotJoinedError());
      }

      // @ts-ignore
      if (!this.mediaId) {
        // Happens when addMedia and mute are triggered in succession
        return _promise.default.reject(new _webexErrors.NoMediaEstablishedYetError());
      }
      if (!this.audio) {
        return _promise.default.reject(new _parameter.default('no audio control associated to the meeting'));
      }
      var LOG_HEADER = 'Meeting:index#muteAudio -->';

      // First, stop sending the local audio media
      return logRequest(this.audio.handleClientRequest(this, true).then(function () {
        _util.default.handleAudioLogging(_this26.mediaProperties.audioTrack);
        _metrics.default.postEvent({
          event: _config.eventType.MUTED,
          meeting: _this26,
          data: {
            trigger: _config.trigger.USER_INTERACTION,
            mediaType: _config.mediaType.AUDIO
          }
        });
      }).catch(function (error) {
        _metrics.default.sendBehavioralMetric(_constants2.default.MUTE_AUDIO_FAILURE, {
          correlation_id: _this26.correlationId,
          locus_id: _this26.locusUrl.split('/').pop(),
          reason: error.message,
          stack: error.stack
        });
        throw error;
      }), {
        header: "".concat(LOG_HEADER, " muting audio"),
        success: "".concat(LOG_HEADER, " muted audio successfully"),
        failure: "".concat(LOG_HEADER, " muting audio failed, ")
      });
    }

    /**
     * Unmute meeting audio
     * @returns {Promise} resolves data from muting audio {mute, self} or rejects if there is no audio set
     * @public
     * @memberof Meeting
     */
  }, {
    key: "unmuteAudio",
    value: function unmuteAudio() {
      var _this27 = this;
      if (!_util.default.isUserInJoinedState(this.locusInfo)) {
        return _promise.default.reject(new _webexErrors.UserNotJoinedError());
      }

      // @ts-ignore
      if (!this.mediaId) {
        // Happens when addMedia and mute are triggered in succession
        return _promise.default.reject(new _webexErrors.NoMediaEstablishedYetError());
      }
      if (!this.audio) {
        return _promise.default.reject(new _parameter.default('no audio control associated to the meeting'));
      }
      var LOG_HEADER = 'Meeting:index#unmuteAudio -->';

      // First, send the control to unmute the participant on the server
      return logRequest(this.audio.handleClientRequest(this, false).then(function () {
        _util.default.handleAudioLogging(_this27.mediaProperties.audioTrack);
        _metrics.default.postEvent({
          event: _config.eventType.UNMUTED,
          meeting: _this27,
          data: {
            trigger: _config.trigger.USER_INTERACTION,
            mediaType: _config.mediaType.AUDIO
          }
        });
      }).catch(function (error) {
        _metrics.default.sendBehavioralMetric(_constants2.default.UNMUTE_AUDIO_FAILURE, {
          correlation_id: _this27.correlationId,
          locus_id: _this27.locusUrl.split('/').pop(),
          reason: error.message,
          stack: error.stack
        });
        throw error;
      }), {
        header: "".concat(LOG_HEADER, " unmuting audio"),
        success: "".concat(LOG_HEADER, " unmuted audio successfully"),
        failure: "".concat(LOG_HEADER, " unmuting audio failed, ")
      });
    }

    /**
     * Mute the video for a meeting
     * @returns {Promise} resolves data from muting video {mute, self} or rejects if there is no video set
     * @public
     * @memberof Meeting
     */
  }, {
    key: "muteVideo",
    value: function muteVideo() {
      var _this28 = this;
      if (!_util.default.isUserInJoinedState(this.locusInfo)) {
        return _promise.default.reject(new _webexErrors.UserNotJoinedError());
      }

      // @ts-ignore
      if (!this.mediaId) {
        // Happens when addMedia and mute are triggered in succession
        return _promise.default.reject(new _webexErrors.NoMediaEstablishedYetError());
      }
      if (!this.video) {
        return _promise.default.reject(new _parameter.default('no video control associated to the meeting'));
      }
      var LOG_HEADER = 'Meeting:index#muteVideo -->';
      return logRequest(this.video.handleClientRequest(this, true).then(function () {
        _util.default.handleVideoLogging(_this28.mediaProperties.videoTrack);
        _metrics.default.postEvent({
          event: _config.eventType.MUTED,
          meeting: _this28,
          data: {
            trigger: _config.trigger.USER_INTERACTION,
            mediaType: _config.mediaType.VIDEO
          }
        });
      }).catch(function (error) {
        _metrics.default.sendBehavioralMetric(_constants2.default.MUTE_VIDEO_FAILURE, {
          correlation_id: _this28.correlationId,
          locus_id: _this28.locusUrl.split('/').pop(),
          reason: error.message,
          stack: error.stack
        });
        throw error;
      }), {
        header: "".concat(LOG_HEADER, " muting video"),
        success: "".concat(LOG_HEADER, " muted video successfully"),
        failure: "".concat(LOG_HEADER, " muting video failed, ")
      });
    }

    /**
     * Unmute meeting video
     * @returns {Promise} resolves data from muting video {mute, self} or rejects if there is no video set
     * @public
     * @memberof Meeting
     */
  }, {
    key: "unmuteVideo",
    value: function unmuteVideo() {
      var _this29 = this;
      if (!_util.default.isUserInJoinedState(this.locusInfo)) {
        return _promise.default.reject(new _webexErrors.UserNotJoinedError());
      }

      // @ts-ignore
      if (!this.mediaId) {
        // Happens when addMedia and mute are triggered in succession
        return _promise.default.reject(new _webexErrors.NoMediaEstablishedYetError());
      }
      if (!this.video) {
        return _promise.default.reject(new _parameter.default('no audio control associated to the meeting'));
      }
      var LOG_HEADER = 'Meeting:index#unmuteVideo -->';
      return logRequest(this.video.handleClientRequest(this, false).then(function () {
        _util.default.handleVideoLogging(_this29.mediaProperties.videoTrack);
        _metrics.default.postEvent({
          event: _config.eventType.UNMUTED,
          meeting: _this29,
          data: {
            trigger: _config.trigger.USER_INTERACTION,
            mediaType: _config.mediaType.VIDEO
          }
        });
      }).catch(function (error) {
        _metrics.default.sendBehavioralMetric(_constants2.default.UNMUTE_VIDEO_FAILURE, {
          correlation_id: _this29.correlationId,
          locus_id: _this29.locusUrl.split('/').pop(),
          reason: error.message,
          stack: error.stack
        });
        throw error;
      }), {
        header: "".concat(LOG_HEADER, " unmuting video"),
        success: "".concat(LOG_HEADER, " unmuted video successfully"),
        failure: "".concat(LOG_HEADER, " unmuting video failed, ")
      });
    }

    /**
     * Shorthand function to join AND set up media
     * @param {Object} options - options to join with media
     * @param {JoinOptions} [options.joinOptions] - see #join()
     * @param {MediaDirection} options.mediaSettings - see #addMedia()
     * @param {AudioVideo} [options.audioVideoOptions] - see #getMediaStreams()
     * @returns {Promise} -- {join: see join(), media: see addMedia(), local: see getMediaStreams()}
     * @public
     * @memberof Meeting
     * @example
     * joinWithMedia({
     *  joinOptions: {resourceId: 'resourceId' },
     *  mediaSettings: {
     *   sendAudio: true,
     *   sendVideo: true,
     *   sendShare: false,
     *   receiveVideo:true,
     *   receiveAudio: true,
     *   receiveShare: true
     * }
     * audioVideoOptions: {
     *   audio: 'audioDeviceId',
     *   video: 'videoDeviceId'
     * }})
     */
  }, {
    key: "joinWithMedia",
    value: function joinWithMedia() {
      var _this30 = this;
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      // TODO: add validations for parameters
      var mediaSettings = options.mediaSettings,
        joinOptions = options.joinOptions,
        audioVideoOptions = options.audioVideoOptions;
      return this.join(joinOptions).then(function (joinResponse) {
        return _this30.getMediaStreams(mediaSettings, audioVideoOptions).then(function (_ref10) {
          var _ref11 = (0, _slicedToArray2.default)(_ref10, 2),
            localStream = _ref11[0],
            localShare = _ref11[1];
          return _this30.addMedia({
            mediaSettings: mediaSettings,
            localShare: localShare,
            localStream: localStream
          }).then(function (mediaResponse) {
            return {
              join: joinResponse,
              media: mediaResponse,
              local: [localStream, localShare]
            };
          });
        });
      }).catch(function (error) {
        _loggerProxy.default.logger.error('Meeting:index#joinWithMedia --> ', error);
        _metrics.default.sendBehavioralMetric(_constants2.default.JOIN_WITH_MEDIA_FAILURE, {
          correlation_id: _this30.correlationId,
          locus_id: _this30.locusUrl.split('/').pop(),
          reason: error.message,
          stack: error.stack
        }, {
          type: error.name
        });
        return _promise.default.reject(error);
      });
    }

    /**
     * Initiates the reconnection of the media in the meeting
     *
     * @param {object} options
     * @returns {Promise} resolves with {reconnect} or errors with {error}
     * @public
     * @memberof Meeting
     */
  }, {
    key: "reconnect",
    value: function reconnect(options) {
      var _this31 = this;
      _loggerProxy.default.logger.log("Meeting:index#reconnect --> attempting to reconnect meeting ".concat(this.id));
      if (!this.reconnectionManager || !this.reconnectionManager.reconnect) {
        return _promise.default.reject(new _parameter.default('Cannot reconnect, ReconnectionManager must first be defined.'));
      }

      // @ts-ignore - currentMediaStatus coming from SelfUtil
      if (!_util.default.isMediaEstablished(this.currentMediaStatus)) {
        return _promise.default.reject(new _parameter.default('Cannot reconnect, Media has not established to reconnect'));
      }
      try {
        _loggerProxy.default.logger.info('Meeting:index#reconnect --> Validating reconnect ability.');
        // @ts-ignore
        this.reconnectionManager.validate();
      } catch (error) {
        // Unable to reconnect this call
        if (error instanceof _reconnectionInProgress.default) {
          _loggerProxy.default.logger.info('Meeting:index#reconnect --> Unable to reconnect, reconnection in progress.');
        } else {
          _loggerProxy.default.logger.log('Meeting:index#reconnect --> Unable to reconnect.', error);
        }
        return _promise.default.resolve();
      }
      _triggerProxy.default.trigger(this, {
        file: 'meeting/index',
        function: 'reconnect'
      }, _constants.EVENT_TRIGGERS.MEETING_RECONNECTION_STARTING);
      return this.reconnectionManager.reconnect(options).then(function () {
        _triggerProxy.default.trigger(_this31, {
          file: 'meeting/index',
          function: 'reconnect'
        }, _constants.EVENT_TRIGGERS.MEETING_RECONNECTION_SUCCESS);
        _loggerProxy.default.logger.log('Meeting:index#reconnect --> Meeting reconnect success');
      }).catch(function (error) {
        _triggerProxy.default.trigger(_this31, {
          file: 'meeting/index',
          function: 'reconnect'
        }, _constants.EVENT_TRIGGERS.MEETING_RECONNECTION_FAILURE, {
          error: new _reconnection.default('Reconnection failure event', error)
        });
        _loggerProxy.default.logger.error('Meeting:index#reconnect --> Meeting reconnect failed', error);
        _metrics.default.sendBehavioralMetric(_constants2.default.MEETING_RECONNECT_FAILURE, {
          correlation_id: _this31.correlationId,
          locus_id: _this31.locusUrl.split('/').pop(),
          reason: error.message,
          stack: error.stack
        });
        _this31.uploadLogs({
          file: 'meeting/index',
          function: 'reconnect'
        });
        return _promise.default.reject(new _reconnection.default('Reconnection failure event', error));
      }).finally(function () {
        _this31.reconnectionManager.reset();
      });
    }

    /**
     * Check if the meeting supports the Webex Assistant feature
     * @returns {boolean}
     * @throws TranscriptionNotSupportedError
     */
  }, {
    key: "isTranscriptionSupported",
    value: function isTranscriptionSupported() {
      var _this$locusInfo$contr;
      if ((_this$locusInfo$contr = this.locusInfo.controls.transcribe) !== null && _this$locusInfo$contr !== void 0 && _this$locusInfo$contr.transcribing) {
        return true;
      }
      _loggerProxy.default.logger.error('Meeting:index#isTranscriptionSupported --> Webex Assistant is not supported');
      return false;
    }

    /**
     * Monitor the Low-Latency Mercury (LLM) web socket connection on `onError` and `onClose` states
     * @private
     * @returns {void}
     */
  }, {
    key: "monitorTranscriptionSocketConnection",
    value: function monitorTranscriptionSocketConnection() {
      var _this32 = this;
      this.transcription.onCloseSocket(function (event) {
        _loggerProxy.default.logger.info("Meeting:index#onCloseSocket -->\n        unable to continue receiving transcription;\n        low-latency mercury web socket connection is closed now.\n        ".concat(event));
        _this32.triggerStopReceivingTranscriptionEvent();
      });
      this.transcription.onErrorSocket(function (event) {
        _loggerProxy.default.logger.error("Meeting:index#onErrorSocket -->\n         unable to continue receiving transcription;\n         low-latency mercury web socket connection error had occured.\n        ".concat(event));
        _this32.triggerStopReceivingTranscriptionEvent();
        _metrics.default.sendBehavioralMetric(_constants2.default.RECEIVE_TRANSCRIPTION_FAILURE, {
          correlation_id: _this32.correlationId,
          reason: 'unexpected error: transcription LLM web socket connection error had occured.',
          event: event
        });
      });
    }

    /**
     * Request for a WebSocket Url, open and monitor the WebSocket connection
     * @private
     * @returns {Promise<void>} a promise to open the WebSocket connection
     */
  }, {
    key: "startTranscription",
    value: function () {
      var _startTranscription = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3() {
        var _this33 = this;
        var datachannelUrl, _yield$this$request, webSocketUrl;
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _loggerProxy.default.logger.info("Meeting:index#startTranscription -->\n      Attempting to generate a web socket url.");
              _context3.prev = 1;
              datachannelUrl = this.locusInfo.info.datachannelUrl; // @ts-ignore - fix type
              _context3.next = 5;
              return this.request({
                method: _constants.HTTP_VERBS.POST,
                uri: datachannelUrl,
                body: {
                  deviceUrl: this.deviceUrl
                }
              });
            case 5:
              _yield$this$request = _context3.sent;
              webSocketUrl = _yield$this$request.body.webSocketUrl;
              _loggerProxy.default.logger.info("Meeting:index#startTranscription -->\n        Generated web socket url succesfully.");
              this.transcription = new _transcription.default(webSocketUrl,
              // @ts-ignore - fix type
              this.webex.sessionId, this.members);
              _loggerProxy.default.logger.info("Meeting:index#startTranscription -->\n        opened LLM web socket connection successfully.");
              if (!this.inMeetingActions.isClosedCaptionActive) {
                _loggerProxy.default.logger.error("Meeting:index#receiveTranscription --> Transcription cannot be started until a licensed user enables it");
              }

              // retrieve and pass the payload
              this.transcription.subscribe(function (payload) {
                _triggerProxy.default.trigger(_this33, {
                  file: 'meeting/index',
                  function: 'join'
                }, _constants.EVENT_TRIGGERS.MEETING_STARTED_RECEIVING_TRANSCRIPTION, payload);
              });
              this.monitorTranscriptionSocketConnection();
              // @ts-ignore - fix type
              this.transcription.connect(this.webex.credentials.supertoken.access_token);
              _context3.next = 20;
              break;
            case 16:
              _context3.prev = 16;
              _context3.t0 = _context3["catch"](1);
              _loggerProxy.default.logger.error("Meeting:index#startTranscription --> ".concat(_context3.t0));
              _metrics.default.sendBehavioralMetric(_constants2.default.RECEIVE_TRANSCRIPTION_FAILURE, {
                correlation_id: this.correlationId,
                reason: _context3.t0.message,
                stack: _context3.t0.stack
              });
            case 20:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[1, 16]]);
      }));
      function startTranscription() {
        return _startTranscription.apply(this, arguments);
      }
      return startTranscription;
    }()
    /**
     * stop recieving Transcription by closing
     * the web socket connection properly
     * @returns {void}
     */
  }, {
    key: "stopReceivingTranscription",
    value: function stopReceivingTranscription() {
      if (this.transcription) {
        this.transcription.closeSocket();
      }
    }

    /**
     * triggers an event to notify that the user
     * will not receive any more transcription
     * @private
     * @returns{void}
     */
  }, {
    key: "triggerStopReceivingTranscriptionEvent",
    value: function triggerStopReceivingTranscriptionEvent() {
      _loggerProxy.default.logger.info("\n      Meeting:index#stopReceivingTranscription -->\n      closed transcription LLM web socket connection successfully.");
      _triggerProxy.default.trigger(this, {
        file: 'meeting',
        function: 'triggerStopReceivingTranscriptionEvent'
      }, _constants.EVENT_TRIGGERS.MEETING_STOPPED_RECEIVING_TRANSCRIPTION);
    }

    /**
     * Specify joining via audio (option: pstn), video, screenshare
     * @param {JoinOptions} options A configurable options object for joining a meeting
     * @returns {Promise} the join response
     * @public
     * @memberof Meeting
     * Scenario A: Joining own claimed personal meeting room
     * Scenario B: Joining other's claimed personal meeting room, do pass pin (if desired to join as host, or nullify), do pass moderator
     * Scenario C: Joining an unclaimed personal meeting room, -do not- pass pin or moderator on first try, -do- pass pin and moderator
     *             if joining as host on second loop, pass pin and pass moderator if joining as guest on second loop
     * Scenario D: Joining any other way (sip, pstn, conversationUrl, link just need to specify resourceId)
     */
  }, {
    key: "join",
    value: function join() {
      var _this34 = this;
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      // @ts-ignore - fix type
      if (!this.webex.meetings.registered) {
        var errorMessage = 'Meeting:index#join --> Device not registered';
        var error = new Error(errorMessage);
        _loggerProxy.default.logger.error(errorMessage);
        return _promise.default.reject(error);
      }

      // If a join request is being processed, refer to the deferred promise.
      if (this.deferJoin) {
        return this.deferJoin;
      }

      // Scope-up the resolve/reject methods for handling within join().
      var joinFailed;
      var joinSuccess;

      // Create a deferred promise for a consistent resolve value from utils.
      // This also prevents redundant API calls.
      this.deferJoin = new _promise.default(function (resolve, reject) {
        joinFailed = reject;
        joinSuccess = resolve;
      });
      if (!this.hasJoinedOnce) {
        this.hasJoinedOnce = true;
      } else {
        _loggerProxy.default.logger.log("Meeting:index#join --> Generating a new correlation id for meeting ".concat(this.id));
        _loggerProxy.default.logger.log("Meeting:index#join --> Previous correlation id ".concat(this.correlationId));
        this.setCorrelationId(_uuid.default.v4());
        _loggerProxy.default.logger.log("Meeting:index#join --> New correlation id ".concat(this.correlationId));
      }
      if (options.rejoin) {
        this.meetingFiniteStateMachine.reset();
      }
      _metrics.default.postEvent({
        event: _config.eventType.CALL_INITIATED,
        meeting: this,
        data: {
          trigger: _config.trigger.USER_INTERACTION,
          isRoapCallEnabled: true
        }
      });
      _loggerProxy.default.logger.log('Meeting:index#join --> Joining a meeting');
      if (this.meetingFiniteStateMachine.state === _constants.MEETING_STATE_MACHINE.STATES.ENDED) {
        this.meetingFiniteStateMachine.reset();
      }
      if (this.meetingFiniteStateMachine.state !== _constants.MEETING_STATE_MACHINE.STATES.RINGING) {
        this.meetingFiniteStateMachine.ring(_constants._JOIN_);
      }

      // TODO: does this really need to be here?
      if (options.resourceId && this.destination && options.resourceId === this.destination) {
        this.wirelessShare = true;
      }
      if (options.meetingQuality) {
        if (typeof options.meetingQuality === 'string') {
          if (!_constants.QUALITY_LEVELS[options.meetingQuality]) {
            var _errorMessage = "Meeting:index#join --> ".concat(options.meetingQuality, " not defined");
            var _error = new Error(_errorMessage);
            _loggerProxy.default.logger.error(_errorMessage);
            joinFailed(_error);
            this.deferJoin = undefined;
            return _promise.default.reject(_error);
          }
          this.mediaProperties.setLocalQualityLevel(options.meetingQuality);
          this.mediaProperties.setRemoteQualityLevel(options.meetingQuality);
        }
        if ((0, _typeof2.default)(options.meetingQuality) === 'object') {
          if (!_constants.QUALITY_LEVELS[options.meetingQuality.local] && !_constants.QUALITY_LEVELS[options.meetingQuality.remote]) {
            var _errorMessage2 = "Meeting:index#join --> ".concat(options.meetingQuality.local || options.meetingQuality.remote, " not defined");
            _loggerProxy.default.logger.error(_errorMessage2);
            var _error2 = new Error(_errorMessage2);
            joinFailed(_error2);
            this.deferJoin = undefined;
            return _promise.default.reject(new Error(_errorMessage2));
          }
          if (options.meetingQuality.local) {
            this.mediaProperties.setLocalQualityLevel(options.meetingQuality.local);
          }
          if (options.meetingQuality.remote) {
            this.mediaProperties.setRemoteQualityLevel(options.meetingQuality.remote);
          }
        }
      }
      return _util.default.joinMeetingOptions(this, options).then(function (join) {
        _this34.meetingFiniteStateMachine.join();
        _loggerProxy.default.logger.log('Meeting:index#join --> Success');
        return join;
      }).then(function (join) {
        joinSuccess(join);
        _this34.deferJoin = undefined;
        _this34.receiveTranscription = !!options.receiveTranscription;
        _metrics.default.sendBehavioralMetric(_constants2.default.JOIN_SUCCESS, {
          correlation_id: _this34.correlationId
        });
        return join;
      }).then( /*#__PURE__*/function () {
        var _ref12 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4(join) {
          return _regenerator.default.wrap(function _callee4$(_context4) {
            while (1) switch (_context4.prev = _context4.next) {
              case 0:
                if (!isBrowser) {
                  _context4.next = 8;
                  break;
                }
                if (!(_this34.config.receiveTranscription || _this34.receiveTranscription)) {
                  _context4.next = 6;
                  break;
                }
                if (!_this34.isTranscriptionSupported()) {
                  _context4.next = 6;
                  break;
                }
                _context4.next = 5;
                return _this34.startTranscription();
              case 5:
                _loggerProxy.default.logger.info('Meeting:index#join --> enabled to receive transcription!');
              case 6:
                _context4.next = 9;
                break;
              case 8:
                _loggerProxy.default.logger.error('Meeting:index#join --> Receving transcription is not supported on this platform');
              case 9:
                return _context4.abrupt("return", join);
              case 10:
              case "end":
                return _context4.stop();
            }
          }, _callee4);
        }));
        return function (_x3) {
          return _ref12.apply(this, arguments);
        };
      }()).catch(function (error) {
        var _error$error;
        _this34.meetingFiniteStateMachine.fail(error);
        _loggerProxy.default.logger.error('Meeting:index#join --> Failed', error);
        _metrics.default.postEvent({
          event: _config.eventType.LOCUS_JOIN_RESPONSE,
          meeting: _this34,
          meetingId: _this34.id,
          data: {
            errors: [_metrics.default.parseLocusError(error.error, true)]
          }
        });

        // TODO:  change this to error codes and pre defined dictionary
        _metrics.default.sendBehavioralMetric(_constants2.default.JOIN_FAILURE, {
          correlation_id: _this34.correlationId,
          reason: (_error$error = error.error) === null || _error$error === void 0 ? void 0 : _error$error.message,
          stack: error.stack
        });

        // Upload logs on join Failure
        _triggerProxy.default.trigger(_this34, {
          file: 'meeting/index',
          function: 'join'
        }, _constants.EVENTS.REQUEST_UPLOAD_LOGS, _this34);
        joinFailed(error);
        _this34.deferJoin = undefined;
        return _promise.default.reject(error);
      });
    }

    /**
     * Use phone for meeting audio
     * @param {String} phoneNumber If provided, it will dial-out using this number. If not provided, dial-in will be used
     * @returns {Promise} Resolves once the dial-in or dial-out request has completed, or rejects if it failed
     * @public
     * @memberof Meeting
     */
  }, {
    key: "usePhoneAudio",
    value: function usePhoneAudio(phoneNumber) {
      if (!phoneNumber) {
        return this.dialInPstn();
      }
      return this.dialOutPstn(phoneNumber);
    }

    /**
     * Determines if the given pstnStatus is in a state which implies the phone is provisioned
     * @param {String} pstnStatus
     * @returns {Boolean}
     * @private
     * @memberof Meeting
     */
  }, {
    key: "isPhoneProvisioned",
    value: function isPhoneProvisioned(pstnStatus) {
      return [_constants.PSTN_STATUS.JOINED, _constants.PSTN_STATUS.CONNECTED, _constants.PSTN_STATUS.SUCCESS].includes(pstnStatus);
    }

    /**
     * Enable dial-in for audio
     * @returns {Promise} Resolves once the dial-in request has completed, or rejects if it failed
     * @private
     * @memberof Meeting
     */
  }, {
    key: "dialInPstn",
    value: function dialInPstn() {
      var _this35 = this;
      if (this.isPhoneProvisioned(this.dialInDeviceStatus)) return _promise.default.resolve(); // prevent multiple dial in devices from being provisioned

      var correlationId = this.correlationId,
        locusUrl = this.locusUrl;
      if (!this.dialInUrl) this.dialInUrl = "dialin:///".concat(_uuid.default.v4());
      return this.meetingRequest
      // @ts-ignore
      .dialIn({
        correlationId: correlationId,
        dialInUrl: this.dialInUrl,
        locusUrl: locusUrl,
        clientUrl: this.deviceUrl
      }).then(function (res) {
        _this35.locusInfo.onFullLocus(res.body.locus);
      }).catch(function (error) {
        var _error$error2;
        _metrics.default.sendBehavioralMetric(_constants2.default.ADD_DIAL_IN_FAILURE, {
          correlation_id: _this35.correlationId,
          dial_in_url: _this35.dialInUrl,
          locus_id: locusUrl.split('/').pop(),
          client_url: _this35.deviceUrl,
          reason: (_error$error2 = error.error) === null || _error$error2 === void 0 ? void 0 : _error$error2.message,
          stack: error.stack
        });
        return _promise.default.reject(error);
      });
    }

    /**
     * Enable dial-out for audio
     * @param {String} phoneNumber Phone number to dial out to
     * @returns {Promise} Resolves once the dial-out request has completed (it doesn't wait for the user to answer the phone), or rejects if it failed
     * @private
     * @memberof Meeting
     */
  }, {
    key: "dialOutPstn",
    value: function dialOutPstn(phoneNumber) {
      var _this36 = this;
      if (this.isPhoneProvisioned(this.dialOutDeviceStatus)) return _promise.default.resolve(); // prevent multiple dial out devices from being provisioned

      var correlationId = this.correlationId,
        locusUrl = this.locusUrl;
      if (!this.dialOutUrl) this.dialOutUrl = "dialout:///".concat(_uuid.default.v4());
      return this.meetingRequest
      // @ts-ignore
      .dialOut({
        correlationId: correlationId,
        dialOutUrl: this.dialOutUrl,
        phoneNumber: phoneNumber,
        locusUrl: locusUrl,
        clientUrl: this.deviceUrl
      }).then(function (res) {
        _this36.locusInfo.onFullLocus(res.body.locus);
      }).catch(function (error) {
        var _error$error3;
        _metrics.default.sendBehavioralMetric(_constants2.default.ADD_DIAL_OUT_FAILURE, {
          correlation_id: _this36.correlationId,
          dial_out_url: _this36.dialOutUrl,
          locus_id: locusUrl.split('/').pop(),
          client_url: _this36.deviceUrl,
          reason: (_error$error3 = error.error) === null || _error$error3 === void 0 ? void 0 : _error$error3.message,
          stack: error.stack
        });
        return _promise.default.reject(error);
      });
    }

    /**
     * Disconnect meeting audio via phone.
     * @returns {Promise} Resolves once the phone audio disconnection has completed
     * @public
     * @memberof Meeting
     * @returns {Promise}
     */
  }, {
    key: "disconnectPhoneAudio",
    value: function disconnectPhoneAudio() {
      return _promise.default.all([this.isPhoneProvisioned(this.dialInDeviceStatus) ? _util.default.disconnectPhoneAudio(this, this.dialInUrl) : _promise.default.resolve(), this.isPhoneProvisioned(this.dialOutDeviceStatus) ? _util.default.disconnectPhoneAudio(this, this.dialOutUrl) : _promise.default.resolve()]);
    }

    /**
     * Moves the call to the specified resourceId
     * @param {String} resourceId
     * @returns {Promise} once the move has been completed
     * @public
     * @memberof Meeting
     */
  }, {
    key: "moveTo",
    value: function moveTo(resourceId) {
      var _this37 = this;
      if (!resourceId) {
        throw new _parameter.default('Cannot move call without a resourceId.');
      }
      _metrics.default.postEvent({
        event: _config.eventType.MEDIA_CAPABILITIES,
        meeting: this,
        data: {
          mediaCapabilities: {
            rx: {
              audio: false,
              share: true,
              share_audio: false,
              video: false,
              whiteboard: false
            },
            tx: {
              audio: false,
              share: false,
              share_audio: false,
              video: false,
              whiteboard: false
            }
          }
        }
      });
      _metrics.default.postEvent({
        event: _config.eventType.MOVE_MEDIA,
        meeting: this
      });
      this.locusInfo.once(_constants.LOCUSINFO.EVENTS.SELF_OBSERVING, /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5() {
        var mediaSettings;
        return _regenerator.default.wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.prev = 0;
              if (!_this37.isSharing) {
                _context5.next = 4;
                break;
              }
              _context5.next = 4;
              return _this37.releaseScreenShareFloor();
            case 4:
              mediaSettings = {
                mediaDirection: {
                  sendVideo: false,
                  receiveVideo: false,
                  sendAudio: false,
                  receiveAudio: false,
                  sendShare: false,
                  receiveShare: true
                }
              }; // clean up the local tracks
              _this37.mediaProperties.setMediaDirection(mediaSettings.mediaDirection);

              // close the existing local tracks
              _context5.next = 8;
              return _this37.closeLocalStream();
            case 8:
              _context5.next = 10;
              return _this37.closeLocalShare();
            case 10:
              _this37.mediaProperties.unsetMediaTracks();

              // when a move to is intiated by the client , Locus delets the existing media node from the server as soon the DX answers the meeting
              // once the DX answers we establish connection back the media server with only receiveShare enabled
              // @ts-ignore - reconnectMedia does not accept any argument
              _context5.next = 13;
              return _this37.reconnectionManager.reconnectMedia(mediaSettings).then(function () {
                _metrics.default.sendBehavioralMetric(_constants2.default.MOVE_TO_SUCCESS);
              });
            case 13:
              _context5.next = 19;
              break;
            case 15:
              _context5.prev = 15;
              _context5.t0 = _context5["catch"](0);
              _loggerProxy.default.logger.error('Meeting:index#moveTo --> Failed to moveTo resourceId', _context5.t0);
              _metrics.default.sendBehavioralMetric(_constants2.default.MOVE_TO_FAILURE, {
                correlation_id: _this37.correlationId,
                locus_id: _this37.locusUrl.split('/').pop(),
                reason: _context5.t0.message,
                stack: _context5.t0.stack
              });
            case 19:
            case "end":
              return _context5.stop();
          }
        }, _callee5, null, [[0, 15]]);
      })));
      _loggerProxy.default.logger.info('Meeting:index#moveTo --> Initated moved to using resourceId', resourceId);
      return _util.default.joinMeetingOptions(this, {
        resourceId: resourceId,
        moveToResource: true
      }).then(function () {
        _this37.meetingFiniteStateMachine.join();
      }).catch(function (error) {
        _this37.meetingFiniteStateMachine.fail(error);
        _metrics.default.sendBehavioralMetric(_constants2.default.MOVE_TO_FAILURE, {
          correlation_id: _this37.correlationId,
          locus_id: _this37.locusUrl.split('/').pop(),
          reason: error.message,
          stack: error.stack
        });
        _loggerProxy.default.logger.error('Meeting:index#moveTo --> Failed to moveTo resourceId', error);
        return _promise.default.reject(error);
      });
    }

    /**
     * Moves the call from the specified resourceId, back to computer
     * @param {String} resourceId
     * @returns {Promise} once the move has been completed
     * @public
     * @memberof Meeting
     */
  }, {
    key: "moveFrom",
    value: function moveFrom(resourceId) {
      var _this38 = this;
      // On moveFrom ask the developer to re capture it moveFrom  then updateMedia
      if (!resourceId) {
        throw new _parameter.default('Cannot move call without a resourceId.');
      }
      var oldCorrelationId = this.correlationId;
      _metrics.default.postEvent({
        event: _config.eventType.MOVE_MEDIA,
        meeting: this
      });
      return _util.default.joinMeetingOptions(this).then(function () {
        return _util.default.leaveMeeting(_this38, {
          resourceId: resourceId,
          correlationId: oldCorrelationId,
          moveMeeting: true
        }).then(function () {
          _this38.resourceId = '';
          _metrics.default.sendBehavioralMetric(_constants2.default.MOVE_FROM_SUCCESS);
        });
      }).catch(function (error) {
        _this38.meetingFiniteStateMachine.fail(error);
        _metrics.default.sendBehavioralMetric(_constants2.default.MOVE_FROM_FAILURE, {
          correlation_id: _this38.correlationId,
          locus_id: _this38.locusUrl.split('/').pop(),
          reason: error.message,
          stack: error.stack
        });
        _loggerProxy.default.logger.error('Meeting:index#moveTo --> Failed to moveTo resourceId', error);
        return _promise.default.reject(error);
      });
    }
  }, {
    key: "addMedia",
    value:
    /**
     * Specify joining via audio (option: pstn), video, screenshare
     * @param {Object} options A configurable options object for joining a meeting
     * @param {Object} options.resourceId pass the deviceId
     * @param {MediaDirection} options.mediaSettings pass media options
     * @param {MediaStream} options.localStream
     * @param {MediaStream} options.localShare
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
    function addMedia() {
      var _this39 = this;
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var LOG_HEADER = 'Meeting:index#addMedia -->';
      var turnDiscoverySkippedReason;
      var turnServerUsed = false;
      if (this.meetingState !== _constants.FULL_STATE.ACTIVE) {
        return _promise.default.reject(new _webexErrors.MeetingNotActiveError());
      }
      if (_util.default.isUserInLeftState(this.locusInfo)) {
        return _promise.default.reject(new _webexErrors.UserNotJoinedError());
      }
      // If the user is unjoined or guest waiting in lobby dont allow the user to addMedia
      // @ts-ignore - isUserUnadmitted coming from SelfUtil
      if (this.isUserUnadmitted && !this.wirelessShare) {
        return _promise.default.reject(new _webexErrors.UserInLobbyError());
      }
      var localStream = options.localStream,
        localShare = options.localShare,
        mediaSettings = options.mediaSettings;
      _loggerProxy.default.logger.info("".concat(LOG_HEADER, " Adding Media."));
      _metrics.default.postEvent({
        event: _config.eventType.MEDIA_CAPABILITIES,
        meeting: this,
        data: {
          mediaCapabilities: {
            rx: {
              audio: false,
              share: false,
              share_audio: false,
              video: false,
              whiteboard: false
            },
            tx: {
              audio: false,
              share: false,
              share_audio: false,
              video: false,
              whiteboard: false
            }
          }
        }
      });
      return _util.default.validateOptions(options).then(function () {
        return _this39.roap.doTurnDiscovery(_this39, false);
      }).then(function (turnDiscoveryObject) {
        turnDiscoverySkippedReason = turnDiscoveryObject.turnDiscoverySkippedReason;
        turnServerUsed = !turnDiscoverySkippedReason;
        var turnServerInfo = turnDiscoveryObject.turnServerInfo;
        _this39.mediaProperties.setMediaPeerConnection(_util4.default.createPeerConnection(turnServerInfo));
        _this39.setMercuryListener();
        _peerConnectionManager.default.setPeerConnectionEvents(_this39);
        return _this39.preMedia(localStream, localShare, mediaSettings);
      }).then(function () {
        return _media.default.attachMedia(_this39.mediaProperties, {
          meetingId: _this39.id,
          remoteQualityLevel: _this39.mediaProperties.remoteQualityLevel,
          // @ts-ignore - config coming from registerPlugin
          enableRtx: _this39.config.enableRtx,
          // @ts-ignore - config coming from registerPlugin
          enableExtmap: _this39.config.enableExtmap,
          setStartLocalSDPGenRemoteSDPRecvDelay: _this39.setStartLocalSDPGenRemoteSDPRecvDelay.bind(_this39)
        });
      }).then(function (peerConnection) {
        return _this39.getDevices().then(function (devices) {
          _util.default.handleDeviceLogging(devices);
          return peerConnection;
        });
      }).then(function (peerConnection) {
        _this39.handleMediaLogging(_this39.mediaProperties);
        _loggerProxy.default.logger.info("".concat(LOG_HEADER, " PeerConnection Received from attachMedia "));
        _this39.setRemoteStream(peerConnection);
        // @ts-ignore - config coming from registerPlugin
        if (_this39.config.stats.enableStatsAnalyzer) {
          // TODO: ** Dont re create StatsAnalyzer on reconnect or rejoin
          // @ts-ignore - config coming from registerPlugin
          _this39.networkQualityMonitor = new _networkQualityMonitor.default(_this39.config.stats);
          // @ts-ignore - config coming from registerPlugin
          _this39.statsAnalyzer = new _statsAnalyzer.StatsAnalyzer(_this39.config.stats, _this39.networkQualityMonitor);
          _this39.setupStatsAnalyzerEventHandlers();
          _this39.networkQualityMonitor.on(_constants.EVENT_TRIGGERS.NETWORK_QUALITY, _this39.sendNetworkQualityEvent.bind(_this39));
        }
      }).catch(function (error) {
        _loggerProxy.default.logger.error("".concat(LOG_HEADER, " Error adding media , setting up peerconnection, "), error);
        throw error;
      }).then(function () {
        return new _promise.default(function (resolve, reject) {
          var timerCount = 0;

          // eslint-disable-next-line func-names
          // eslint-disable-next-line prefer-arrow-callback
          if (_this39.type === _constants._CALL_) {
            resolve();
          }
          var joiningTimer = setInterval(function () {
            timerCount += 1;
            if (_this39.meetingState === _constants.FULL_STATE.ACTIVE) {
              clearInterval(joiningTimer);
              resolve();
            }
            if (timerCount === 4) {
              clearInterval(joiningTimer);
              reject(new Error('Meeting is still not active '));
            }
          }, 1000);
        });
      }).then(function () {
        return logRequest(_this39.roap.sendRoapMediaRequest({
          sdp: _this39.mediaProperties.peerConnection.sdp,
          roapSeq: _this39.roapSeq,
          meeting: _this39 // or can pass meeting ID
        }), {
          header: "".concat(LOG_HEADER, " Send Roap Media Request."),
          success: "".concat(LOG_HEADER, " Successfully send roap media request"),
          failure: "".concat(LOG_HEADER, " Error joining the call on send roap media request, ")
        });
      }).then(function () {
        return _this39.mediaProperties.waitForIceConnectedState().catch(function () {
          throw (0, _webexErrors.createMeetingsError)(30202, 'Meeting connection failed');
        });
      }).then(function () {
        _loggerProxy.default.logger.info("".concat(LOG_HEADER, " PeerConnection CONNECTED"));
        if (mediaSettings && mediaSettings.sendShare && localShare) {
          if (_this39.state === _constants.MEETING_STATE.STATES.JOINED) {
            return _this39.requestScreenShareFloor();
          }

          // When the self state changes to JOINED then request the floor
          _this39.floorGrantPending = true;
        }
        return {};
      }).then(function () {
        return _this39.mediaProperties.getCurrentConnectionType();
      }).then(function (connectionType) {
        _metrics.default.sendBehavioralMetric(_constants2.default.ADD_MEDIA_SUCCESS, {
          correlation_id: _this39.correlationId,
          locus_id: _this39.locusUrl.split('/').pop(),
          connectionType: connectionType
        });
      }).catch(function (error) {
        // Clean up stats analyzer, peer connection, and turn off listeners
        var stopStatsAnalyzer = _this39.statsAnalyzer ? _this39.statsAnalyzer.stopAnalyzer() : _promise.default.resolve();
        return stopStatsAnalyzer.then(function () {
          _this39.statsAnalyzer = null;
          if (_this39.mediaProperties.peerConnection) {
            _this39.closePeerConnections();
            _this39.unsetPeerConnections();
          }
          _loggerProxy.default.logger.error("".concat(LOG_HEADER, " Error adding media failed to initiate PC and send request, "), error);
          _metrics.default.sendBehavioralMetric(_constants2.default.ADD_MEDIA_FAILURE, {
            correlation_id: _this39.correlationId,
            locus_id: _this39.locusUrl.split('/').pop(),
            reason: error.message,
            stack: error.stack,
            code: error.code,
            turnDiscoverySkippedReason: turnDiscoverySkippedReason,
            turnServerUsed: turnServerUsed
          });

          // Upload logs on error while adding media
          _triggerProxy.default.trigger(_this39, {
            file: 'meeting/index',
            function: 'addMedia'
          }, _constants.EVENTS.REQUEST_UPLOAD_LOGS, _this39);

          // If addMedia failes for not establishing connection then
          // leave the meeting with reson connection failed as meeting anyways will end
          // and cannot be connected unless network condition is checked for firewall
          if (error.code === _webexErrors.InvalidSdpError.CODE) {
            _this39.leave({
              reason: _constants.MEETING_REMOVED_REASON.MEETING_CONNECTION_FAILED
            });
          }
          throw error;
        });
      });
    }

    /**
     * Informs if the peer connection is in a state that can be updated with updateMedia (audio/video/share)
     * @returns {Boolean}
     */
  }, {
    key: "canUpdateMedia",
    value: function canUpdateMedia() {
      return this.mediaProperties.peerConnection.signalingState === _constants.SDP.STABLE && !_collection.default.isBusy(this.correlationId);
    }

    /**
     * Enqueues a media update operation.
     * @param {String} mediaUpdateType one of MEDIA_UPDATE_TYPE values
     * @param {Object} options
     * @returns {Promise}
     * @private
     * @memberof Meeting
     */
  }, {
    key: "enqueueMediaUpdate",
    value: function enqueueMediaUpdate(mediaUpdateType, options) {
      var _this40 = this;
      return new _promise.default(function (resolve, reject) {
        var queueItem = {
          pendingPromiseResolve: resolve,
          pendingPromiseReject: reject,
          mediaUpdateType: mediaUpdateType,
          options: options
        };
        _loggerProxy.default.logger.log("Meeting:index#enqueueMediaUpdate --> enqueuing media update type=".concat(mediaUpdateType));
        _this40.queuedMediaUpdates.push(queueItem);
      });
    }
  }, {
    key: "updateMedia",
    value:
    /**
     * A confluence of updateAudio, updateVideo, and updateShare
     * this function re-establishes all of the media streams with new options
     * @param {Object} options
     * @param {MediaStream} options.localStream
     * @param {MediaStream} options.localShare
     * @param {MediaDirection} options.mediaSettings
     * @returns {Promise}
     * @todo fix setRemoteStream for updateMedia
     * @public
     * @memberof Meeting
     */
    function updateMedia() {
      var _this41 = this;
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var LOG_HEADER = 'Meeting:index#updateMedia -->';
      if (!this.canUpdateMedia()) {
        return this.enqueueMediaUpdate(MEDIA_UPDATE_TYPE.ALL, options);
      }
      var localStream = options.localStream,
        localShare = options.localShare,
        mediaSettings = options.mediaSettings;
      var previousSendShareStatus = this.mediaProperties.mediaDirection.sendShare;
      return _util.default.validateOptions(options).then(function () {
        return _this41.preMedia(localStream, localShare, mediaSettings);
      }).then(function () {
        return _media.default.updateMedia(_this41.mediaProperties, {
          meetingId: _this41.id,
          remoteQualityLevel: _this41.mediaProperties.remoteQualityLevel,
          // @ts-ignore - config coming from registerPlugin
          enableRtx: _this41.config.enableRtx,
          // @ts-ignore - config coming from registerPlugin
          enableExtmap: _this41.config.enableExtmap
        }).then(function (peerConnection) {
          _loggerProxy.default.logger.info("".concat(LOG_HEADER, " PeerConnection received from updateMedia, ").concat(peerConnection));
          _this41.setRemoteStream(peerConnection);
          if (mediaSettings.receiveShare || localShare) {
            _peerConnectionManager.default.setContentSlides(peerConnection);
          }
        }).catch(function (error) {
          _loggerProxy.default.logger.error("".concat(LOG_HEADER, " Error updatedMedia, "), error);
          _metrics.default.sendBehavioralMetric(_constants2.default.UPDATE_MEDIA_FAILURE, {
            correlation_id: _this41.correlationId,
            locus_id: _this41.locusUrl.split('/').pop(),
            reason: error.message,
            stack: error.stack
          });
          throw error;
        }).then(function () {
          return logRequest(_this41.roap.sendRoapMediaRequest({
            sdp: _this41.mediaProperties.peerConnection.sdp,
            roapSeq: _this41.roapSeq,
            meeting: _this41 // or can pass meeting ID
          }), {
            header: "".concat(LOG_HEADER, " sendRoapMediaRequest being sent"),
            success: "".concat(LOG_HEADER, " sendRoadMediaRequest successful"),
            failure: "".concat(LOG_HEADER, " Error updateMedia on send roap media request, ")
          });
        }).then(function () {
          return _this41.checkForStopShare(mediaSettings.sendShare, previousSendShareStatus);
        }).then(function (startShare) {
          // This is a special case if we do an /floor grant followed by /media
          // we actually get a OFFER from the server and a GLAR condition happens
          if (startShare) {
            // We are assuming that the clients are connected when doing an update
            return _this41.requestScreenShareFloor();
          }
          return _promise.default.resolve();
        });
      });
    }

    /**
     * Update the main audio track with new parameters
     * @param {Object} options
     * @param {boolean} options.sendAudio
     * @param {boolean} options.receiveAudio
     * @param {MediaStream} options.stream Stream that contains the audio track to update
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
  }, {
    key: "updateAudio",
    value: function () {
      var _updateAudio = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6(options) {
        var _this42 = this;
        var sendAudio, receiveAudio, stream, audioTransceiver, track, bnrEnabled;
        return _regenerator.default.wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              if (this.canUpdateMedia()) {
                _context6.next = 2;
                break;
              }
              return _context6.abrupt("return", this.enqueueMediaUpdate(MEDIA_UPDATE_TYPE.AUDIO, options));
            case 2:
              sendAudio = options.sendAudio, receiveAudio = options.receiveAudio, stream = options.stream;
              audioTransceiver = this.mediaProperties.peerConnection.audioTransceiver;
              track = _util.default.getTrack(stream).audioTrack;
              if (!(typeof sendAudio !== 'boolean' || typeof receiveAudio !== 'boolean')) {
                _context6.next = 7;
                break;
              }
              return _context6.abrupt("return", _promise.default.reject(new _parameter.default('Pass sendAudio and receiveAudio parameter')));
            case 7:
              if (!(this.effects && this.effects.state)) {
                _context6.next = 15;
                break;
              }
              bnrEnabled = this.effects.state.bnr.enabled;
              if (!(sendAudio && !this.isAudioMuted() && (bnrEnabled === _constants.BNR_STATUS.ENABLED || bnrEnabled === _constants.BNR_STATUS.SHOULD_ENABLE))) {
                _context6.next = 15;
                break;
              }
              _loggerProxy.default.logger.info('Meeting:index#updateAudio. Calling WebRTC enable bnr method');
              _context6.next = 13;
              return this.internal_enableBNR(track);
            case 13:
              track = _context6.sent;
              _loggerProxy.default.logger.info('Meeting:index#updateAudio. WebRTC enable bnr request completed');
            case 15:
              return _context6.abrupt("return", _util.default.validateOptions({
                sendAudio: sendAudio,
                localStream: stream
              }).then(function () {
                var previousMediaDirection = {};
                if (_this42.mediaProperties.mediaDirection) {
                  previousMediaDirection = {
                    sendTrack: _this42.mediaProperties.mediaDirection.sendAudio,
                    receiveTrack: _this42.mediaProperties.mediaDirection.receiveAudio
                  };
                } else {
                  _this42.mediaProperties.mediaDirection = {};
                }
                return _util.default.updateTransceiver({
                  type: 'audio',
                  sendTrack: options.sendAudio,
                  receiveTrack: options.receiveAudio,
                  track: track,
                  transceiver: audioTransceiver,
                  peerConnection: _this42.mediaProperties.peerConnection,
                  previousMediaDirection: previousMediaDirection
                }, {
                  mediaProperties: _this42.mediaProperties,
                  meeting: _this42,
                  id: _this42.id
                });
              }).then(function () {
                _this42.setLocalAudioTrack(track);
                _this42.mediaProperties.mediaDirection.sendAudio = sendAudio;
                _this42.mediaProperties.mediaDirection.receiveAudio = receiveAudio;

                // audio state could be undefined if you have not sent audio before
                _this42.audio = _this42.audio || (0, _muteState.default)(_constants.AUDIO, _this42, _this42.mediaProperties.mediaDirection);
              }));
            case 16:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function updateAudio(_x4) {
        return _updateAudio.apply(this, arguments);
      }
      return updateAudio;
    }()
    /**
     * Update the main video track with new parameters
     * @param {Object} options
     * @param {boolean} options.sendVideo
     * @param {boolean} options.receiveVideo
     * @param {MediaStream} options.stream Stream that contains the video track to update
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
  }, {
    key: "updateVideo",
    value: function updateVideo(options) {
      var _this43 = this;
      if (!this.canUpdateMedia()) {
        return this.enqueueMediaUpdate(MEDIA_UPDATE_TYPE.VIDEO, options);
      }
      var sendVideo = options.sendVideo,
        receiveVideo = options.receiveVideo,
        stream = options.stream;
      var videoTransceiver = this.mediaProperties.peerConnection.videoTransceiver;
      var track = _util.default.getTrack(stream).videoTrack;
      if (typeof sendVideo !== 'boolean' || typeof receiveVideo !== 'boolean') {
        return _promise.default.reject(new _parameter.default('Pass sendVideo and receiveVideo parameter'));
      }
      return _util.default.validateOptions({
        sendVideo: sendVideo,
        localStream: stream
      }).then(function () {
        return _util.default.updateTransceiver({
          type: 'video',
          sendTrack: options.sendVideo,
          receiveTrack: options.receiveVideo,
          track: track,
          transceiver: videoTransceiver,
          peerConnection: _this43.mediaProperties.peerConnection,
          previousMediaDirection: {
            sendTrack: _this43.mediaProperties.mediaDirection.sendVideo,
            receiveTrack: _this43.mediaProperties.mediaDirection.receiveVideo
          }
        }, {
          mediaProperties: _this43.mediaProperties,
          meeting: _this43,
          id: _this43.id
        });
      }).then(function () {
        _this43.setLocalVideoTrack(track);
        _this43.mediaProperties.mediaDirection.sendVideo = sendVideo;
        _this43.mediaProperties.mediaDirection.receiveVideo = receiveVideo;

        // video state could be undefined if you have not sent video before
        _this43.video = _this43.video || (0, _muteState.default)(_constants.VIDEO, _this43, _this43.mediaProperties.mediaDirection);
      });
    }

    /**
     * Internal function when stopping a share stream, cleanup
     * @param {boolean} sendShare
     * @param {boolean} previousShareStatus
     * @returns {Promise}
     * @private
     * @memberof Meeting
     */
  }, {
    key: "checkForStopShare",
    value: function checkForStopShare(sendShare, previousShareStatus) {
      if (sendShare && !previousShareStatus) {
        // When user starts sharing
        return _promise.default.resolve(true);
      }
      if (!sendShare && previousShareStatus) {
        // When user stops sharing
        return this.releaseScreenShareFloor().then(function () {
          return _promise.default.resolve(false);
        });
      }
      return _promise.default.resolve();
    }

    /**
     * Update the share streams, can be used to start sharing
     * @param {Object} options
     * @param {boolean} options.sendShare
     * @param {boolean} options.receiveShare
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
  }, {
    key: "updateShare",
    value: function updateShare(options) {
      var _this44 = this;
      if (!options.skipSignalingCheck && !this.canUpdateMedia()) {
        return this.enqueueMediaUpdate(MEDIA_UPDATE_TYPE.SHARE, options);
      }
      var sendShare = options.sendShare,
        receiveShare = options.receiveShare,
        stream = options.stream;
      var shareTransceiver = this.mediaProperties.peerConnection.shareTransceiver;
      var track = _util.default.getTrack(stream).videoTrack;
      if (typeof sendShare !== 'boolean' || typeof receiveShare !== 'boolean') {
        return _promise.default.reject(new _parameter.default('Pass sendShare and receiveShare parameter'));
      }
      var previousSendShareStatus = this.mediaProperties.mediaDirection.sendShare;
      this.setLocalShareTrack(stream);
      return _util.default.validateOptions({
        sendShare: sendShare,
        localShare: stream
      }).then(function () {
        return _this44.checkForStopShare(sendShare, previousSendShareStatus);
      }).then(function (startShare) {
        return _util.default.updateTransceiver({
          type: 'video',
          sendTrack: sendShare,
          receiveTrack: receiveShare,
          track: track,
          transceiver: shareTransceiver,
          peerConnection: _this44.mediaProperties.peerConnection,
          previousMediaDirection: {
            sendTrack: _this44.mediaProperties.mediaDirection.sendShare,
            receiveTrack: _this44.mediaProperties.mediaDirection.receiveShare
          }
        }, {
          mediaProperties: _this44.mediaProperties,
          meeting: _this44,
          id: _this44.id
        }).then(function () {
          if (startShare) {
            return _this44.requestScreenShareFloor();
          }
          return _promise.default.resolve();
        });
      }).then(function () {
        _this44.mediaProperties.mediaDirection.sendShare = sendShare;
        _this44.mediaProperties.mediaDirection.receiveShare = receiveShare;
      }).catch(function (error) {
        _this44.unsetLocalShareTrack();
        throw error;
      }).finally(function () {
        var delay = 1e3;
        // Check to see if share was stopped natively before onended was assigned.
        var sharingModeIsActive = _this44.mediaProperties.peerConnection.shareTransceiver.direction === _constants.SENDRECV;
        var isSharingOutOfSync = sharingModeIsActive && !_this44.isLocalShareLive;
        if (isSharingOutOfSync) {
          // Adding a delay to avoid a 409 from server
          // which results in user still appearing as if sharing.
          // Also delay give time for changes to peerConnection.
          setTimeout(function () {
            return _this44.handleShareTrackEnded(stream);
          }, delay);
        }
      });
    }

    /**
     * Do all the attach media pre set up before executing the actual attach
     * @param {MediaStream} localStream
     * @param {MediaStream} localShare
     * @param {MediaDirection} mediaSettings
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
  }, {
    key: "preMedia",
    value: function preMedia(localStream, localShare, mediaSettings) {
      // eslint-disable-next-line no-warning-comments
      // TODO wire into default config. There's currently an issue with the stateless plugin or how we register
      // @ts-ignore - config coming from registerPlugin
      this.mediaProperties.setMediaDirection((0, _assign.default)(this.config.mediaSettings, mediaSettings));
      // add a setup a function move the create and setup media in future
      // TODO: delete old audio and video if stale
      this.audio = this.audio || (0, _muteState.default)(_constants.AUDIO, this, this.mediaProperties.mediaDirection);
      this.video = this.video || (0, _muteState.default)(_constants.VIDEO, this, this.mediaProperties.mediaDirection);
      // Validation is already done in addMedia so no need to check if the lenght is greater then 0
      this.setLocalTracks(localStream);
      this.setLocalShareTrack(localShare);
    }

    /**
     * Acknowledge the meeting, outgoing or incoming
     * @param {String} type
     * @returns {Promise} resolve {message, ringing, response}
     * @public
     * @memberof Meeting
     */
  }, {
    key: "acknowledge",
    value: function acknowledge(type) {
      var _this45 = this;
      if (!type) {
        return _promise.default.reject(new _parameter.default('Type must be set to acknowledge the meeting.'));
      }
      if (type === _constants._INCOMING_) {
        return this.meetingRequest.acknowledgeMeeting({
          locusUrl: this.locusUrl,
          deviceUrl: this.deviceUrl,
          correlationId: this.correlationId
        }).then(function (response) {
          return _promise.default.resolve(response);
        }).then(function (response) {
          _this45.meetingFiniteStateMachine.ring(type);
          _metrics.default.postEvent({
            event: _config.eventType.ALERT_DISPLAYED,
            meeting: _this45
          });
          return _promise.default.resolve({
            response: response
          });
        });
      }

      // TODO: outside of 1:1 incoming, and all outgoing calls
      return _promise.default.resolve({
        message: 'noop'
      });
    }

    /**
     * Decline this meeting
     * @param {String} reason
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */
  }, {
    key: "decline",
    value: function decline(reason) {
      var _this46 = this;
      return _util.default.declineMeeting(this, reason).then(function (decline) {
        _this46.meetingFiniteStateMachine.decline();
        return _promise.default.resolve(decline);
      }).catch(function (error) {
        _this46.meetingFiniteStateMachine.fail(error);
        return _promise.default.reject(error);
      });
    }

    /**
     * Leave the current meeting
     * @param {Object} options leave options
     * @param {String} options.resourceId the device with which to leave from, empty if just the computer
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
  }, {
    key: "leave",
    value: function leave() {
      var _this47 = this;
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _metrics.default.postEvent({
        event: _config.eventType.LEAVE,
        meeting: this,
        data: {
          trigger: _config.trigger.USER_INTERACTION,
          canProceed: false
        }
      });
      var leaveReason = options.reason || _constants.MEETING_REMOVED_REASON.CLIENT_LEAVE_REQUEST;
      _loggerProxy.default.logger.log('Meeting:index#leave --> Leaving a meeting');
      return _util.default.leaveMeeting(this, options).then(function (leave) {
        _this47.meetingFiniteStateMachine.leave();
        _this47.clearMeetingData();

        // upload logs on leave irrespective of meeting delete
        _triggerProxy.default.trigger(_this47, {
          file: 'meeting/index',
          function: 'leave'
        }, _constants.EVENTS.REQUEST_UPLOAD_LOGS, _this47);

        // TODO: more testing before we remove this code, we are not sure the scenarios for destroy here
        if (_this47.wirelessShare || _this47.guest) {
          // If screen sharing clean the meeting object
          _triggerProxy.default.trigger(_this47, {
            file: 'meeting/index',
            function: 'leave'
          }, _constants.EVENTS.DESTROY_MEETING, {
            reason: options.reason,
            meetingId: _this47.id
          });
        }
        _loggerProxy.default.logger.log('Meeting:index#leave --> LEAVE REASON ', leaveReason);
        return leave;
      }).catch(function (error) {
        _this47.meetingFiniteStateMachine.fail(error);
        _loggerProxy.default.logger.error('Meeting:index#leave --> Failed to leave ', error);
        // upload logs on leave irrespective of meeting delete
        _triggerProxy.default.trigger(_this47, {
          file: 'meeting/index',
          function: 'leave'
        }, _constants.EVENTS.REQUEST_UPLOAD_LOGS, _this47);
        _metrics.default.sendBehavioralMetric(_constants2.default.MEETING_LEAVE_FAILURE, {
          correlation_id: _this47.correlationId,
          locus_id: _this47.locusUrl.split('/').pop(),
          reason: error.message,
          stack: error.stack,
          code: error.code
        });
        return _promise.default.reject(error);
      });
    }

    /**
     * Start sharing whiteboard given channelUrl
     * @param {string} channelUrl whiteboard url
     * @param {String} resourceToken token created by authorize media injector
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
  }, {
    key: "startWhiteboardShare",
    value: function startWhiteboardShare(channelUrl, resourceToken) {
      var _this48 = this;
      var whiteboard = this.locusInfo.mediaShares.find(function (element) {
        return element.name === 'whiteboard';
      });
      if (!channelUrl) {
        return _promise.default.reject(new _parameter.default('Cannot share without channelUrl.'));
      }
      if (whiteboard) {
        _metrics.default.postEvent({
          event: _config.eventType.WHITEBOARD_SHARE_INITIATED,
          meeting: this
        });
        var body = {
          disposition: _constants.FLOOR_ACTION.GRANTED,
          personUrl: this.locusInfo.self.url,
          deviceUrl: this.deviceUrl,
          uri: whiteboard.url,
          resourceUrl: channelUrl
        };
        if (resourceToken) {
          body.resourceToken = resourceToken;
        }
        return this.meetingRequest.changeMeetingFloor(body).then(function () {
          _this48.isSharing = false;
          return _promise.default.resolve();
        }).catch(function (error) {
          _loggerProxy.default.logger.error('Meeting:index#startWhiteboardShare --> Error ', error);
          _metrics.default.sendBehavioralMetric(_constants2.default.MEETING_START_WHITEBOARD_SHARE_FAILURE, {
            correlation_id: _this48.correlationId,
            locus_id: _this48.locusUrl.split('/').pop(),
            reason: error.message,
            stack: error.stack,
            board: {
              channelUrl: channelUrl
            }
          });
          return _promise.default.reject(error);
        });
      }
      return _promise.default.reject(new _parameter.default('Cannot share without whiteboard.'));
    }

    /**
     * Stop sharing whiteboard given channelUrl
     * @param {string} channelUrl whiteboard url
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
  }, {
    key: "stopWhiteboardShare",
    value: function stopWhiteboardShare(channelUrl) {
      var _this49 = this;
      var whiteboard = this.locusInfo.mediaShares.find(function (element) {
        return element.name === 'whiteboard';
      });
      if (whiteboard) {
        _metrics.default.postEvent({
          event: _config.eventType.WHITEBOARD_SHARE_STOPPED,
          meeting: this
        });
        return this.meetingRequest.changeMeetingFloor({
          disposition: _constants.FLOOR_ACTION.RELEASED,
          personUrl: this.locusInfo.self.url,
          deviceUrl: this.deviceUrl,
          uri: whiteboard.url
        }).catch(function (error) {
          _loggerProxy.default.logger.error('Meeting:index#stopWhiteboardShare --> Error ', error);
          _metrics.default.sendBehavioralMetric(
          // @ts-ignore - check if STOP_WHITEBOARD_SHARE_FAILURE exists
          _constants2.default.STOP_WHITEBOARD_SHARE_FAILURE, {
            correlation_id: _this49.correlationId,
            locus_id: _this49.locusUrl.split('/').pop(),
            reason: error.message,
            stack: error.stack,
            board: {
              channelUrl: channelUrl
            }
          });
          return _promise.default.reject(error);
        }).finally(function () {});
      }
      return _promise.default.reject(new _parameter.default('Cannot stop share without whiteboard.'));
    }

    /**
     * Sends a request to Locus to obtain the screen share floor
     * @returns {Promise} see #meetingRequest.changeMeetingFloor
     * @private
     * @memberof Meeting
     */
  }, {
    key: "requestScreenShareFloor",
    value: function requestScreenShareFloor() {
      var _this50 = this;
      var content = this.locusInfo.mediaShares.find(function (element) {
        return element.name === _constants.CONTENT;
      });
      if (content && this.shareStatus !== _constants.SHARE_STATUS.LOCAL_SHARE_ACTIVE) {
        _metrics.default.postEvent({
          event: _config.eventType.SHARE_INITIATED,
          meeting: this
        });
        return this.meetingRequest.changeMeetingFloor({
          disposition: _constants.FLOOR_ACTION.GRANTED,
          personUrl: this.locusInfo.self.url,
          deviceUrl: this.deviceUrl,
          uri: content.url,
          resourceUrl: this.resourceUrl
        }).then(function () {
          _this50.isSharing = true;
          return _promise.default.resolve();
        }).catch(function (error) {
          _loggerProxy.default.logger.error('Meeting:index#share --> Error ', error);
          _metrics.default.sendBehavioralMetric(_constants2.default.MEETING_SHARE_FAILURE, {
            correlation_id: _this50.correlationId,
            locus_id: _this50.locusUrl.split('/').pop(),
            reason: error.message,
            stack: error.stack
          });
          return _promise.default.reject(error);
        });
      }
      return _promise.default.reject(new _parameter.default('Cannot share without content.'));
    }

    /**
     * Stops the screen share
     * @returns {Promise} see #updateShare
     * @public
     * @memberof Meeting
     */
    // Internal only, temporarily allows optional params
    // eslint-disable-next-line valid-jsdoc
  }, {
    key: "stopShare",
    value: function stopShare() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this.updateShare(_objectSpread({
        sendShare: false,
        receiveShare: this.mediaProperties.mediaDirection.receiveShare
      }, options));
    }

    /**
     * Sends a request to Locus to release the screen share floor.
     * @returns {Promise} see #meetingRequest.changeMeetingFloor
     * @private
     * @memberof Meeting
     */
  }, {
    key: "releaseScreenShareFloor",
    value: function releaseScreenShareFloor() {
      var _this51 = this;
      var content = this.locusInfo.mediaShares.find(function (element) {
        return element.name === _constants.CONTENT;
      });
      if (content && this.mediaProperties.mediaDirection.sendShare) {
        _metrics.default.postEvent({
          event: _config.eventType.SHARE_STOPPED,
          meeting: this
        });
        _media.default.stopTracks(this.mediaProperties.shareTrack);
        if (content.floor.beneficiary.id !== this.selfId) {
          // remote participant started sharing and caused our sharing to stop, we don't want to send any floor action request in that case
          this.isSharing = false;
          return _promise.default.resolve();
        }
        return this.meetingRequest.changeMeetingFloor({
          disposition: _constants.FLOOR_ACTION.RELEASED,
          personUrl: this.locusInfo.self.url,
          deviceUrl: this.deviceUrl,
          uri: content.url,
          resourceUrl: this.resourceUrl
        }).catch(function (error) {
          _loggerProxy.default.logger.error('Meeting:index#releaseScreenShareFloor --> Error ', error);
          _metrics.default.sendBehavioralMetric(_constants2.default.STOP_FLOOR_REQUEST_FAILURE, {
            correlation_id: _this51.correlationId,
            locus_id: _this51.locusUrl.split('/').pop(),
            reason: error.message,
            stack: error.stack
          });
          return _promise.default.reject(error);
        }).finally(function () {
          _this51.isSharing = false;
        });
      }
      return _promise.default.reject(new _parameter.default('Cannot stop share without content'));
    }

    /**
     * Intiate a recording of this meeting
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
  }, {
    key: "startRecording",
    value: function startRecording() {
      return this.recordingController.startRecording();
    }

    /**
     * set the mute on entry flag for participants if you're the host
     * @returns {Promise}
     * @param {boolean} enabled
     * @public
     * @memberof Meeting
     */
  }, {
    key: "setMuteOnEntry",
    value: function setMuteOnEntry(enabled) {
      return this.controlsOptionsManager.setMuteOnEntry(enabled);
    }

    /**
     * set the disallow unmute flag for participants if you're the host
     * @returns {Promise}
     * @param {boolean} enabled
     * @public
     * @memberof Meeting
     */
  }, {
    key: "setDisallowUnmute",
    value: function setDisallowUnmute(enabled) {
      return this.controlsOptionsManager.setDisallowUnmute(enabled);
    }

    /**
     * End the recording of this meeting
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
  }, {
    key: "stopRecording",
    value: function stopRecording() {
      return this.recordingController.stopRecording();
    }

    /**
     * Pauses the recording of this meeting
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
  }, {
    key: "pauseRecording",
    value: function pauseRecording() {
      return this.recordingController.pauseRecording();
    }

    /**
     * Resumes the recording of this meeting
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
  }, {
    key: "resumeRecording",
    value: function resumeRecording() {
      return this.recordingController.resumeRecording();
    }

    /**
     * Locks the current meeting if possible
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
  }, {
    key: "lockMeeting",
    value: function lockMeeting() {
      return _util.default.lockMeeting(this.inMeetingActions, this.meetingRequest, this.locusUrl);
    }

    /**
     * Unlocks the current meeting if possible
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
  }, {
    key: "unlockMeeting",
    value: function unlockMeeting() {
      return _util.default.unlockMeeting(this.inMeetingActions, this.meetingRequest, this.locusUrl);
    }

    /**
     * Logs an error message and returns a rejected promise with same message
     * @param {String} message
     * @returns {Promise}
     * @private
     * @memberof Meeting
     */
  }, {
    key: "rejectWithErrorLog",
    value: function rejectWithErrorLog(message) {
      _loggerProxy.default.logger.error(message);
      return _promise.default.reject(new Error(message));
    }

    /**
     * Sends DTMF tones to the current meeting
     * @param {String} tones a string of one or more DTMF tones to send
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
  }, {
    key: "sendDTMF",
    value: function sendDTMF(tones) {
      if (this.locusInfo && this.locusInfo.self) {
        if (this.locusInfo.self.enableDTMF) {
          return this.meetingRequest.sendDTMF({
            locusUrl: this.locusInfo.self.url,
            deviceUrl: this.deviceUrl,
            tones: tones
          });
        }
        return this.rejectWithErrorLog('Meeting:index#sendDTMF --> cannot send DTMF, meeting does not have DTMF enabled');
      }
      return this.rejectWithErrorLog('Meeting:index#sendDTMF --> cannot send DTMF, meeting does not have a connection to the "locus" call control service. Have you joined?');
    }

    /**
     * Sends request to change layout type for the current meeting for the specific participant/device only
     * @param {String} [layoutType] a layout type that should be available in meeting constants {@link #layout_types}
     * @param {Object} renderInfo preferred dimensions for the remote main and content streams (server can ignore it)
     * @param {Object} renderInfo.main preferred dimensions for the remote main video stream
     * @param {Number} renderInfo.main.width preferred width of main video stream
     * @param {Number} renderInfo.main.height preferred height of main video stream
     * @param {Object} renderInfo.content preferred dimensions for the remote content share stream
     * @param {Number} renderInfo.content.width preferred width of content share stream
     * @param {Number} renderInfo.content.height preferred height of content share stream
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
  }, {
    key: "changeVideoLayout",
    value: function changeVideoLayout(layoutType) {
      var _this52 = this;
      var renderInfo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var main = renderInfo.main,
        content = renderInfo.content;
      var _this$mediaProperties5 = this.mediaProperties,
        mediaDirection = _this$mediaProperties5.mediaDirection,
        remoteShare = _this$mediaProperties5.remoteShare,
        remoteVideoTrack = _this$mediaProperties5.remoteVideoTrack;
      var layoutInfo = (0, _cloneDeep2.default)(this.lastVideoLayoutInfo);

      // TODO: We need a real time value for Audio, Video and Share send indicator
      if (mediaDirection.receiveVideo !== true || !remoteVideoTrack) {
        return this.rejectWithErrorLog('Meeting:index#changeVideoLayout --> cannot change video layout, you are not recieving any video/share stream');
      }
      if (layoutType) {
        if (!_constants.LAYOUT_TYPES.includes(layoutType)) {
          return this.rejectWithErrorLog('Meeting:index#changeVideoLayout --> cannot change video layout, invalid layoutType received.');
        }
        layoutInfo.layoutType = layoutType;
      }
      if (main) {
        var mainWidth = Math.round(main.width);
        var mainHeight = Math.round(main.height);

        // Stop any "twitching" caused by very slight size changes
        if (!this.lastVideoLayoutInfo.main || Math.abs(this.lastVideoLayoutInfo.main.height - mainHeight) > 2 || Math.abs(this.lastVideoLayoutInfo.main.width - mainWidth) > 2) {
          layoutInfo.main = {
            width: mainWidth,
            height: mainHeight
          };
        }
      }
      if (content) {
        if (this.mediaProperties.mediaDirection.receiveShare && remoteShare) {
          var contentWidth = Math.round(content.width);
          var contentHeight = Math.round(content.height);

          // Stop any "twitching" caused by very slight size changes
          if (!this.lastVideoLayoutInfo.content || Math.abs(this.lastVideoLayoutInfo.content.height - contentHeight) > 2 || Math.abs(this.lastVideoLayoutInfo.content.width - contentWidth) > 2) {
            layoutInfo.content = {
              width: contentWidth,
              height: contentHeight
            };
          }
        } else {
          return this.rejectWithErrorLog('Meeting:index#changeVideoLayout --> unable to send renderInfo for content, you are not receiving remote share');
        }
      }
      if ((0, _isEqual2.default)(layoutInfo, this.lastVideoLayoutInfo)) {
        // nothing changed, no need to send any request
        return _promise.default.resolve();
      }
      this.lastVideoLayoutInfo = (0, _cloneDeep2.default)(layoutInfo);
      this.locusInfo.once(_constants.LOCUSINFO.EVENTS.CONTROLS_MEETING_LAYOUT_UPDATED, function (envelope) {
        _triggerProxy.default.trigger(_this52, {
          file: 'meeting/index',
          function: 'changeVideoLayout'
        }, _constants.EVENT_TRIGGERS.MEETING_CONTROLS_LAYOUT_UPDATE, {
          layout: envelope.layout
        });
      });
      return this.meetingRequest.changeVideoLayoutDebounced({
        locusUrl: this.locusInfo.self.url,
        deviceUrl: this.deviceUrl,
        layoutType: layoutType,
        main: layoutInfo.main,
        content: layoutInfo.content
      }).then(function (response) {
        if (response && response.body && response.body.locus) {
          _this52.locusInfo.onFullLocus(response.body.locus);
        }
      }).catch(function (error) {
        _loggerProxy.default.logger.error('Meeting:index#changeVideoLayout --> Error ', error);
        return _promise.default.reject(error);
      });
    }

    /**
     * Sets the quality of the local video stream
     * @param {String} level {LOW|MEDIUM|HIGH}
     * @returns {Promise<MediaStream>} localStream
     */
  }, {
    key: "setLocalVideoQuality",
    value: function setLocalVideoQuality(level) {
      var _this53 = this;
      _loggerProxy.default.logger.log("Meeting:index#setLocalVideoQuality --> Setting quality to ".concat(level));
      if (!_constants.VIDEO_RESOLUTIONS[level]) {
        return this.rejectWithErrorLog("Meeting:index#setLocalVideoQuality --> ".concat(level, " not defined"));
      }
      if (!this.mediaProperties.mediaDirection.sendVideo) {
        return this.rejectWithErrorLog('Meeting:index#setLocalVideoQuality --> unable to change video quality, sendVideo is disabled');
      }

      // If level is already the same, don't do anything
      if (level === this.mediaProperties.localQualityLevel) {
        _loggerProxy.default.logger.warn("Meeting:index#setLocalQualityLevel --> Quality already set to ".concat(level));
        return _promise.default.resolve();
      }

      // Set the quality level in properties
      this.mediaProperties.setLocalQualityLevel(level);
      var mediaDirection = {
        sendAudio: this.mediaProperties.mediaDirection.sendAudio,
        sendVideo: this.mediaProperties.mediaDirection.sendVideo,
        sendShare: this.mediaProperties.mediaDirection.sendShare
      };

      // When changing local video quality level
      // Need to stop current track first as chrome doesn't support resolution upscaling(for eg. changing 480p to 720p)
      // Without feeding it a new track
      // open bug link: https://bugs.chromium.org/p/chromium/issues/detail?id=943469
      if (isBrowser('chrome') && this.mediaProperties.videoTrack) _media.default.stopTracks(this.mediaProperties.videoTrack);
      return this.getMediaStreams(mediaDirection, _constants.VIDEO_RESOLUTIONS[level]).then( /*#__PURE__*/function () {
        var _ref15 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee7(_ref14) {
          var _ref16, localStream;
          return _regenerator.default.wrap(function _callee7$(_context7) {
            while (1) switch (_context7.prev = _context7.next) {
              case 0:
                _ref16 = (0, _slicedToArray2.default)(_ref14, 1), localStream = _ref16[0];
                _context7.next = 3;
                return _this53.updateVideo({
                  sendVideo: true,
                  receiveVideo: true,
                  stream: localStream
                });
              case 3:
                return _context7.abrupt("return", localStream);
              case 4:
              case "end":
                return _context7.stop();
            }
          }, _callee7);
        }));
        return function (_x5) {
          return _ref15.apply(this, arguments);
        };
      }());
    }

    /**
     * Sets the quality level of the remote incoming media
     * @param {String} level {LOW|MEDIUM|HIGH}
     * @returns {Promise}
     */
  }, {
    key: "setRemoteQualityLevel",
    value: function setRemoteQualityLevel(level) {
      _loggerProxy.default.logger.log("Meeting:index#setRemoteQualityLevel --> Setting quality to ".concat(level));
      if (!_constants.QUALITY_LEVELS[level]) {
        return this.rejectWithErrorLog("Meeting:index#setRemoteQualityLevel --> ".concat(level, " not defined"));
      }
      if (!this.mediaProperties.mediaDirection.receiveAudio && !this.mediaProperties.mediaDirection.receiveVideo) {
        return this.rejectWithErrorLog('Meeting:index#setRemoteQualityLevel --> unable to change remote quality, receiveVideo and receiveAudio is disabled');
      }

      // If level is already the same, don't do anything
      if (level === this.mediaProperties.remoteQualityLevel) {
        _loggerProxy.default.logger.warn("Meeting:index#setRemoteQualityLevel --> Quality already set to ".concat(level));
        return _promise.default.resolve();
      }

      // Set the quality level in properties
      this.mediaProperties.setRemoteQualityLevel(level);
      return this.updateMedia({
        mediaSettings: this.mediaProperties.mediaDirection
      });
    }

    /**
     * This is deprecated, please use setLocalVideoQuality for setting local and setRemoteQualityLevel for remote
     * @param {String} level {LOW|MEDIUM|HIGH}
     * @returns {Promise}
     * @deprecated After FHD support
     */
  }, {
    key: "setMeetingQuality",
    value: function setMeetingQuality(level) {
      var _this54 = this;
      _loggerProxy.default.logger.log("Meeting:index#setMeetingQuality --> Setting quality to ".concat(level));
      if (!_constants.QUALITY_LEVELS[level]) {
        return this.rejectWithErrorLog("Meeting:index#setMeetingQuality --> ".concat(level, " not defined"));
      }
      var previousLevel = {
        local: this.mediaProperties.localQualityLevel,
        remote: this.mediaProperties.remoteQualityLevel
      };

      // If level is already the same, don't do anything
      if (level === this.mediaProperties.localQualityLevel && level === this.mediaProperties.remoteQualityLevel) {
        _loggerProxy.default.logger.warn("Meeting:index#setMeetingQuality --> Quality already set to ".concat(level));
        return _promise.default.resolve();
      }

      // Determine the direction of our current media
      var _this$mediaProperties6 = this.mediaProperties.mediaDirection,
        receiveAudio = _this$mediaProperties6.receiveAudio,
        receiveVideo = _this$mediaProperties6.receiveVideo,
        sendVideo = _this$mediaProperties6.sendVideo;
      return (sendVideo ? this.setLocalVideoQuality(level) : _promise.default.resolve()).then(function () {
        return receiveAudio || receiveVideo ? _this54.setRemoteQualityLevel(level) : _promise.default.resolve();
      }).catch(function (error) {
        // From troubleshooting it seems that the stream itself doesn't change the max-fs if the peer connection isn't stable
        _this54.mediaProperties.setLocalQualityLevel(previousLevel.local);
        _this54.mediaProperties.setRemoteQualityLevel(previousLevel.remote);
        _loggerProxy.default.logger.error("Meeting:index#setMeetingQuality --> ".concat(error.message));
        _metrics.default.sendBehavioralMetric(_constants2.default.SET_MEETING_QUALITY_FAILURE, {
          correlation_id: _this54.correlationId,
          locus_id: _this54.locusUrl.split('/').pop(),
          reason: error.message,
          stack: error.stack
        }, {
          type: error.name
        });
        return _promise.default.reject(error);
      });
    }

    /**
     * @param {Object} options parameter
     * @param {Boolean} options.sendAudio send audio from the display share
     * @param {Boolean} options.sendShare send video from the display share
     * @param {Object} options.sharePreferences
     * @param {MediaTrackConstraints} options.sharePreferences.shareConstraints constraints to apply to video
     *   @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints}
     * @param {Boolean} options.sharePreferences.highFrameRate if shareConstraints isn't provided, set default values based off of this boolean
     * @returns {Promise}
     */
  }, {
    key: "shareScreen",
    value: function shareScreen() {
      var _this55 = this;
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _loggerProxy.default.logger.log('Meeting:index#shareScreen --> Getting local share');
      var shareConstraints = _objectSpread({
        sendShare: true,
        sendAudio: false
      }, options);

      // @ts-ignore - config coming from registerPlugin
      return _media.default.getDisplayMedia(shareConstraints, this.config).then(function (shareStream) {
        return _this55.updateShare({
          sendShare: true,
          receiveShare: _this55.mediaProperties.mediaDirection.receiveShare,
          stream: shareStream
        });
      }).catch(function (error) {
        // Whenever there is a failure when trying to access a user's display
        // report it as an Behavioral metric
        // This gives visibility into common errors and can help
        // with further troubleshooting

        // This metrics will get erros for getDisplayMedia and share errors for now
        // TODO: The getDisplayMedia errors need to be moved inside `media.getDisplayMedia`
        var metricName = _constants2.default.GET_DISPLAY_MEDIA_FAILURE;
        var data = {
          correlation_id: _this55.correlationId,
          locus_id: _this55.locusUrl.split('/').pop(),
          reason: error.message,
          stack: error.stack
        };
        var metadata = {
          type: error.name
        };
        _metrics.default.sendBehavioralMetric(metricName, data, metadata);
        throw new _media2.default('Unable to retrieve display media stream', error);
      });
    }

    /**
     * Functionality for when a share is ended.
     * @private
     * @memberof Meeting
     * @param {MediaStream} localShare
     * @returns {undefined}
     */
  }, {
    key: "handleShareTrackEnded",
    value: function handleShareTrackEnded(localShare) {
      if (this.wirelessShare) {
        this.leave({
          reason: _constants.MEETING_REMOVED_REASON.USER_ENDED_SHARE_STREAMS
        });
      } else {
        // Skip checking for a stable peerConnection
        // to allow immediately stopping screenshare
        this.stopShare({
          skipSignalingCheck: true
        }).catch(function (error) {
          _loggerProxy.default.logger.log('Meeting:index#handleShareTrackEnded --> Error stopping share: ', error);
        });
      }
      _triggerProxy.default.trigger(this, {
        file: 'meeting/index',
        function: 'handleShareTrackEnded'
      }, _constants.EVENT_TRIGGERS.MEETING_STOPPED_SHARING_LOCAL, {
        type: _constants.EVENT_TYPES.LOCAL_SHARE,
        stream: localShare
      });
    }

    /**
     * Emits the 'network:quality' event
     * 1 indicates an acceptable uplink network.
     * 0 indicates an unacceptable uplink network based on a predefined threshold
     * @returns {undefined}
     * @param {Object} res - payload of emitNetworkQuality
     * @property {string} mediaType {video|audio}
     * @property {number} networkQualityScore - {1|0}
     * @private
     * @memberof Meeting
     */
  }, {
    key: "sendNetworkQualityEvent",
    value: function sendNetworkQualityEvent(res) {
      _triggerProxy.default.trigger(this, {
        file: 'meeting/index',
        function: 'addMedia'
      }, _constants.EVENT_TRIGGERS.NETWORK_QUALITY, {
        networkQualityScore: res.networkQualityScore,
        mediaType: res.mediaType
      });
    }

    /**
     * Handle logging the media
     * @param {Object} audioTrack The audio track
     * @param {Object} videoTrack The video track
     * @private
     * @returns {undefined}
     */
  }, {
    key: "handleMediaLogging",
    value: function handleMediaLogging(_ref17) {
      var audioTrack = _ref17.audioTrack,
        videoTrack = _ref17.videoTrack;
      _util.default.handleVideoLogging(videoTrack);
      _util.default.handleAudioLogging(audioTrack);
    }

    /**
     * @param {string} typeMedia 'audio' or 'video'
     * @returns {undefined}
     */
  }, {
    key: "setStartSetupDelay",
    value: function setStartSetupDelay(typeMedia) {
      this["startSetupDelay".concat(typeMedia)] = performance.now();
      this["endSetupDelay".concat(typeMedia)] = undefined;
    }

    /**
     * @param {string} typeMedia 'audio' or 'video'
     * @returns {undefined}
     */
  }, {
    key: "setEndSetupDelay",
    value: function setEndSetupDelay(typeMedia) {
      this["endSetupDelay".concat(typeMedia)] = performance.now();
    }

    /**
     * @param {string} typeMedia 'audio' or 'video'
     * @returns {string} duration between start and end of setup
     */
  }, {
    key: "getSetupDelayDuration",
    value: function getSetupDelayDuration(typeMedia) {
      var start = this["startSetupDelay".concat(typeMedia)];
      var end = this["endSetupDelay".concat(typeMedia)];
      return start && end ? end - start : undefined;
    }

    /**
     * @param {string} typeMedia 'audio' or 'video'
     * @returns {undefined}
     */
  }, {
    key: "setStartSendingMediaDelay",
    value: function setStartSendingMediaDelay(typeMedia) {
      this["startSendingMediaDelay".concat(typeMedia)] = performance.now();
      this["endSendingMediaDelay".concat(typeMedia)] = undefined;
    }

    /**
     * @param {string} typeMedia 'audio' or 'video'
     * @returns {undefined}
     */
  }, {
    key: "setEndSendingMediaDelay",
    value: function setEndSendingMediaDelay(typeMedia) {
      this["endSendingMediaDelay".concat(typeMedia)] = performance.now();
    }

    /**
     * @param {string} typeMedia 'audio' or 'video'
     * @returns {string} duration between join response and first media tx
     */
  }, {
    key: "getSendingMediaDelayDuration",
    value: function getSendingMediaDelayDuration(typeMedia) {
      var start = this["startSendingMediaDelay".concat(typeMedia)];
      var end = this["endSendingMediaDelay".concat(typeMedia)];
      return start && end ? end - start : undefined;
    }

    /**
     *
     * @returns {undefined}
     */
  }, {
    key: "setStartLocalSDPGenRemoteSDPRecvDelay",
    value: function setStartLocalSDPGenRemoteSDPRecvDelay() {
      if (!this.startLocalSDPGenRemoteSDPRecvDelay) {
        this.startLocalSDPGenRemoteSDPRecvDelay = performance.now();
        this.endLocalSDPGenRemoteSDPRecvDelay = undefined;
      }
    }

    /**
     *
     * @returns {undefined}
     */
  }, {
    key: "setEndLocalSDPGenRemoteSDPRecvDelay",
    value: function setEndLocalSDPGenRemoteSDPRecvDelay() {
      if (!this.endLocalSDPGenRemoteSDPRecvDelay) {
        this.endLocalSDPGenRemoteSDPRecvDelay = performance.now();
      }
    }

    /**
     *
     * @returns {string} duration between local SDP generation and remote SDP reception
     */
  }, {
    key: "getLocalSDPGenRemoteSDPRecvDelay",
    value: function getLocalSDPGenRemoteSDPRecvDelay() {
      var start = this.startLocalSDPGenRemoteSDPRecvDelay;
      var end = this.endLocalSDPGenRemoteSDPRecvDelay;
      if (start && end) {
        var calculatedDelay = end - start;
        return calculatedDelay > _constants.METRICS_JOIN_TIMES_MAX_DURATION ? undefined : calculatedDelay;
      }
      return undefined;
    }

    /**
     *
     * @returns {undefined}
     */
  }, {
    key: "setStartCallInitiateJoinReq",
    value: function setStartCallInitiateJoinReq() {
      this.startCallInitiateJoinReq = performance.now();
      this.endCallInitiateJoinReq = undefined;
    }

    /**
     *
     * @returns {undefined}
     */
  }, {
    key: "setEndCallInitiateJoinReq",
    value: function setEndCallInitiateJoinReq() {
      this.endCallInitiateJoinReq = performance.now();
    }

    /**
     *
     * @returns {string} duration between call initiate and sending join request to locus
     */
  }, {
    key: "getCallInitiateJoinReq",
    value: function getCallInitiateJoinReq() {
      var start = this.startCallInitiateJoinReq;
      var end = this.endCallInitiateJoinReq;
      if (start && end) {
        var calculatedDelay = end - start;
        return calculatedDelay > _constants.METRICS_JOIN_TIMES_MAX_DURATION ? undefined : calculatedDelay;
      }
      return undefined;
    }

    /**
     *
     * @returns {undefined}
     */
  }, {
    key: "setStartJoinReqResp",
    value: function setStartJoinReqResp() {
      this.startJoinReqResp = performance.now();
      this.endJoinReqResp = undefined;
    }

    /**
     *
     * @returns {undefined}
     */
  }, {
    key: "setEndJoinReqResp",
    value: function setEndJoinReqResp() {
      this.endJoinReqResp = performance.now();
    }

    /**
     *
     * @returns {string} duration between sending locus join request and receiving join response
     */
  }, {
    key: "getJoinReqResp",
    value: function getJoinReqResp() {
      var start = this.startJoinReqResp;
      var end = this.endJoinReqResp;
      if (start && end) {
        var calculatedDelay = end - start;
        return calculatedDelay > _constants.METRICS_JOIN_TIMES_MAX_DURATION ? undefined : calculatedDelay;
      }
      return undefined;
    }

    /**
     *
     * @returns {string} duration between call initiate and successful locus join (even if it is in lobby)
     */
  }, {
    key: "getTotalJmt",
    value: function getTotalJmt() {
      var start = this.startCallInitiateJoinReq;
      var end = this.endJoinReqResp;
      return start && end ? end - start : undefined;
    }

    /**
     * End the current meeting for all
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
  }, {
    key: "endMeetingForAll",
    value: function endMeetingForAll() {
      var _this56 = this;
      _metrics.default.postEvent({
        event: _config.eventType.LEAVE,
        meeting: this,
        data: {
          trigger: _config.trigger.USER_INTERACTION,
          canProceed: false
        }
      });
      _loggerProxy.default.logger.log('Meeting:index#endMeetingForAll --> End meeting for All');
      _metrics.default.sendBehavioralMetric(_constants2.default.MEETING_END_ALL_INITIATED, {
        correlation_id: this.correlationId,
        locus_id: this.locusId
      });
      return _util.default.endMeetingForAll(this).then(function (end) {
        _this56.meetingFiniteStateMachine.end();
        _this56.clearMeetingData();
        // upload logs on leave irrespective of meeting delete
        _triggerProxy.default.trigger(_this56, {
          file: 'meeting/index',
          function: 'endMeetingForAll'
        }, _constants.EVENTS.REQUEST_UPLOAD_LOGS, _this56);
        return end;
      }).catch(function (error) {
        _this56.meetingFiniteStateMachine.fail(error);
        _loggerProxy.default.logger.error('Meeting:index#endMeetingForAll --> Failed to end meeting ', error);
        // upload logs on leave irrespective of meeting delete
        _triggerProxy.default.trigger(_this56, {
          file: 'meeting/index',
          function: 'endMeetingForAll'
        }, _constants.EVENTS.REQUEST_UPLOAD_LOGS, _this56);
        _metrics.default.sendBehavioralMetric(_constants2.default.MEETING_END_ALL_FAILURE, {
          correlation_id: _this56.correlationId,
          locus_id: _this56.locusUrl.split('/').pop(),
          reason: error.message,
          stack: error.stack,
          code: error.code
        });
        return _promise.default.reject(error);
      });
    }
  }, {
    key: "isBnrEnabled",
    value:
    /**
     * Internal API to return status of BNR
     * @returns {Boolean}
     * @public
     * @memberof Meeting
     */
    function isBnrEnabled() {
      return this.effects && this.effects.isBnrEnabled();
    }

    /**
     * Internal API to obtain BNR enabled MediaStream
     * @returns {Promise<MediaStreamTrack>}
     * @private
     * @param {MedaiStreamTrack} audioTrack from updateAudio
     * @memberof Meeting
     */
  }, {
    key: "internal_enableBNR",
    value: function () {
      var _internal_enableBNR = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee8(audioTrack) {
        var bnrAudioTrack;
        return _regenerator.default.wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              _context8.prev = 0;
              _loggerProxy.default.logger.info('Meeting:index#internal_enableBNR. Internal enable BNR called');
              _context8.next = 4;
              return _internalMediaCore.Media.Effects.BNR.enableBNR(audioTrack);
            case 4:
              bnrAudioTrack = _context8.sent;
              _loggerProxy.default.logger.info('Meeting:index#internal_enableBNR. BNR enabled track obtained from WebRTC & returned as stream');
              return _context8.abrupt("return", bnrAudioTrack);
            case 9:
              _context8.prev = 9;
              _context8.t0 = _context8["catch"](0);
              _loggerProxy.default.logger.error('Meeting:index#internal_enableBNR.', _context8.t0);
              throw _context8.t0;
            case 13:
            case "end":
              return _context8.stop();
          }
        }, _callee8, null, [[0, 9]]);
      }));
      function internal_enableBNR(_x6) {
        return _internal_enableBNR.apply(this, arguments);
      }
      return internal_enableBNR;
    }()
    /**
     * Enable the audio track with BNR for a meeting
     * @returns {Promise} resolves the data from enable bnr or rejects if there is no audio or audio is muted
     * @public
     * @memberof Meeting
     */
  }, {
    key: "enableBNR",
    value: function enableBNR() {
      if (typeof this.mediaProperties === 'undefined' || typeof this.mediaProperties.audioTrack === 'undefined') {
        return _promise.default.reject(new Error("Meeting doesn't have an audioTrack attached"));
      }
      if (this.isAudioMuted()) {
        return _promise.default.reject(new Error('Cannot enable BNR while meeting is muted'));
      }
      this.effects = this.effects || (0, _effectsState.default)('BNR');
      var LOG_HEADER = 'Meeting:index#enableBNR -->';
      return logRequest(this.effects.handleClientRequest(true, this).then(function (res) {
        _loggerProxy.default.logger.info('Meeting:index#enableBNR. Enable bnr completed');
        return res;
      }).catch(function (error) {
        throw error;
      }), {
        header: "".concat(LOG_HEADER, " enable bnr"),
        success: "".concat(LOG_HEADER, " enable bnr success"),
        failure: "".concat(LOG_HEADER, " enable bnr failure, ")
      });
    }

    /**
     * Disable the BNR for an audio track
     * @returns {Promise} resolves the data from disable bnr or rejects if there is no audio set
     * @public
     * @memberof Meeting
     */
  }, {
    key: "disableBNR",
    value: function disableBNR() {
      if (typeof this.mediaProperties === 'undefined' || typeof this.mediaProperties.audioTrack === 'undefined') {
        return _promise.default.reject(new Error("Meeting doesn't have an audioTrack attached"));
      }
      if (!this.isBnrEnabled()) {
        return _promise.default.reject(new Error('Can not disable as BNR is not enabled'));
      }
      this.effects = this.effects || (0, _effectsState.default)('BNR');
      var LOG_HEADER = 'Meeting:index#disableBNR -->';
      return logRequest(this.effects.handleClientRequest(false, this).then(function (res) {
        _loggerProxy.default.logger.info('Meeting:index#disableBNR. Disable bnr completed');
        return res;
      }).catch(function (error) {
        throw error;
      }), {
        header: "".concat(LOG_HEADER, " disable bnr"),
        success: "".concat(LOG_HEADER, " disable bnr success"),
        failure: "".concat(LOG_HEADER, " disable bnr failure, ")
      });
    }
  }, {
    key: "sendReaction",
    value:
    /**
     * Send a reaction inside the meeting.
     *
     * @param {ReactionType} reactionType - type of reaction to be sent. Example: "thumbs_up"
     * @param {SkinToneType} skinToneType - skin tone for the reaction. Example: "medium_dark"
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
    function sendReaction(reactionType, skinToneType) {
      var _this$locusInfo5, _this$locusInfo5$cont, _this$locusInfo5$cont2;
      var reactionChannelUrl = (_this$locusInfo5 = this.locusInfo) === null || _this$locusInfo5 === void 0 ? void 0 : (_this$locusInfo5$cont = _this$locusInfo5.controls) === null || _this$locusInfo5$cont === void 0 ? void 0 : (_this$locusInfo5$cont2 = _this$locusInfo5$cont.reactions) === null || _this$locusInfo5$cont2 === void 0 ? void 0 : _this$locusInfo5$cont2.reactionChannelUrl;
      var participantId = this.members.selfId;
      var reactionData = _reactions.Reactions[reactionType];
      if (!reactionData) {
        return _promise.default.reject(new Error("".concat(reactionType, " is not a valid reaction.")));
      }
      var skinToneData = _reactions.SkinTones[skinToneType] || _reactions.SkinTones.normal;
      var reaction = _objectSpread(_objectSpread({}, reactionData), {}, {
        tone: skinToneData
      });
      if (reactionChannelUrl) {
        return this.meetingRequest.sendReaction({
          reactionChannelUrl: reactionChannelUrl,
          reaction: reaction,
          participantId: participantId
        });
      }
      return _promise.default.reject(new Error('Error sending reaction, service url not found.'));
    }
  }]);
  return Meeting;
}(_webexCore.StatelessWebexPlugin);
exports.default = Meeting;
//# sourceMappingURL=index.js.map
