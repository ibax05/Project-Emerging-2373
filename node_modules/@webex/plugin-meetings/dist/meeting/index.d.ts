/// <reference types="node" />
import { StatelessWebexPlugin } from '@webex/webex-core';
import { StatsAnalyzer } from '../statsAnalyzer';
import NetworkQualityMonitor from '../networkQualityMonitor';
import Roap from '../roap/index';
import MediaProperties from '../media/properties';
import ReconnectionManager from '../reconnection-manager';
import MeetingRequest from './request';
import Members from '../members/index';
import Transcription from '../transcription';
import { ReactionType, SkinToneType } from '../reactions/reactions.type';
import InMeetingActions from './in-meeting-actions';
import RecordingController from '../recording-controller';
import ControlsOptionsManager from '../controls-options-manager';
export declare const MEDIA_UPDATE_TYPE: {
    ALL: string;
    AUDIO: string;
    VIDEO: string;
    SHARE: string;
};
/**
 * MediaDirection
 * @typedef {Object} MediaDirection
 * @property {boolean} sendAudio
 * @property {boolean} receiveAudio
 * @property {boolean} sendVideo
 * @property {boolean} receiveVideo
 * @property {boolean} sendShare
 * @property {boolean} receiveShare
 * @property {boolean} isSharing
 */
/**
 * AudioVideo
 * @typedef {Object} AudioVideo
 * @property {Object} audio
 * @property {String} audio.deviceId
 * @property {Object} video
 * @property {String} video.deviceId
 * @property {String} video.localVideoQuality // [240p, 360p, 480p, 720p, 1080p]
 */
/**
 * SharePreferences
 * @typedef {Object} SharePreferences
 * @property {Object} [shareConstraints]
 * @property {Boolean} [highFrameRate]
 */
/**
 * JoinOptions
 * @typedef {Object} JoinOptions
 * @property {String} [resourceId]
 * @property {String} [pin]
 * @property {Boolean} [moderator]
 * @property {String|Object} [meetingQuality]
 * @property {String} [meetingQuality.local]
 * @property {String} [meetingQuality.remote]
 * @property {Boolean} [rejoin]
 */
/**
 * SendOptions
 * @typedef {Object} SendOptions
 * @property {Boolean} sendAudio
 * @property {Boolean} sendVideo
 * @property {Boolean} sendShare
 */
/**
 * Recording
 * @typedef {Object} Recording
 * @property {Object} state
 * @property {String} modifiedBy
 */
/**
 * Meeting State Change Event
 * Emitted when ever there is a meeting state change
 * @event meeting:stateChange
 * @instance
 * @type {Object}
 * @property {String} currentState current state of the meeting
 * @property {String} previousState previous state of the meeting
 * @memberof Meeting
 */
/**
 * Media Ready Event
 * Emitted when a stream is ready to be rendered
 * @event media:ready
 * @instance
 * @type {Object}
 * @property {MediaStream} stream the media stream
 * @property {String} type what type of stream, remote, local
 * @memberof Meeting
 */
/**
 * Media Stopped Event
 * Emitted when a stream has stopped sending
 * @event media:stopped
 * @instance
 * @type {Object}
 * @property {String} type what type of stream, remote, local
 * @memberof Meeting
 */
/**
 * Meeting Ringing Event
 * Emitted when this client should play a ringing sound, because this member is getting an incoming meeting
 * or sending out an incoming meeting
 * @event meeting:ringing
 * @instance
 * @type {Object}
 * @property {String} type // INCOMING or JOIN
 * @property {String} id
 * @memberof Meeting
 */
/**
 * Meeting Ringing Stop Event
 * Emitted when this client should stop playing a ringing sound
 * @event meeting:ringingStop
 * @instance
 * @type {Object}
 * @property {Object} type
 * @property {Boolean} type.remoteAnswered
 * @property {Boolean} type.remoteDeclined
 * @property {String} id
 * @memberof Meeting
 */
/**
 * Meeting Started Sharing Local Event
 * Emitted when this member starts sharing
 * @event meeting:startedSharingLocal
 * @instance
 * @type {Object}
 * @memberof Meeting
 */
/**
 * Meeting Stopped Sharing Local Event
 * Emitted when this member stops sharing
 * @event meeting:stoppedSharingLocal
 * @instance
 * @type {Object}
 * @memberof Meeting
 */
/**
 * Meeting Started Sharing Remote Event
 * Emitted when remote sharing starts
 * @event meeting:startedSharingRemote
 * @instance
 * @type {Object}
 * @property {Boolean} memberId id of the meeting member that started screen share
 * @memberof Meeting
 */
/**
 * Meeting Stopped Sharing Remote Event
 * Emitted when remote screen sharing ends
 * @event meeting:stoppedSharingRemote
 * @instance
 * @type {Object}
 * @memberof Meeting
 */
/**
 * Meeting Locked Event
 * Emitted when a meeting is locked
 * @event meeting:locked
 * @instance
 * @type {Object}
 * @property {Object} info
 * @memberof Meeting
 */
/**
 * Meeting Unlocked Event
 * Emitted when a meeting is unlocked
 * @event meeting:unlocked
 * @instance
 * @type {Object}
 * @property {Object} info
 * @memberof Meeting
 */
/**
 * Meeting Actions Update Event
 * Emitted when a user can take actions on a meeting such as lock, unlock, assign host
 * @event meeting:actionsUpdate
 * @instance
 * @type {Object}
 * @property {Boolean} canLock
 * @property {Boolean} canUnlock
 * @property {Boolean} canAssignHost
 * @memberof Meeting
 */
/**
 * Meeting Unmuted By Others Event
 * Emitted when a member is unmuted by another member
 * @event meeting:self:unmutedByOthers
 * @instance
 * @type {Object}
 * @property {Object} payload
 * @memberof Meeting
 */
/**
 * Meeting Muted By Others Event
 * Emitted when a member is muted by another member
 * @event meeting:self:mutedByOthers
 * @instance
 * @type {Object}
 * @property {Object} payload
 * @property {Boolean} payload.unmuteAllowed - whether the user is allowed to unmute self
 * @memberof Meeting
 */
/**
 * Meeting Muted By Others Event
 * Emitted when the host(moderator)/co-host requests a user to unmute
 * @event meeting:self:requestedToUnmute
 * @instance
 * @type {Object}
 * @property {Object} payload
 * @memberof Meeting
 */
/**
 * Meeting Self Guest Admitted Event
 * Emitted when a joined user get admitted to the meeting by another member or host
 * @event meeting:self:guestAdmitted
 * @instance
 * @type {Object}
 * @property {Object} payload
 * @memberof Meeting
 */
/**
 * Meeting Self Lobby Waiting Event
 * Emitted when joined user enters the lobby and is waiting for the webex meeting to begin
 * @event meeting:self:lobbyWaiting
 * @instance
 * @type {Object}
 * @property {Object} reason Reason why user left the meeting
 * @memberof Meeting
 */
/**
 * Meeting Self Left State
 * Emitted when user is inactive for more then 40 seconds, User can rejoin the meeting again
 * @event meeting:self:left
 * @instance
 * @type {Object}
 * @property {Object} payload
 * @memberof Meeting
 */
/**
 * Reconnection Starting Event
 * Emitted when reconnection of media to the active meeting was successful
 * @event meeting:reconnectionStarting
 * @instance
 * @memberof Meeting
 */
/**
 * Reconnection Success Event
 * Emitted when reconnection of media to the active meeting was successful
 * @event meeting:reconnectionSuccess
 * @instance
 * @type {Object}
 * @property {Object} reconnect
 * @memberof Meeting
 */
/**
 * Reconnection Failure Event
 * Emitted when reconnection of media to the active meeting was successful
 * @event meeting:reconnectionFailure
 * @instance
 * @type {Object}
 * @property {Error} error
 * @memberof Meeting
 */
/**
 * Meeting network quality event
 * Emitted on each interval of retrieving stats Analyzer data
 * @event network:quality
 * @type {Object}
 * @property {string} mediaType {video|audio}
 * @property {number} networkQualityScore - {1|0} 1 indicates acceptable uplink 0 indicates unacceptable uplink based on threshold
 * @memberof Meeting
 */
/**
 * @description Meeting is the crux of the plugin
 * @export
 * @class Meeting
 */
export default class Meeting extends StatelessWebexPlugin {
    attrs: any;
    audio: any;
    conversationUrl: string;
    correlationId: string;
    destination: string;
    destinationType: string;
    deviceUrl: string;
    effects: any;
    hostId: string;
    id: string;
    locusUrl: string;
    mediaConnections: any[];
    meetingFiniteStateMachine: any;
    meetingInfo: object;
    meetingRequest: MeetingRequest;
    members: Members;
    options: object;
    orgId: string;
    owner: string;
    partner: any;
    policy: string;
    reconnectionManager: ReconnectionManager;
    resource: string;
    roap: Roap;
    roapSeq: number;
    sipUri: string;
    type: string;
    userId: string;
    video: any;
    callEvents: any[];
    deferJoin: Promise<any>;
    dialInDeviceStatus: string;
    dialInUrl: string;
    dialOutDeviceStatus: string;
    dialOutUrl: string;
    fetchMeetingInfoTimeoutId: NodeJS.Timeout;
    floorGrantPending: boolean;
    hasJoinedOnce: boolean;
    hasWebsocketConnected: boolean;
    inMeetingActions: InMeetingActions;
    isLocalShareLive: boolean;
    isSharing: boolean;
    keepAliveTimerId: NodeJS.Timeout;
    lastVideoLayoutInfo: any;
    locusInfo: any;
    mediaProperties: MediaProperties;
    meetingInfoFailureReason: string;
    networkQualityMonitor: NetworkQualityMonitor;
    networkStatus: string;
    passwordStatus: string;
    queuedMediaUpdates: any[];
    recording: any;
    recordingController: RecordingController;
    controlsOptionsManager: ControlsOptionsManager;
    requiredCaptcha: any;
    shareStatus: string;
    statsAnalyzer: StatsAnalyzer;
    transcription: Transcription;
    receiveTranscription: boolean;
    updateMediaConnections: (mediaConnections: any[]) => void;
    endCallInitiateJoinReq: any;
    endJoinReqResp: any;
    endLocalSDPGenRemoteSDPRecvDelay: any;
    joinedWith: any;
    locusId: any;
    startCallInitiateJoinReq: any;
    startJoinReqResp: any;
    startLocalSDPGenRemoteSDPRecvDelay: any;
    wirelessShare: any;
    guest: any;
    meetingJoinUrl: any;
    meetingNumber: any;
    meetingState: any;
    permissionToken: any;
    resourceId: any;
    resourceUrl: string;
    selfId: string;
    state: any;
    namespace: string;
    /**
     * @param {Object} attrs
     * @param {Object} options
     * @constructor
     * @memberof Meeting
     */
    constructor(attrs: any, options: object);
    /**
     * Fetches meeting information.
     * @param {Object} options
     * @param {String} [options.password] optional
     * @param {String} [options.captchaCode] optional
     * @public
     * @memberof Meeting
     * @returns {Promise}
     */
    fetchMeetingInfo({ password, captchaCode, }: {
        password?: string;
        captchaCode?: string;
    }): Promise<void>;
    /**
     * Checks if the supplied password/host key is correct. It returns a promise with information whether the
     * password and captcha code were correct or not.
     * @param {String} password - this can be either a password or a host key, can be undefined if only captcha was required
     * @param {String} captchaCode - can be undefined if captcha was not required by the server
     * @public
     * @memberof Meeting
     * @returns {Promise<{isPasswordValid: boolean, requiredCaptcha: boolean, failureReason: MEETING_INFO_FAILURE_REASON}>}
     */
    verifyPassword(password: string, captchaCode: string): Promise<{
        isPasswordValid: boolean;
        requiredCaptcha: any;
        failureReason: string;
    } | {
        isPasswordValid: boolean;
        requiredCaptcha: any;
        failureReason: string;
    }>;
    /**
     * Refreshes the captcha. As a result the meeting will have new captcha id, image and audio.
     * If the refresh operation fails, meeting remains with the old captcha properties.
     * @public
     * @memberof Meeting
     * @returns {Promise}
     */
    refreshCaptcha(): any;
    /**
     * Proxy function for all the listener set ups
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
    private setUpLocusInfoListeners;
    /**
     * Set up the locus info listener for meetings disconnected due to inactivity
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
    private setUpLocusInfoMediaInactiveListener;
    /**
     * Set up the locus info listener for assign host permissions on a meeting
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
    private setUpLocusInfoAssignHostListener;
    /**
     * Set up the internal locus info full state object listener
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
    private setUpLocusFullStateListener;
    /**
     * get the metrics payload pre
     * @param {Object} options
     * @param {String} options.event
     * @param {String} options.trackingId
     * @param {Object} options.locus
     * @param {Array} options.mediaConnections
     * @param {Object} options.errors
     * @returns {Object}
     * @memberof Meeting
     */
    getAnalyzerMetricsPrePayload(options: {
        event: string;
        trackingId: string;
        locus: object;
        mediaConnections: Array<any>;
        errors: object;
    } | any): {};
    /**
     * Send the metrics to call-analyzer dashboard
     * @param {Object} options
     * @param {String} options.event
     * @param {String} options.trackingId
     * @param {Object} options.locus
     * @param {Object} options.errors
     * @returns {Promise}
     * @private
     * @memberof Meeting
     */
    private sendCallAnalyzerMetrics;
    /**
     * Send the metrics to Media Quality Analyzer dashboard
     * @param {Object} options
     * @param {String} options.event
     * @param {String} options.trackingId
     * @param {Object} options.locus
     * @returns {Promise}
     * @private
     * @memberof Meeting
     */
    private sendMediaQualityAnalyzerMetrics;
    /**
     * sets the network status on meeting object
     * @param {String} networkStatus
     * @private
     * @returns {undefined}
     * @memberof Meeting
     */
    private setNetworkStatus;
    /**
     * Set up the locus info self listener
     * update self value for members and updates the member
     * notifies consumer with members:self:update {activeSelfId endedSelfId}
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
    private setUpLocusSelfListener;
    /**
     * Notify any changes on the pstn devices
     * @param {Object} payload
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
    private pstnUpdate;
    /**
     * Set up the locus info host listener
     * update host value for members and updates the member
     * notifies consumer with members:host:update: {activeHostId, endedHostId}
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
    private setUpLocusHostListener;
    /**
     * Set up the locus info participants update listener
     * update members collection value for members
     * notifies consumer with members:update
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
    private setUpLocusParticipantsListener;
    /**
     * Set up the locus info recording update listener
     * update recording value for the meeting
     * notifies consumer with:
     *  meeting:recording:started
     *  meeting:recording:stopped
     *  meeting:recording:paused
     *  meeting:recording:resumed
     *
     * Set up the locus info meeeting container listener
     * update meetingContainerUrl value for the meeting
     * notifies consumer with:
     *  meeting:meetingContainer:update
     *
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
    private setupLocusControlsListener;
    /**
     * Set up the locus info media shares listener
     * update content and whiteboard sharing id value for members, and updates the member
     * notifies consumer with members:content:update {activeContentSharingId, endedContentSharingId}
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
    private setUpLocusMediaSharesListener;
    /**
     * Set up the locus info url listener
     * update locus_url value for members
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
    private setUpLocusUrlListener;
    /**
     * Set up the locus info service link listener
     * update the locusInfo for recording controller
     * does not currently re-emit the event as it's internal only
     * payload is unused
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
    private setUpLocusServicesListener;
    /**
     * Set up the locus info meeting info listener
     * @returns {undefined}
     * @private
     * @memberof meeting
     */
    private setUpLocusInfoMeetingInfoListener;
    /**
     * Set up the locus info embedded apps listener
     * @returns {undefined}
     * @private
     * @memberof meeting
     */
    private setUpLocusEmbeddedAppsListener;
    /**
     * Internal function to listen to the self object changes
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
    private setUpLocusInfoSelfListener;
    /**
     * Add LocusInfo nested object listeners (from child to parent)
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
    private setUpLocusInfoMeetingListener;
    /**
     * Set meeting values rather than events
     * @param {Object} object
     * @returns {undefined}
     * @private
     * @memberof Meeting
     * // TODO: is this function necessary?
     */
    private updateMeetingObject;
    /**
     * Invite a guest to the call that isn't normally part of this call
     * @param {Object} invitee
     * @param {String} invitee.emailAddress
     * @param {String} invitee.email
     * @param {String} invitee.phoneNumber
     * @param {Boolean} [alertIfActive]
     * @returns {Promise} see #members.addMember
     * @public
     * @memberof Meeting
     */
    invite(invitee: {
        emailAddress: string;
        email: string;
        phoneNumber: string;
    }, alertIfActive?: boolean): any;
    /**
     * Cancel an outgoing phone call invitation made during a meeting
     * @param {Object} invitee
     * @param {String} invitee.phoneNumber
     * @returns {Promise} see #members.cancelPhoneInvite
     * @public
     * @memberof Meeting
     */
    cancelPhoneInvite(invitee: {
        phoneNumber: string;
    }): any;
    /**
     * Admit the guest(s) to the call once they are waiting
     * @param {Array} memberIds
     * @returns {Promise} see #members.admitMembers
     * @public
     * @memberof Meeting
     */
    admit(memberIds: Array<any>): any;
    /**
     * Remove the member from the meeting, boot them
     * @param {String} memberId
     * @returns {Promise} see #members.removeMember
     * @public
     * @memberof Meeting
     */
    remove(memberId: string): any;
    /**
     * Mute another member from the meeting
     * @param {String} memberId
     * @param {Boolean} mute
     * @returns {Promise} see #members.muteMember
     * @public
     * @memberof Meeting
     */
    mute(memberId: string, mute?: boolean): any;
    /**
     * Transfer the moderator role to another eligible member
     * @param {String} memberId
     * @param {Boolean} moderator
     * @returns {Promise} see #members.transferHostToMember
     * @public
     * @memberof Meeting
     */
    transfer(memberId: string, moderator?: boolean): any;
    /**
     * Reference to the Members object
     * @returns {Members}
     * @public
     * @memberof Meeting
     */
    getMembers(): Members;
    /**
     * Truthy when a meeting has an audio connection established
     * @returns {Boolean}  true if meeting audio is connected otherwise false
     * @public
     * @memberof Meeting
     */
    isAudioConnected(): boolean;
    /**
     * Convenience function to tell whether a meeting is muted
     * @returns {Boolean} if meeting audio muted or not
     * @public
     * @memberof Meeting
     */
    isAudioMuted(): any;
    /**
     * Convenience function to tell if the end user last changed the audio state
     * @returns {Boolean} if audio was manipulated by the end user
     * @public
     * @memberof Meeting
     */
    isAudioSelf(): any;
    /**
     * Truthy when a meeting has a video connection established
     * @returns {Boolean} true if meeting video connected otherwise false
     * @public
     * @memberof Meeting
     */
    isVideoConnected(): boolean;
    /**
     * Convenience function to tell whether video is muted
     * @returns {Boolean} if meeting video is muted or not
     * @public
     * @memberof Meeting
     */
    isVideoMuted(): any;
    /**
     * Convenience function to tell whether the end user changed the video state
     * @returns {Boolean} if meeting video is muted or not
     * @public
     * @memberof Meeting
     */
    isVideoSelf(): any;
    /**
     * Sets the meeting info on the class instance
     * @param {Object} meetingInfo
     * @param {Object} meetingInfo.body
     * @param {String} meetingInfo.body.conversationUrl
     * @param {String} meetingInfo.body.locusUrl
     * @param {String} meetingInfo.body.sipUri
     * @param {Object} meetingInfo.body.owner
     * @param {Object | String} destination locus object with meeting data or destination string (sip url, meeting link, etc)
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
    parseMeetingInfo(meetingInfo: {
        body: {
            conversationUrl: string;
            locusUrl: string;
            sipUri: string;
            owner: object;
        };
    } | any, destination?: object | string | null): void;
    /**
     * Sets the first locus info on the class instance
     * @param {Object} locus
     * @param {String} locus.url
     * @param {Array} locus.participants
     * @param {Object} locus.self
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
    private parseLocus;
    /**
     * Sets the sip uri on the class instance
     * uses meeting info as precedence
     * @param {String} sipUri
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
    setSipUri(sipUri: string): void;
    /**
     * Set the roap seq on the class instance
     * @param {Number} seq
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
    setRoapSeq(seq: number): void;
    /**
     * Set the locus info the class instance
     * @param {Object} locus
     * @param {Array} locus.mediaConnections
     * @param {String} locus.locusUrl
     * @param {String} locus.locusId
     * @param {String} locus.mediaId
     * @param {Object} locus.host
     * @todo change name to genertic parser
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
    private setLocus;
    /**
     * Sets the remote stream on the class instance and emits and
     * event to developers
     * @param {Object} pc The remote stream peer connection
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */
    setRemoteStream(pc: any): void;
    /**
     * Upload logs for the current meeting
     * @param {object} options file name and function name
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */
    uploadLogs(options?: object): void;
    /**
     * Removes remote audio and video stream on the class instance and triggers an event
     * to developers
     * @returns {undefined}
     * @public
     * @memberof Meeting
     * @deprecated after v1.89.3
     */
    unsetRemoteStream(): void;
    /**
     * Removes remote audio, video and share tracks from class instance's mediaProperties
     * @returns {undefined}
     */
    unsetRemoteTracks(): void;
    /**
     * Removes the remote stream on the class instance and triggers an event
     * to developers
     * @returns {undefined}
     * @public
     * @memberof Meeting
     * @deprecated after v1.89.3
     */
    closeRemoteStream(): void;
    /**
     * Removes the remote tracks on the class instance and triggers an event
     * to developers
     * @returns {undefined}
     * @memberof Meeting
     */
    closeRemoteTracks(): Promise<[any, any, any]>;
    /**
     * Emits the 'media:ready' event with a local stream that consists of 1 local audio and 1 local video track
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
    private sendLocalMediaReadyEvent;
    /**
     * Sets the local audio track on the class and emits an event to the developer
     * @param {MediaStreamTrack} audioTrack
     * @param {Boolean} emitEvent if true, a media ready event is emitted to the developer
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
    private setLocalAudioTrack;
    /**
     * Sets the local video track on the class and emits an event to the developer
     * @param {MediaStreamTrack} videoTrack
     * @param {Boolean} emitEvent if true, a media ready event is emitted to the developer
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
    private setLocalVideoTrack;
    /**
     * Sets the local media stream on the class and emits an event to the developer
     * @param {Stream} localStream the local media stream
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */
    setLocalTracks(localStream: any): void;
    /**
     * Sets the local media stream on the class and emits an event to the developer
     * @param {MediaStream} localShare the local media stream
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */
    setLocalShareTrack(localShare: MediaStream): void;
    /**
     * Closes the local stream from the class and emits an event to the developer
     * @returns {undefined}
     * @event media:stopped
     * @public
     * @memberof Meeting
     */
    closeLocalStream(): any;
    /**
     * Closes the local stream from the class and emits an event to the developer
     * @returns {undefined}
     * @event media:stopped
     * @public
     * @memberof Meeting
     */
    closeLocalShare(): any;
    /**
     * Removes the local stream from the class and emits an event to the developer
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */
    unsetLocalVideoTrack(): void;
    /**
     * Removes the local share from the class and emits an event to the developer
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */
    unsetLocalShareTrack(): void;
    /**
     * sets up listner for mercury event
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */
    setMercuryListener(): void;
    /**
     * Close the peer connections and remove them from the class. Triggers an event
     * when each is closed.
     * @returns {Promise} returns a resolved promise with an array of closed peer connections
     * @public
     * @memberof Meeting
     */
    closePeerConnections(): any;
    /**
     * Unsets the peer connections on the class
     * warning DO NOT CALL WITHOUT CLOSING PEER CONNECTIONS FIRST
     * @param {PeerConnection} peerConnection
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */
    unsetPeerConnections(): void;
    /**
     * Convenience method to set the correlation id for the Meeting
     * @param {String} id correlation id to set on the class
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
    private setCorrelationId;
    /**
     * Mute the audio for a meeting
     * @returns {Promise} resolves the data from muting audio {mute, self} or rejects if there is no audio set
     * @public
     * @memberof Meeting
     */
    muteAudio(): any;
    /**
     * Unmute meeting audio
     * @returns {Promise} resolves data from muting audio {mute, self} or rejects if there is no audio set
     * @public
     * @memberof Meeting
     */
    unmuteAudio(): any;
    /**
     * Mute the video for a meeting
     * @returns {Promise} resolves data from muting video {mute, self} or rejects if there is no video set
     * @public
     * @memberof Meeting
     */
    muteVideo(): any;
    /**
     * Unmute meeting video
     * @returns {Promise} resolves data from muting video {mute, self} or rejects if there is no video set
     * @public
     * @memberof Meeting
     */
    unmuteVideo(): any;
    /**
     * Shorthand function to join AND set up media
     * @param {Object} options - options to join with media
     * @param {JoinOptions} [options.joinOptions] - see #join()
     * @param {MediaDirection} options.mediaSettings - see #addMedia()
     * @param {AudioVideo} [options.audioVideoOptions] - see #getMediaStreams()
     * @returns {Promise} -- {join: see join(), media: see addMedia(), local: see getMediaStreams()}
     * @public
     * @memberof Meeting
     * @example
     * joinWithMedia({
     *  joinOptions: {resourceId: 'resourceId' },
     *  mediaSettings: {
     *   sendAudio: true,
     *   sendVideo: true,
     *   sendShare: false,
     *   receiveVideo:true,
     *   receiveAudio: true,
     *   receiveShare: true
     * }
     * audioVideoOptions: {
     *   audio: 'audioDeviceId',
     *   video: 'videoDeviceId'
     * }})
     */
    joinWithMedia(options?: {
        joinOptions?: any;
        mediaSettings: any;
        audioVideoOptions?: any;
    }): any;
    /**
     * Initiates the reconnection of the media in the meeting
     *
     * @param {object} options
     * @returns {Promise} resolves with {reconnect} or errors with {error}
     * @public
     * @memberof Meeting
     */
    reconnect(options?: object): any;
    /**
     * Check if the meeting supports the Webex Assistant feature
     * @returns {boolean}
     * @throws TranscriptionNotSupportedError
     */
    isTranscriptionSupported(): boolean;
    /**
     * Monitor the Low-Latency Mercury (LLM) web socket connection on `onError` and `onClose` states
     * @private
     * @returns {void}
     */
    private monitorTranscriptionSocketConnection;
    /**
     * Request for a WebSocket Url, open and monitor the WebSocket connection
     * @private
     * @returns {Promise<void>} a promise to open the WebSocket connection
     */
    private startTranscription;
    /**
     * stop recieving Transcription by closing
     * the web socket connection properly
     * @returns {void}
     */
    stopReceivingTranscription(): void;
    /**
     * triggers an event to notify that the user
     * will not receive any more transcription
     * @private
     * @returns{void}
     */
    private triggerStopReceivingTranscriptionEvent;
    /**
     * Specify joining via audio (option: pstn), video, screenshare
     * @param {JoinOptions} options A configurable options object for joining a meeting
     * @returns {Promise} the join response
     * @public
     * @memberof Meeting
     * Scenario A: Joining own claimed personal meeting room
     * Scenario B: Joining other's claimed personal meeting room, do pass pin (if desired to join as host, or nullify), do pass moderator
     * Scenario C: Joining an unclaimed personal meeting room, -do not- pass pin or moderator on first try, -do- pass pin and moderator
     *             if joining as host on second loop, pass pin and pass moderator if joining as guest on second loop
     * Scenario D: Joining any other way (sip, pstn, conversationUrl, link just need to specify resourceId)
     */
    join(options?: any): any;
    /**
     * Use phone for meeting audio
     * @param {String} phoneNumber If provided, it will dial-out using this number. If not provided, dial-in will be used
     * @returns {Promise} Resolves once the dial-in or dial-out request has completed, or rejects if it failed
     * @public
     * @memberof Meeting
     */
    usePhoneAudio(phoneNumber: string): any;
    /**
     * Determines if the given pstnStatus is in a state which implies the phone is provisioned
     * @param {String} pstnStatus
     * @returns {Boolean}
     * @private
     * @memberof Meeting
     */
    private isPhoneProvisioned;
    /**
     * Enable dial-in for audio
     * @returns {Promise} Resolves once the dial-in request has completed, or rejects if it failed
     * @private
     * @memberof Meeting
     */
    private dialInPstn;
    /**
     * Enable dial-out for audio
     * @param {String} phoneNumber Phone number to dial out to
     * @returns {Promise} Resolves once the dial-out request has completed (it doesn't wait for the user to answer the phone), or rejects if it failed
     * @private
     * @memberof Meeting
     */
    private dialOutPstn;
    /**
     * Disconnect meeting audio via phone.
     * @returns {Promise} Resolves once the phone audio disconnection has completed
     * @public
     * @memberof Meeting
     * @returns {Promise}
     */
    disconnectPhoneAudio(): Promise<[any, any]>;
    /**
     * Moves the call to the specified resourceId
     * @param {String} resourceId
     * @returns {Promise} once the move has been completed
     * @public
     * @memberof Meeting
     */
    moveTo(resourceId: string): any;
    /**
     * Moves the call from the specified resourceId, back to computer
     * @param {String} resourceId
     * @returns {Promise} once the move has been completed
     * @public
     * @memberof Meeting
     */
    moveFrom(resourceId: string): any;
    /**
     * Get local media streams based on options passed
     * @param {MediaDirection} mediaDirection A configurable options object for joining a meeting
     * @param {AudioVideo} [audioVideo] audio/video object to set audioinput and videoinput devices, see #Media.getUserMedia
     * @param {SharePreferences} [sharePreferences] audio/video object to set audioinput and videoinput devices, see #Media.getUserMedia
     * @returns {Promise} see #Media.getUserMedia
     * @public
     * @todo should be static, or moved so can be called outside of a meeting
     * @memberof Meeting
     */
    getMediaStreams: (mediaDirection: any, audioVideo?: any, sharePreferences?: any) => any;
    /**
     * Checks if the machine has at least one audio or video device
     * @param {Object} options
     * @param {Boolean} options.sendAudio
     * @param {Boolean} options.sendVideo
     * @returns {Object}
     * @memberof Meetings
     */
    getSupportedDevices: ({ sendAudio, sendVideo, }: {
        sendAudio: boolean;
        sendVideo: boolean;
    }) => any;
    /**
     * Get the devices from the Media module
     * @returns {Promise} resolves to an array of DeviceInfo
     * @memberof Meetings
     */
    getDevices: () => any;
    /**
     * Registers for all required StatsAnalyzer events
     * @private
     * @returns {void}
     * @memberof Meetings
     */
    setupStatsAnalyzerEventHandlers: () => void;
    /**
     * Specify joining via audio (option: pstn), video, screenshare
     * @param {Object} options A configurable options object for joining a meeting
     * @param {Object} options.resourceId pass the deviceId
     * @param {MediaDirection} options.mediaSettings pass media options
     * @param {MediaStream} options.localStream
     * @param {MediaStream} options.localShare
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
    addMedia(options?: any): any;
    /**
     * Informs if the peer connection is in a state that can be updated with updateMedia (audio/video/share)
     * @returns {Boolean}
     */
    canUpdateMedia(): boolean;
    /**
     * Enqueues a media update operation.
     * @param {String} mediaUpdateType one of MEDIA_UPDATE_TYPE values
     * @param {Object} options
     * @returns {Promise}
     * @private
     * @memberof Meeting
     */
    private enqueueMediaUpdate;
    /**
     * emits event when the negotation is completed
     * @returns {void}
     * @private
     * @memberof Meeting
     */
    mediaNegotiatedEvent: () => void;
    /**
     * Checks if there are any queued media updates and runs the first one from
     * the queue if we are in a state that allows doing that.
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */
    processNextQueuedMediaUpdate: () => void;
    /**
     * A confluence of updateAudio, updateVideo, and updateShare
     * this function re-establishes all of the media streams with new options
     * @param {Object} options
     * @param {MediaStream} options.localStream
     * @param {MediaStream} options.localShare
     * @param {MediaDirection} options.mediaSettings
     * @returns {Promise}
     * @todo fix setRemoteStream for updateMedia
     * @public
     * @memberof Meeting
     */
    updateMedia(options?: {
        localStream?: MediaStream;
        localShare?: MediaStream;
        mediaSettings?: any;
    }): any;
    /**
     * Update the main audio track with new parameters
     * @param {Object} options
     * @param {boolean} options.sendAudio
     * @param {boolean} options.receiveAudio
     * @param {MediaStream} options.stream Stream that contains the audio track to update
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
    updateAudio(options: {
        sendAudio: boolean;
        receiveAudio: boolean;
        stream: MediaStream;
    }): Promise<any>;
    /**
     * Update the main video track with new parameters
     * @param {Object} options
     * @param {boolean} options.sendVideo
     * @param {boolean} options.receiveVideo
     * @param {MediaStream} options.stream Stream that contains the video track to update
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
    updateVideo(options: {
        sendVideo: boolean;
        receiveVideo: boolean;
        stream: MediaStream;
    }): any;
    /**
     * Internal function when stopping a share stream, cleanup
     * @param {boolean} sendShare
     * @param {boolean} previousShareStatus
     * @returns {Promise}
     * @private
     * @memberof Meeting
     */
    private checkForStopShare;
    /**
     * Update the share streams, can be used to start sharing
     * @param {Object} options
     * @param {boolean} options.sendShare
     * @param {boolean} options.receiveShare
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
    updateShare(options: {
        sendShare?: boolean;
        receiveShare?: boolean;
        stream?: any;
        skipSignalingCheck?: boolean;
    }): any;
    /**
     * Do all the attach media pre set up before executing the actual attach
     * @param {MediaStream} localStream
     * @param {MediaStream} localShare
     * @param {MediaDirection} mediaSettings
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */
    private preMedia;
    /**
     * Acknowledge the meeting, outgoing or incoming
     * @param {String} type
     * @returns {Promise} resolve {message, ringing, response}
     * @public
     * @memberof Meeting
     */
    acknowledge(type: string): any;
    /**
     * Decline this meeting
     * @param {String} reason
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */
    decline(reason: string): any;
    /**
     * Leave the current meeting
     * @param {Object} options leave options
     * @param {String} options.resourceId the device with which to leave from, empty if just the computer
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
    leave(options?: {
        resourceId?: string;
        reason?: any;
    }): any;
    /**
     * Start sharing whiteboard given channelUrl
     * @param {string} channelUrl whiteboard url
     * @param {String} resourceToken token created by authorize media injector
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
    startWhiteboardShare(channelUrl: string, resourceToken: string): any;
    /**
     * Stop sharing whiteboard given channelUrl
     * @param {string} channelUrl whiteboard url
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
    stopWhiteboardShare(channelUrl: string): any;
    /**
     * Sends a request to Locus to obtain the screen share floor
     * @returns {Promise} see #meetingRequest.changeMeetingFloor
     * @private
     * @memberof Meeting
     */
    private requestScreenShareFloor;
    /**
     * Stops the screen share
     * @returns {Promise} see #updateShare
     * @public
     * @memberof Meeting
     */
    stopShare(options?: {}): any;
    /**
     * Sends a request to Locus to release the screen share floor.
     * @returns {Promise} see #meetingRequest.changeMeetingFloor
     * @private
     * @memberof Meeting
     */
    private releaseScreenShareFloor;
    /**
     * Intiate a recording of this meeting
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
    startRecording(): Promise<any>;
    /**
     * set the mute on entry flag for participants if you're the host
     * @returns {Promise}
     * @param {boolean} enabled
     * @public
     * @memberof Meeting
     */
    setMuteOnEntry(enabled: boolean): Promise<any>;
    /**
     * set the disallow unmute flag for participants if you're the host
     * @returns {Promise}
     * @param {boolean} enabled
     * @public
     * @memberof Meeting
     */
    setDisallowUnmute(enabled: boolean): Promise<any>;
    /**
     * End the recording of this meeting
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
    stopRecording(): Promise<any>;
    /**
     * Pauses the recording of this meeting
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
    pauseRecording(): Promise<any>;
    /**
     * Resumes the recording of this meeting
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
    resumeRecording(): Promise<any>;
    /**
     * Locks the current meeting if possible
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
    lockMeeting(): any;
    /**
     * Unlocks the current meeting if possible
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
    unlockMeeting(): any;
    /**
     * Logs an error message and returns a rejected promise with same message
     * @param {String} message
     * @returns {Promise}
     * @private
     * @memberof Meeting
     */
    private rejectWithErrorLog;
    /**
     * Sends DTMF tones to the current meeting
     * @param {String} tones a string of one or more DTMF tones to send
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
    sendDTMF(tones: string): any;
    /**
     * Sends request to change layout type for the current meeting for the specific participant/device only
     * @param {String} [layoutType] a layout type that should be available in meeting constants {@link #layout_types}
     * @param {Object} renderInfo preferred dimensions for the remote main and content streams (server can ignore it)
     * @param {Object} renderInfo.main preferred dimensions for the remote main video stream
     * @param {Number} renderInfo.main.width preferred width of main video stream
     * @param {Number} renderInfo.main.height preferred height of main video stream
     * @param {Object} renderInfo.content preferred dimensions for the remote content share stream
     * @param {Number} renderInfo.content.width preferred width of content share stream
     * @param {Number} renderInfo.content.height preferred height of content share stream
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
    changeVideoLayout(layoutType?: string, renderInfo?: {
        main: {
            width: number;
            height: number;
        };
        content: {
            width: number;
            height: number;
        };
    }): any;
    /**
     * Sets the quality of the local video stream
     * @param {String} level {LOW|MEDIUM|HIGH}
     * @returns {Promise<MediaStream>} localStream
     */
    setLocalVideoQuality(level: string): any;
    /**
     * Sets the quality level of the remote incoming media
     * @param {String} level {LOW|MEDIUM|HIGH}
     * @returns {Promise}
     */
    setRemoteQualityLevel(level: string): any;
    /**
     * This is deprecated, please use setLocalVideoQuality for setting local and setRemoteQualityLevel for remote
     * @param {String} level {LOW|MEDIUM|HIGH}
     * @returns {Promise}
     * @deprecated After FHD support
     */
    setMeetingQuality(level: string): any;
    /**
     * @param {Object} options parameter
     * @param {Boolean} options.sendAudio send audio from the display share
     * @param {Boolean} options.sendShare send video from the display share
     * @param {Object} options.sharePreferences
     * @param {MediaTrackConstraints} options.sharePreferences.shareConstraints constraints to apply to video
     *   @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints}
     * @param {Boolean} options.sharePreferences.highFrameRate if shareConstraints isn't provided, set default values based off of this boolean
     * @returns {Promise}
     */
    shareScreen(options?: {
        sendAudio: boolean;
        sendShare: boolean;
        sharePreferences: {
            shareConstraints: MediaTrackConstraints;
        };
    }): any;
    /**
     * Functionality for when a share is ended.
     * @private
     * @memberof Meeting
     * @param {MediaStream} localShare
     * @returns {undefined}
     */
    private handleShareTrackEnded;
    /**
     * Emits the 'network:quality' event
     * 1 indicates an acceptable uplink network.
     * 0 indicates an unacceptable uplink network based on a predefined threshold
     * @returns {undefined}
     * @param {Object} res - payload of emitNetworkQuality
     * @property {string} mediaType {video|audio}
     * @property {number} networkQualityScore - {1|0}
     * @private
     * @memberof Meeting
     */
    private sendNetworkQualityEvent;
    /**
     * Handle logging the media
     * @param {Object} audioTrack The audio track
     * @param {Object} videoTrack The video track
     * @private
     * @returns {undefined}
     */
    private handleMediaLogging;
    /**
     * @param {string} typeMedia 'audio' or 'video'
     * @returns {undefined}
     */
    setStartSetupDelay(typeMedia: string): void;
    /**
     * @param {string} typeMedia 'audio' or 'video'
     * @returns {undefined}
     */
    setEndSetupDelay(typeMedia: string): void;
    /**
     * @param {string} typeMedia 'audio' or 'video'
     * @returns {string} duration between start and end of setup
     */
    getSetupDelayDuration(typeMedia: string): number;
    /**
     * @param {string} typeMedia 'audio' or 'video'
     * @returns {undefined}
     */
    setStartSendingMediaDelay(typeMedia: string): void;
    /**
     * @param {string} typeMedia 'audio' or 'video'
     * @returns {undefined}
     */
    setEndSendingMediaDelay(typeMedia: string): void;
    /**
     * @param {string} typeMedia 'audio' or 'video'
     * @returns {string} duration between join response and first media tx
     */
    getSendingMediaDelayDuration(typeMedia: string): number;
    /**
     *
     * @returns {undefined}
     */
    setStartLocalSDPGenRemoteSDPRecvDelay(): void;
    /**
     *
     * @returns {undefined}
     */
    setEndLocalSDPGenRemoteSDPRecvDelay(): void;
    /**
     *
     * @returns {string} duration between local SDP generation and remote SDP reception
     */
    getLocalSDPGenRemoteSDPRecvDelay(): number;
    /**
     *
     * @returns {undefined}
     */
    setStartCallInitiateJoinReq(): void;
    /**
     *
     * @returns {undefined}
     */
    setEndCallInitiateJoinReq(): void;
    /**
     *
     * @returns {string} duration between call initiate and sending join request to locus
     */
    getCallInitiateJoinReq(): number;
    /**
     *
     * @returns {undefined}
     */
    setStartJoinReqResp(): void;
    /**
     *
     * @returns {undefined}
     */
    setEndJoinReqResp(): void;
    /**
     *
     * @returns {string} duration between sending locus join request and receiving join response
     */
    getJoinReqResp(): number;
    /**
     *
     * @returns {string} duration between call initiate and successful locus join (even if it is in lobby)
     */
    getTotalJmt(): number;
    /**
     * End the current meeting for all
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
    endMeetingForAll(): any;
    /**
     * clear the meeting data
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */
    clearMeetingData: () => void;
    /**
     * Internal API to return status of BNR
     * @returns {Boolean}
     * @public
     * @memberof Meeting
     */
    isBnrEnabled(): any;
    /**
     * Internal API to obtain BNR enabled MediaStream
     * @returns {Promise<MediaStreamTrack>}
     * @private
     * @param {MedaiStreamTrack} audioTrack from updateAudio
     * @memberof Meeting
     */
    private internal_enableBNR;
    /**
     * Enable the audio track with BNR for a meeting
     * @returns {Promise} resolves the data from enable bnr or rejects if there is no audio or audio is muted
     * @public
     * @memberof Meeting
     */
    enableBNR(): any;
    /**
     * Disable the BNR for an audio track
     * @returns {Promise} resolves the data from disable bnr or rejects if there is no audio set
     * @public
     * @memberof Meeting
     */
    disableBNR(): any;
    /**
     * starts keepAlives being sent
     * @returns {void}
     * @private
     * @memberof Meeting
     */
    startKeepAlive: () => void;
    /**
     * stops keepAlives being sent
     * @returns {void}
     * @private
     * @memberof Meeting
     */
    stopKeepAlive: () => void;
    /**
     * Send a reaction inside the meeting.
     *
     * @param {ReactionType} reactionType - type of reaction to be sent. Example: "thumbs_up"
     * @param {SkinToneType} skinToneType - skin tone for the reaction. Example: "medium_dark"
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
    sendReaction(reactionType: ReactionType, skinToneType?: SkinToneType): any;
}
