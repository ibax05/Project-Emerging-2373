"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _parseInt2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/parse-int"));
var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));
var _tsSdp = require("@webex/ts-sdp");
var PeerConnectionUtils = {};

// max-fs values for all H264 profile levels
var maxFsForProfileLevel = {
  10: 99,
  11: 396,
  12: 396,
  13: 396,
  20: 396,
  21: 792,
  22: 1620,
  30: 1620,
  31: 3600,
  32: 5120,
  40: 8192,
  41: 8192,
  42: 8704,
  50: 22080,
  51: 36864,
  52: 36864,
  60: 139264,
  61: 139264,
  62: 139264
};
var framesPerSecond = 30;

/**
 * Convert C line to IPv4
 * @param {string} sdp
 * @returns {string}
 */
PeerConnectionUtils.convertCLineToIpv4 = function (sdp) {
  var replaceSdp = sdp;

  // TODO: remove this once linus supports Ipv6 c line.currently linus rejects SDP with c line having ipv6 candidates we are
  // mocking ipv6 to ipv4 candidates
  // https://jira-eng-gpk2.cisco.com/jira/browse/SPARK-299232
  replaceSdp = replaceSdp.replace(/c=IN IP6 .*/gi, 'c=IN IP4 0.0.0.0');
  return replaceSdp;
};

/**
 * estimate profile levels for max-fs & max-mbps values
 * @param {string} sdp
 * @param {number} maxFsValue
 * @returns {string}
 */
PeerConnectionUtils.adjustH264Profile = function (sdp, maxFsValue) {
  // converting with ts-sdp parser, no munging
  var parsedSdp = (0, _tsSdp.parse)(sdp);
  parsedSdp.avMedia.forEach(function (media) {
    if (media.type === 'video') {
      media.codecs.forEach(function (codec) {
        var _codec$name;
        if (((_codec$name = codec.name) === null || _codec$name === void 0 ? void 0 : _codec$name.toUpperCase()) === 'H264') {
          // there should really be just 1 fmtp line, but just in case, we process all of them
          codec.fmtParams = codec.fmtParams.map(function (fmtp) {
            var parsedRegex = fmtp.match(/(.*)profile-level-id=(\w{4})(\w{2})(.*)/);
            if (parsedRegex && parsedRegex.length === 5) {
              var stuffBeforeProfileLevelId = parsedRegex[1];
              var profile = parsedRegex[2].toLowerCase();
              var levelId = (0, _parseInt2.default)(parsedRegex[3], 16);
              var stuffAfterProfileLevelId = parsedRegex[4];
              if (!maxFsForProfileLevel[levelId]) {
                throw new Error("found unsupported h264 profile level id value in the SDP: ".concat(levelId));
              }
              if (maxFsForProfileLevel[levelId] === maxFsValue) {
                // profile level already matches our desired max-fs value, so we don't need to do anything
                return fmtp;
              }
              if (maxFsForProfileLevel[levelId] < maxFsValue) {
                // profile level has too low max-fs, so we need to override it (this is upgrading)
                return "".concat(fmtp, ";max-fs=").concat(maxFsValue, ";max-mbps=").concat(maxFsValue * framesPerSecond);
              }

              // profile level has too high max-fs value, so we need to use a lower level

              // find highest level that has the matching maxFs
              var newLevelId = (0, _keys.default)(maxFsForProfileLevel).reverse().find(function (key) {
                return maxFsForProfileLevel[key] === maxFsValue;
              });
              if (newLevelId) {
                // Object.keys returns keys as strings, so we need to parse it to an int again and then convert to hex
                var newLevelIdHex = (0, _parseInt2.default)(newLevelId, 10).toString(16);
                return "".concat(stuffBeforeProfileLevelId, "profile-level-id=").concat(profile).concat(newLevelIdHex, ";max-mbps=").concat(maxFsValue * framesPerSecond).concat(stuffAfterProfileLevelId);
              }
              throw new Error("unsupported maxFsValue: ".concat(maxFsValue));
            }
            return fmtp;
          });
        }
      });
    }
  });
  return parsedSdp.toString();
};
var _default = PeerConnectionUtils;
exports.default = _default;
//# sourceMappingURL=util.js.map
