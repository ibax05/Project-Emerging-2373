/**
 * @description Metrics handles all the call metrics events
 * @export
 * @class Metrics
 */
declare class Metrics {
    static instance: Metrics;
    _events: any;
    keys: any;
    meetingCollection: any;
    webex: any;
    /**
     * Create Metrics Object
     * @constructor
     * @public
     * @memberof Meetings
     */
    constructor();
    /**
     * Initializes the Metrics singleton with a meeting Collection.
     *
     * @param {Object} meetingCollection meetings object
     * @param {Object} webex  webex SDK object
     *
     * @returns {void}
     */
    initialSetup(meetingCollection: object, webex: object): void;
    /**
     * poste Meeting event metrics
     * @param {object} options {meetingId/meeting} as a json object
     * @param {Meeting} options.meeting Meeting object
     * @param {String} options.meetingId
     * @param {object} options.data
     * @param {object} options.event
     * @returns {object} null
     */
    postEvent(options: {
        meeting?: any;
        meetingId?: string;
        data?: object;
        event?: any;
    } | any): void;
    /**
     *  Docs for Call analyzer metrics
     *   https://sqbu-github.cisco.com/WebExSquared/call-analyzer/wiki
     *   https://sqbu-github.cisco.com/WebExSquared/event-dictionary/blob/master/diagnostic-events.raml
     */
    initPayload(eventType: any, identifiers: any, options: any): any;
    /**
     * get the payload specific for a media quality event through call analyzer
     * @param {String} eventType the event name
     * @param {Object} identifiers contains the identifiers needed for CA
     * @param {String} identifiers.correlationId
     * @param {String} identifiers.locusUrl
     * @param {String} identifiers.locusId
     * @param {Object} options
     * @param {Object} options.intervalData
     * @param {String} options.clientType
     * @returns {Object}
     * @public
     * @memberof Metrics
     */
    initMediaPayload(eventType: string, identifiers: {
        correlationId: string;
        locusUrl: string;
        locusId: string;
    }, options?: {
        intervalData: object;
        clientType: string;
    } | any): {
        eventId: any;
        version: number;
        origin: {
            audioSetupDelay: any;
            videoSetupDelay: any;
            name: string;
            networkType: any;
            userAgent: string;
            clientInfo: {
                clientType: any;
                clientVersion: string;
                localNetworkPrefix: string;
                os: any;
                osVersion: any;
                subClientType: any;
                browser: any;
                browserVersion: any;
            };
        };
        originTime: {
            triggered: string;
        };
        senderCountryCode: any;
        event: {
            name: string;
            canProceed: boolean;
            identifiers: {
                correlationId: string;
                locusUrl: string;
                locusId: string;
            };
            intervals: any[];
            joinTimes: any;
            eventData: {
                webClientDomain: any;
            };
            sourceMetadata: {
                applicationSoftwareType: string;
                applicationSoftwareVersion: any;
                mediaEngineSoftwareType: any;
                mediaEngineSoftwareVersion: any;
                startTime: string;
            };
        };
    };
    /**
     * This function Parses a Locus error and returns a diagnostic event payload.
     * It should keep updating from:
     * https://sqbu-github.cisco.com/WebExSquared/spark-client-framework/blob/master/spark-client-framework/Adapters/TelephonyAdapter/TelephonyAdapter.cpp#L920
     *
     * @param {Object} err the error Object from Locus response
     * @param {boolean} showToUser true if a toast is shown to user
     * @returns {{showToUser: boolean, category: string, errorDescription: string,
     *  errorCode: number, errorData: *, fatal: boolean, name: string}}
     */
    parseLocusError(err: any, showToUser: boolean): any;
    generateErrorPayload(errorCode: any, shownToUser: any, name: any, err: any): any;
    /**
     * Returns a formated string of the user agent.
     *
     * @returns {string} formatted user agent information
     */
    userAgentToString(): string;
    /**
     * Uploads given metric to the Metrics service as an Behavioral metric.
     * Metadata about the environment such as browser, OS, SDK and their versions
     * are automatically added when the metric is sent.
     *
     * The Metrics service will send an Behavioral metric to InfluxDB for
     * aggregation.
     * See https://confluence-eng-gpk2.cisco.com/conf/display/WBXT/Getting+started+with+Metrics+Service.
     *
     * @param {string} metricName  Name of the metric (measurement) to send
     * @param {Object} metricFields  Key-valye pairs of data or values about this metric
     * @param {Object} metricTags  Key-value pairs of metric metadata
     *
     * @returns {void}
     */
    sendBehavioralMetric(metricName: string, metricFields?: object, metricTags?: object): void;
}
declare const instance: Metrics;
export default instance;
