/// <reference types="node" />
import EventsScope from '../common/events/events-scope';
export declare const EVENTS: {
    MEDIA_QUALITY: string;
    NO_FRAMES_SENT: string;
    NO_VIDEO_ENCODED: string;
    LOCAL_MEDIA_STARTED: string;
    LOCAL_MEDIA_STOPPED: string;
    REMOTE_MEDIA_STARTED: string;
    REMOTE_MEDIA_STOPPED: string;
};
/**
 * Stats Analyzer class that will emit events based on detected quality
 *
 * @export
 * @class StatsAnalyzer
 * @extends {EventsScope}
 */
export declare class StatsAnalyzer extends EventsScope {
    config: any;
    correlationId: any;
    lastEmittedStartStopEvent: any;
    lastMqaDataSent: any;
    lastStatsResults: any;
    localMQEStats: any;
    meetingMediaStatus: any;
    mqaInterval: NodeJS.Timeout;
    mqaSentCount: any;
    networkQualityMonitor: any;
    peerConnection: any;
    statsInterval: NodeJS.Timeout;
    statsResults: any;
    statsStarted: any;
    /**
     * Creates a new instance of StatsAnalyzer
     * @constructor
     * @public
     * @param {Object} config SDK Configuration Object
     * @param {Object} networkQualityMonitor class for assessing network characteristics (jitter, packetLoss, latency)
     * @param {Object} statsResults Default properties for stats
     */
    constructor(config: any, networkQualityMonitor?: object, statsResults?: object);
    populateResults(lastMqa: any): void;
    resetStatsResults(): void;
    /**
     * sets mediaStatus status for analyzing metrics
     *
     * @public
     * @param {Object} status for the audio and video
     * @memberof StatsAnalyzer
     * @returns {void}
     */
    updateMediaStatus(status: object): void;
    /**
     * captures MQA data from peerconnection
     *
     * @public
     * @memberof StatsAnalyzer
     * @returns {void}
     */
    sendMqaData(): void;
    /**
     * updated the peerconnection when changed
     *
     * @private
     * @memberof updatePeerconnection
     * @param {PeerConnection} peerConnection
     * @returns {void}
     */
    updatePeerconnection(peerConnection: any): void;
    /**
     * Starts the stats analyzer on interval
     *
     * @public
     * @memberof StatsAnalyzer
     * @param {PeerConnection} peerConnection
     * @returns {Promise}
     */
    startAnalyzer(peerConnection: any): Promise<void>;
    /**
     * Cleans up the analyzer when done
     *
     * @public
     * @memberof StatsAnalyzer
     * @returns {void}
     */
    stopAnalyzer(): Promise<void>;
    /**
     * Parse a single result of get stats
     *
     * @private
     * @param {*} getStatsResult
     * @param {String} type
     * @param {boolean} isSender
     * @returns {void}
     * @memberof StatsAnalyzer
     */
    private parseGetStatsResult;
    /**
     * Filters the get stats results for types
     * @private
     * @param {Array} getStatsResults
     * @param {String} type
     * @param {boolean} isSender
     * @returns {void}
     */
    private filterAndParseGetStatsResults;
    /**
     * parse the audio
     * @param {String} result
     * @param {boolean} type
     * @returns {void}
     */
    parseAudioSource(result: any, type: any): void;
    /**
     * emits started/stopped events for local/remote media by checking
     * if given values are increasing or not. The previousValue, currentValue
     * params can be any numerical value like number of receive packets or
     * decoded frames, etc.
     *
     * @private
     * @param {string} mediaType
     * @param {number} previousValue - value to compare
     * @param {number} currentValue - value to compare (must be same type of value as previousValue)
     * @param {boolean} isLocal - true if stats are for local media being sent out, false for remote media being received
     * @memberof StatsAnalyzer
     * @returns {void}
     */
    emitStartStopEvents: (mediaType: string, previousValue: number, currentValue: number, isLocal: boolean) => void;
    /**
     * compares current and previous stats to check if packets are not sent
     *
     * @private
     * @memberof StatsAnalyzer
     * @returns {void}
     */
    private compareLastStatsResult;
    /**
     * Does a `getStats` on all the transceivers and parses the results
     *
     * @private
     * @memberof StatsAnalyzer
     * @returns {Promise}
     */
    private getStatsAndParse;
    /**
     * Processes OutboundRTP stats result and stores
     * @private
     * @param {*} result
     * @param {*} type
     * @returns {void}
     */
    private processOutboundRTPResult;
    /**
     * Processes InboundRTP stats result and stores
     * @private
     * @param {*} result
     * @param {*} type
     * @returns {void}
     */
    private processInboundRTPResult;
    /**
     * Processes remote and local candidate result and stores
     * @private
     * @param {*} result
     * @param {*} type
     * @param {boolean} isSender
     * @param {boolean} isRemote
     *
     * @returns {void}
     */
    parseCandidate: (result: any, type: any, isSender: boolean, isRemote: boolean) => void;
    /**
     * Process Track results
     *
     * @private
     * @param {*} result
     * @param {*} mediaType
     * @param {*} sendrecvType
     * @returns {void}
     * @memberof StatsAnalyzer
     */
    private processTrackResult;
    /**
     *
     * @private
     * @param {*} result
     * @param {*} type
     * @returns {void}
     * @memberof StatsAnalyzer
     */
    private compareSentAndReceived;
}
