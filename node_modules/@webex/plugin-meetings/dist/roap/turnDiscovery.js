"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));
var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));
var _stringify = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));
var _common = require("@webex/common");
var _metrics = _interopRequireDefault(require("../metrics"));
var _constants = _interopRequireDefault(require("../metrics/constants"));
var _loggerProxy = _interopRequireDefault(require("../common/logs/logger-proxy"));
var _constants2 = require("../constants");
// @ts-ignore - Types not available for @webex/common

var TURN_DISCOVERY_TIMEOUT = 10; // in seconds

/**
 * Handles the process of finding out TURN server information from Linus.
 * This is achieved by sending a TURN_DISCOVERY_REQUEST.
 */
var TurnDiscovery = /*#__PURE__*/function () {
  // used for waiting for the response

  /**
   * Constructor
   *
   * @param {RoapRequest} roapRequest
   */
  function TurnDiscovery(roapRequest) {
    (0, _classCallCheck2.default)(this, TurnDiscovery);
    (0, _defineProperty2.default)(this, "roapRequest", void 0);
    (0, _defineProperty2.default)(this, "defer", void 0);
    (0, _defineProperty2.default)(this, "turnInfo", void 0);
    (0, _defineProperty2.default)(this, "responseTimer", void 0);
    this.roapRequest = roapRequest;
    this.turnInfo = {
      url: '',
      username: '',
      password: ''
    };
  }

  /**
   * waits for TURN_DISCOVERY_RESPONSE message to arrive
   *
   * @returns {Promise}
   * @private
   * @memberof Roap
   */
  (0, _createClass2.default)(TurnDiscovery, [{
    key: "waitForTurnDiscoveryResponse",
    value: function waitForTurnDiscoveryResponse() {
      if (!this.defer) {
        _loggerProxy.default.logger.warn('Roap:turnDiscovery#waitForTurnDiscoveryResponse --> TURN discovery is not in progress');
        return _promise.default.reject(new Error('waitForTurnDiscoveryResponse() called before sendRoapTurnDiscoveryRequest()'));
      }
      var defer = this.defer;
      this.responseTimer = setTimeout(function () {
        _loggerProxy.default.logger.warn("Roap:turnDiscovery#waitForTurnDiscoveryResponse --> timeout! no response arrived within ".concat(TURN_DISCOVERY_TIMEOUT, " seconds"));
        defer.reject(new Error('Timed out waiting for TURN_DISCOVERY_RESPONSE'));
      }, TURN_DISCOVERY_TIMEOUT * 1000);
      _loggerProxy.default.logger.info('Roap:turnDiscovery#waitForTurnDiscoveryResponse --> waiting for TURN_DISCOVERY_RESPONSE...');
      return defer.promise;
    }

    /**
     * handles TURN_DISCOVERY_RESPONSE roap message
     *
     * @param {Object} roapMessage
     * @returns {void}
     * @public
     * @memberof Roap
     */
  }, {
    key: "handleTurnDiscoveryResponse",
    value: function handleTurnDiscoveryResponse(roapMessage) {
      var _this = this;
      // @ts-ignore - Fix missing type
      var headers = roapMessage.headers;
      if (!this.defer) {
        _loggerProxy.default.logger.warn('Roap:turnDiscovery#handleTurnDiscoveryResponse --> unexpected TURN discovery response');
        return;
      }
      var expectedHeaders = [{
        headerName: 'x-cisco-turn-url',
        field: 'url'
      }, {
        headerName: 'x-cisco-turn-username',
        field: 'username'
      }, {
        headerName: 'x-cisco-turn-password',
        field: 'password'
      }];
      var foundHeaders = 0;
      headers === null || headers === void 0 ? void 0 : headers.forEach(function (receivedHeader) {
        // check if it matches any of our expected headers
        expectedHeaders.forEach(function (expectedHeader) {
          if (receivedHeader.startsWith("".concat(expectedHeader.headerName, "="))) {
            _this.turnInfo[expectedHeader.field] = receivedHeader.substring(expectedHeader.headerName.length + 1);
            foundHeaders += 1;
          }
        });
      });
      clearTimeout(this.responseTimer);
      this.responseTimer = undefined;
      if (foundHeaders !== expectedHeaders.length) {
        _loggerProxy.default.logger.warn("Roap:turnDiscovery#handleTurnDiscoveryResponse --> missing some headers, received: ".concat((0, _stringify.default)(headers)));
        this.defer.reject(new Error("TURN_DISCOVERY_RESPONSE missing some headers: ".concat((0, _stringify.default)(headers))));
      } else {
        _loggerProxy.default.logger.info("Roap:turnDiscovery#handleTurnDiscoveryResponse --> received a valid response, url=".concat(this.turnInfo.url));
        this.defer.resolve();
      }
    }

    /**
     * sends the TURN_DISCOVERY_REQUEST roap request
     *
     * @param {Meeting} meeting
     * @param {Boolean} isReconnecting
     * @returns {Promise}
     * @private
     * @memberof Roap
     */
  }, {
    key: "sendRoapTurnDiscoveryRequest",
    value: function sendRoapTurnDiscoveryRequest(meeting, isReconnecting) {
      var _meeting$audio, _meeting$video;
      var seq = meeting.roapSeq + 1;
      if (this.defer) {
        _loggerProxy.default.logger.warn('Roap:turnDiscovery#sendRoapTurnDiscoveryRequest --> already in progress');
        return _promise.default.resolve();
      }
      this.defer = new _common.Defer();
      var roapMessage = {
        messageType: _constants2.ROAP.ROAP_TYPES.TURN_DISCOVERY_REQUEST,
        version: _constants2.ROAP.ROAP_VERSION,
        seq: seq
      };
      _loggerProxy.default.logger.info('Roap:turnDiscovery#sendRoapTurnDiscoveryRequest --> sending TURN_DISCOVERY_REQUEST');
      return this.roapRequest.sendRoap({
        roapMessage: roapMessage,
        correlationId: meeting.correlationId,
        // @ts-ignore - Fix missing type
        locusSelfUrl: meeting.selfUrl,
        // @ts-ignore - Fix missing type
        mediaId: isReconnecting ? '' : meeting.mediaId,
        audioMuted: (_meeting$audio = meeting.audio) === null || _meeting$audio === void 0 ? void 0 : _meeting$audio.isLocallyMuted(),
        videoMuted: (_meeting$video = meeting.video) === null || _meeting$video === void 0 ? void 0 : _meeting$video.isLocallyMuted(),
        meetingId: meeting.id
      }).then(function (_ref) {
        var mediaConnections = _ref.mediaConnections;
        meeting.setRoapSeq(seq);
        if (mediaConnections) {
          meeting.updateMediaConnections(mediaConnections);
        }
      });
    }

    /**
     * Sends the OK message that server expects to receive
     * after it sends us TURN_DISCOVERY_RESPONSE
     *
     * @param {Meeting} meeting
     * @returns {Promise}
     */
  }, {
    key: "sendRoapOK",
    value: function sendRoapOK(meeting) {
      var _meeting$audio2, _meeting$video2;
      _loggerProxy.default.logger.info('Roap:turnDiscovery#sendRoapOK --> sending OK');
      return this.roapRequest.sendRoap({
        roapMessage: {
          messageType: _constants2.ROAP.ROAP_TYPES.OK,
          version: _constants2.ROAP.ROAP_VERSION,
          seq: meeting.roapSeq
        },
        // @ts-ignore - fix type
        locusSelfUrl: meeting.selfUrl,
        // @ts-ignore - fix type
        mediaId: meeting.mediaId,
        correlationId: meeting.correlationId,
        audioMuted: (_meeting$audio2 = meeting.audio) === null || _meeting$audio2 === void 0 ? void 0 : _meeting$audio2.isLocallyMuted(),
        videoMuted: (_meeting$video2 = meeting.video) === null || _meeting$video2 === void 0 ? void 0 : _meeting$video2.isLocallyMuted(),
        meetingId: meeting.id
      });
    }

    /**
     * Retrieves TURN server information from the backend by doing
     * a roap message exchange:
     * client                             server
     *  | -----TURN_DISCOVERY_REQUEST-----> |
     *  | <----TURN_DISCOVERY_RESPONSE----- |
     *  | --------------OK----------------> |
     *
     * @param {Meeting} meeting
     * @param {Boolean} isReconnecting should be set to true if this is a new
     *                                 media connection just after a reconnection
     * @returns {Promise}
     */
  }, {
    key: "doTurnDiscovery",
    value: function () {
      var _doTurnDiscovery = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(meeting, isReconnecting) {
        var _this2 = this;
        var turnDiscoverySkippedReason;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.getSkipReason(meeting);
            case 2:
              turnDiscoverySkippedReason = _context.sent;
              if (!turnDiscoverySkippedReason) {
                _context.next = 5;
                break;
              }
              return _context.abrupt("return", {
                turnServerInfo: undefined,
                turnDiscoverySkippedReason: turnDiscoverySkippedReason
              });
            case 5:
              return _context.abrupt("return", this.sendRoapTurnDiscoveryRequest(meeting, isReconnecting).then(function () {
                return _this2.waitForTurnDiscoveryResponse();
              }).then(function () {
                return _this2.sendRoapOK(meeting);
              }).then(function () {
                _this2.defer = undefined;
                _loggerProxy.default.logger.info('Roap:turnDiscovery#doTurnDiscovery --> TURN discovery completed');
                return {
                  turnServerInfo: _this2.turnInfo,
                  turnDiscoverySkippedReason: undefined
                };
              }).catch(function (e) {
                // we catch any errors and resolve with no turn information so that the normal call join flow can continue without TURN
                _loggerProxy.default.logger.info("Roap:turnDiscovery#doTurnDiscovery --> TURN discovery failed, continuing without TURN: ".concat(e));
                _metrics.default.sendBehavioralMetric(_constants.default.TURN_DISCOVERY_FAILURE, {
                  correlation_id: meeting.correlationId,
                  locus_id: meeting.locusUrl.split('/').pop(),
                  reason: e.message,
                  stack: e.stack
                });
                return _promise.default.resolve({
                  turnServerInfo: undefined,
                  turnDiscoverySkippedReason: undefined
                });
              }));
            case 6:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function doTurnDiscovery(_x, _x2) {
        return _doTurnDiscovery.apply(this, arguments);
      }
      return doTurnDiscovery;
    }()
    /**
     * Gets the reason why reachability is skipped.
     *
     * @param {Meeting} meeting
     * @returns {Promise<string>} Promise with empty string if reachability is not skipped or a reason if it is skipped
     */
  }, {
    key: "getSkipReason",
    value: function () {
      var _getSkipReason = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(meeting) {
        var isAnyClusterReachable;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return meeting.webex.meetings.reachability.isAnyClusterReachable();
            case 2:
              isAnyClusterReachable = _context2.sent;
              if (!isAnyClusterReachable) {
                _context2.next = 6;
                break;
              }
              _loggerProxy.default.logger.info('Roap:turnDiscovery#getSkipReason --> reachability has not failed, skipping TURN discovery');
              return _context2.abrupt("return", 'reachability');
            case 6:
              if (meeting.config.experimental.enableTurnDiscovery) {
                _context2.next = 9;
                break;
              }
              _loggerProxy.default.logger.info('Roap:turnDiscovery#getSkipReason --> TURN discovery disabled in config, skipping it');
              return _context2.abrupt("return", 'config');
            case 9:
              return _context2.abrupt("return", '');
            case 10:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      function getSkipReason(_x3) {
        return _getSkipReason.apply(this, arguments);
      }
      return getSkipReason;
    }()
    /**
     * Checks if TURN discovery is skipped.
     *
     * @param {Meeting} meeting
     * @returns {Boolean} true if TURN discovery is being skipped, false if it is being done
     */
  }, {
    key: "isSkipped",
    value: function () {
      var _isSkipped = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(meeting) {
        var skipReason;
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this.getSkipReason(meeting);
            case 2:
              skipReason = _context3.sent;
              return _context3.abrupt("return", !!skipReason);
            case 4:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function isSkipped(_x4) {
        return _isSkipped.apply(this, arguments);
      }
      return isSkipped;
    }()
  }]);
  return TurnDiscovery;
}();
exports.default = TurnDiscovery;
//# sourceMappingURL=turnDiscovery.js.map
