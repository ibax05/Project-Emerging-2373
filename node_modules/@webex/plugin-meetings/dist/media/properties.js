"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));
var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));
var _constants = require("../constants");
var _loggerProxy = _interopRequireDefault(require("../common/logs/logger-proxy"));
var _util = _interopRequireDefault(require("./util"));
/**
 * @class MediaProperties
 */
var MediaProperties = /*#__PURE__*/function () {
  /**
   * @param {Object} [options] -- to auto construct
   * @returns {MediaProperties}
   */
  function MediaProperties() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, MediaProperties);
    (0, _defineProperty2.default)(this, "audioTrack", void 0);
    (0, _defineProperty2.default)(this, "localQualityLevel", void 0);
    (0, _defineProperty2.default)(this, "mediaDirection", void 0);
    (0, _defineProperty2.default)(this, "mediaSettings", void 0);
    (0, _defineProperty2.default)(this, "peerConnection", void 0);
    (0, _defineProperty2.default)(this, "remoteAudioTrack", void 0);
    (0, _defineProperty2.default)(this, "remoteQualityLevel", void 0);
    (0, _defineProperty2.default)(this, "remoteShare", void 0);
    (0, _defineProperty2.default)(this, "remoteVideoTrack", void 0);
    (0, _defineProperty2.default)(this, "shareTrack", void 0);
    (0, _defineProperty2.default)(this, "videoDeviceId", void 0);
    (0, _defineProperty2.default)(this, "videoTrack", void 0);
    (0, _defineProperty2.default)(this, "namespace", _constants.MEETINGS);
    this.peerConnection = _util.default.createPeerConnection();
    this.mediaDirection = options.mediaDirection;
    this.videoTrack = options.videoTrack;
    this.audioTrack = options.audioTrack;
    this.shareTrack = options.shareTrack;
    this.remoteShare = options.remoteShare;
    this.remoteAudioTrack = options.remoteAudioTrack;
    this.remoteVideoTrack = options.remoteVideoTrack;
    this.localQualityLevel = options.localQualityLevel || _constants.QUALITY_LEVELS['720p'];
    this.remoteQualityLevel = options.remoteQualityLevel || _constants.QUALITY_LEVELS.HIGH;
    this.mediaSettings = {};
    this.videoDeviceId = null;
  }

  /**
   * Retrieves the preferred video input device
   * @returns {Object|null}
   */
  (0, _createClass2.default)(MediaProperties, [{
    key: "getVideoDeviceId",
    value: function getVideoDeviceId() {
      return this.videoDeviceId || null;
    }
  }, {
    key: "setMediaDirection",
    value: function setMediaDirection(mediaDirection) {
      this.mediaDirection = mediaDirection;
    }
  }, {
    key: "setMediaSettings",
    value: function setMediaSettings(type, values) {
      this.mediaSettings[type] = values;
    }
  }, {
    key: "setMediaPeerConnection",
    value: function setMediaPeerConnection(peerConnection) {
      this.peerConnection = peerConnection;
    }
  }, {
    key: "setLocalVideoTrack",
    value: function setLocalVideoTrack(videoTrack) {
      this.videoTrack = videoTrack;
    }
  }, {
    key: "setLocalAudioTrack",
    value: function setLocalAudioTrack(audioTrack) {
      this.audioTrack = audioTrack;
    }
  }, {
    key: "setLocalQualityLevel",
    value: function setLocalQualityLevel(localQualityLevel) {
      this.localQualityLevel = localQualityLevel;
    }
  }, {
    key: "setLocalShareTrack",
    value: function setLocalShareTrack(shareTrack) {
      this.shareTrack = shareTrack;
    }
  }, {
    key: "setRemoteQualityLevel",
    value: function setRemoteQualityLevel(remoteQualityLevel) {
      this.remoteQualityLevel = remoteQualityLevel;
    }
  }, {
    key: "setRemoteShare",
    value: function setRemoteShare(remoteShare) {
      this.remoteShare = remoteShare;
    }

    /**
     * Sets the remote audio track
     * @param {MediaTrack} remoteAudioTrack MediaTrack to save
     * @returns {void}
     */
  }, {
    key: "setRemoteAudioTrack",
    value: function setRemoteAudioTrack(remoteAudioTrack) {
      this.remoteAudioTrack = remoteAudioTrack;
    }

    /**
     * Sets the remote video track
     * @param {MediaTrack} remoteVideoTrack MediaTrack to save
     * @returns {void}
     */
  }, {
    key: "setRemoteVideoTrack",
    value: function setRemoteVideoTrack(remoteVideoTrack) {
      this.remoteVideoTrack = remoteVideoTrack;
    }

    /**
     * Stores the preferred video input device
     * @param {string} deviceId Preferred video input device
     * @returns {void}
     */
  }, {
    key: "setVideoDeviceId",
    value: function setVideoDeviceId(deviceId) {
      this.videoDeviceId = deviceId;
    }
  }, {
    key: "unsetPeerConnection",
    value: function unsetPeerConnection() {
      this.peerConnection = null;
    }
  }, {
    key: "reInitiatePeerconnection",
    value: function reInitiatePeerconnection(turnServerInfo) {
      this.peerConnection = _util.default.createPeerConnection(turnServerInfo);
    }
  }, {
    key: "unsetLocalVideoTrack",
    value: function unsetLocalVideoTrack() {
      this.videoTrack = null;
    }
  }, {
    key: "unsetLocalShareTrack",
    value: function unsetLocalShareTrack() {
      this.shareTrack = null;
    }
  }, {
    key: "unsetLocalAudioTrack",
    value: function unsetLocalAudioTrack() {
      this.audioTrack = null;
    }

    /**
     * Removes remote stream from class instance
     * @deprecated after v1.89.3
     * @returns {void}
     */
  }, {
    key: "unsetRemoteStream",
    value: function unsetRemoteStream() {
      _loggerProxy.default.logger.warn('Media:properties#unsetRemoteStream --> [DEPRECATION WARNING]: unsetRemoteStream has been deprecated after v1.89.3 (use unsetRemoteTracks instead)');
      // unsets audio and video only
      this.unsetRemoteMedia();
    }

    /**
     * Removes both remote audio and video from class instance
     * @returns {void}
     */
  }, {
    key: "unsetRemoteMedia",
    value: function unsetRemoteMedia() {
      this.remoteAudioTrack = null;
      this.remoteVideoTrack = null;
    }
  }, {
    key: "unsetRemoteShare",
    value: function unsetRemoteShare() {
      this.remoteShare = null;
    }
  }, {
    key: "unsetLocalVideoTracks",
    value: function unsetLocalVideoTracks() {
      this.unsetLocalVideoTrack();
      this.unsetLocalShareTrack();
    }

    /**
     * Removes remote stream and remote share from class instance
     * @deprecated after v1.89.3
     * @returns {void}
     */
  }, {
    key: "unsetRemoteStreams",
    value: function unsetRemoteStreams() {
      _loggerProxy.default.logger.warn('Media:properties#unsetRemoteStreams --> [DEPRECATION WARNING]: unsetRemoteStreams has been deprecated after v1.89.3 (use unsetRemoteTracks instead)');
      this.unsetRemoteStream();
      this.unsetRemoteShare();
    }

    /**
     * Unsets all remote tracks
     * @returns {void}
     */
  }, {
    key: "unsetRemoteTracks",
    value: function unsetRemoteTracks() {
      this.unsetRemoteMedia();
      this.unsetRemoteShare();
    }
  }, {
    key: "unsetShareStreams",
    value: function unsetShareStreams() {
      this.unsetLocalShareTrack();
      this.unsetRemoteShare();
    }

    /**
     * Removes both local and remote video stream from class instance
     * @deprecated after v1.89.3
     * @returns {void}
     */
  }, {
    key: "unsetMediaStreams",
    value: function unsetMediaStreams() {
      _loggerProxy.default.logger.warn('Media:properties#unsetMediaStreams --> [DEPRECATION WARNING]: unsetMediaStreams has been deprecated after v1.89.3 (use unsetMediaTracks instead)');
      this.unsetLocalVideoTrack();
      this.unsetRemoteStream();
    }

    /**
     * Removes both local and remote video stream from class instance
     * @returns {void}
     */
  }, {
    key: "unsetMediaTracks",
    value: function unsetMediaTracks() {
      this.unsetLocalVideoTrack();
      this.unsetRemoteMedia();
    }

    /**
     * Waits until ice connection is established
     *
     * @returns {Promise<void>}
     */
  }, {
    key: "waitForIceConnectedState",
    value: function waitForIceConnectedState() {
      var _this = this;
      var isIceConnected = function isIceConnected() {
        return _this.peerConnection.iceConnectionState === _constants.ICE_STATE.CONNECTED || _this.peerConnection.iceConnectionState === _constants.ICE_STATE.COMPLETED;
      };
      if (isIceConnected()) {
        return _promise.default.resolve();
      }
      return new _promise.default(function (resolve, reject) {
        var timer;
        var iceListener = function iceListener() {
          _loggerProxy.default.logger.log("Media:properties#waitForIceConnectedState --> ice state: ".concat(_this.peerConnection.iceConnectionState, ", conn state: ").concat(_this.peerConnection.connectionState));
          if (isIceConnected()) {
            clearTimeout(timer);
            _this.peerConnection.removeEventListener('iceconnectionstatechange', iceListener);
            resolve();
          }
        };
        timer = setTimeout(function () {
          _this.peerConnection.removeEventListener('iceconnectionstatechange', iceListener);
          reject();
        }, _constants.PC_BAIL_TIMEOUT);
        _this.peerConnection.addEventListener('iceconnectionstatechange', iceListener);
      });
    }

    /**
     * Returns the type of a connection that has been established
     *
     * @returns {Promise<'UDP' | 'TCP' | 'TURN-TLS' | 'TURN-TCP' | 'TURN-UDP' | 'unknown'>}
     */
  }, {
    key: "getCurrentConnectionType",
    value: function () {
      var _getCurrentConnectionType = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
        var allStatsReports, statsResult, successfulCandidatePairs, foundConnectionType;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.waitForIceConnectedState();
            case 2:
              allStatsReports = [];
              _context.prev = 3;
              _context.next = 6;
              return this.peerConnection.getStats();
            case 6:
              statsResult = _context.sent;
              statsResult.forEach(function (report) {
                return allStatsReports.push(report);
              });
              _context.next = 13;
              break;
            case 10:
              _context.prev = 10;
              _context.t0 = _context["catch"](3);
              _loggerProxy.default.logger.warn("Media:properties#getCurrentConnectionType --> getStats() failed: ".concat(_context.t0));
            case 13:
              successfulCandidatePairs = allStatsReports.filter(function (report) {
                var _report$state;
                return report.type === 'candidate-pair' && ((_report$state = report.state) === null || _report$state === void 0 ? void 0 : _report$state.toLowerCase()) === 'succeeded';
              });
              foundConnectionType = 'unknown'; // all of the successful pairs should have the same connection type, so just return the type for the first one
              successfulCandidatePairs.some(function (pair) {
                var localCandidate = allStatsReports.find(function (report) {
                  return report.type === 'local-candidate' && report.id === pair.localCandidateId;
                });
                if (localCandidate === undefined) {
                  _loggerProxy.default.logger.warn("Media:properties#getCurrentConnectionType --> failed to find local candidate \"".concat(pair.localCandidateId, "\" in getStats() results"));
                  return false;
                }
                var connectionType;
                if (localCandidate.relayProtocol) {
                  connectionType = "TURN-".concat(localCandidate.relayProtocol.toUpperCase());
                } else {
                  var _localCandidate$proto;
                  connectionType = (_localCandidate$proto = localCandidate.protocol) === null || _localCandidate$proto === void 0 ? void 0 : _localCandidate$proto.toUpperCase(); // it will be UDP or TCP
                }

                if (connectionType) {
                  foundConnectionType = connectionType;
                  return true;
                }
                return false;
              });
              return _context.abrupt("return", foundConnectionType);
            case 17:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[3, 10]]);
      }));
      function getCurrentConnectionType() {
        return _getCurrentConnectionType.apply(this, arguments);
      }
      return getCurrentConnectionType;
    }()
  }]);
  return MediaProperties;
}();
exports.default = MediaProperties;
//# sourceMappingURL=properties.js.map
